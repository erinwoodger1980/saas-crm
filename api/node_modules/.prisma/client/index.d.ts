
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model EmailIngest
 * 
 */
export type EmailIngest = $Result.DefaultSelection<Prisma.$EmailIngestPayload>
/**
 * Model LeadFieldDef
 * 
 */
export type LeadFieldDef = $Result.DefaultSelection<Prisma.$LeadFieldDefPayload>
/**
 * Model GmailTenantConnection
 * 
 */
export type GmailTenantConnection = $Result.DefaultSelection<Prisma.$GmailTenantConnectionPayload>
/**
 * Model Ms365TenantConnection
 * 
 */
export type Ms365TenantConnection = $Result.DefaultSelection<Prisma.$Ms365TenantConnectionPayload>
/**
 * Model LeadExample
 * 
 */
export type LeadExample = $Result.DefaultSelection<Prisma.$LeadExamplePayload>
/**
 * Model LeadTrainingExample
 * 
 */
export type LeadTrainingExample = $Result.DefaultSelection<Prisma.$LeadTrainingExamplePayload>
/**
 * Model TenantSettings
 * *
 *  * ✅ Unified TenantSettings (only ONE model)
 */
export type TenantSettings = $Result.DefaultSelection<Prisma.$TenantSettingsPayload>
/**
 * Model FollowUpLog
 * 
 */
export type FollowUpLog = $Result.DefaultSelection<Prisma.$FollowUpLogPayload>
/**
 * Model LeadSourceCost
 * 
 */
export type LeadSourceCost = $Result.DefaultSelection<Prisma.$LeadSourceCostPayload>
/**
 * Model LeadSourceSpend
 * 
 */
export type LeadSourceSpend = $Result.DefaultSelection<Prisma.$LeadSourceSpendPayload>
/**
 * Model LeadSourceConfig
 * 
 */
export type LeadSourceConfig = $Result.DefaultSelection<Prisma.$LeadSourceConfigPayload>
/**
 * Model FollowupExperiment
 * 
 */
export type FollowupExperiment = $Result.DefaultSelection<Prisma.$FollowupExperimentPayload>
/**
 * Model EmailThread
 * 
 */
export type EmailThread = $Result.DefaultSelection<Prisma.$EmailThreadPayload>
/**
 * Model EmailMessage
 * 
 */
export type EmailMessage = $Result.DefaultSelection<Prisma.$EmailMessagePayload>
/**
 * Model Quote
 * *
 *  * =============== Quoting ===============
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model QuoteLine
 * 
 */
export type QuoteLine = $Result.DefaultSelection<Prisma.$QuoteLinePayload>
/**
 * Model UploadedFile
 * 
 */
export type UploadedFile = $Result.DefaultSelection<Prisma.$UploadedFilePayload>
/**
 * Model PasswordResetToken
 * *
 *  * ============== Password reset tokens ==============
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubscriptionStatus: {
  trialing: 'trialing',
  active: 'active',
  past_due: 'past_due',
  canceled: 'canceled',
  incomplete: 'incomplete',
  incomplete_expired: 'incomplete_expired',
  paused: 'paused'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const Plan: {
  monthly: 'monthly',
  annual: 'annual'
};

export type Plan = (typeof Plan)[keyof typeof Plan]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  DISQUALIFIED: 'DISQUALIFIED',
  INFO_REQUESTED: 'INFO_REQUESTED',
  REJECTED: 'REJECTED',
  READY_TO_QUOTE: 'READY_TO_QUOTE',
  QUOTE_SENT: 'QUOTE_SENT',
  WON: 'WON',
  LOST: 'LOST'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const OppStage: {
  QUALIFY: 'QUALIFY',
  PROPOSE: 'PROPOSE',
  NEGOTIATE: 'NEGOTIATE',
  WON: 'WON',
  LOST: 'LOST'
};

export type OppStage = (typeof OppStage)[keyof typeof OppStage]


export const LeadLabel: {
  LEAD: 'LEAD',
  NOT_LEAD: 'NOT_LEAD',
  UNSURE: 'UNSURE'
};

export type LeadLabel = (typeof LeadLabel)[keyof typeof LeadLabel]


export const QuoteStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type QuoteStatus = (typeof QuoteStatus)[keyof typeof QuoteStatus]


export const FileKind: {
  SUPPLIER_QUOTE: 'SUPPLIER_QUOTE',
  OTHER: 'OTHER'
};

export type FileKind = (typeof FileKind)[keyof typeof FileKind]

}

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type OppStage = $Enums.OppStage

export const OppStage: typeof $Enums.OppStage

export type LeadLabel = $Enums.LeadLabel

export const LeadLabel: typeof $Enums.LeadLabel

export type QuoteStatus = $Enums.QuoteStatus

export const QuoteStatus: typeof $Enums.QuoteStatus

export type FileKind = $Enums.FileKind

export const FileKind: typeof $Enums.FileKind

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailIngest`: Exposes CRUD operations for the **EmailIngest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailIngests
    * const emailIngests = await prisma.emailIngest.findMany()
    * ```
    */
  get emailIngest(): Prisma.EmailIngestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadFieldDef`: Exposes CRUD operations for the **LeadFieldDef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadFieldDefs
    * const leadFieldDefs = await prisma.leadFieldDef.findMany()
    * ```
    */
  get leadFieldDef(): Prisma.LeadFieldDefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gmailTenantConnection`: Exposes CRUD operations for the **GmailTenantConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GmailTenantConnections
    * const gmailTenantConnections = await prisma.gmailTenantConnection.findMany()
    * ```
    */
  get gmailTenantConnection(): Prisma.GmailTenantConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ms365TenantConnection`: Exposes CRUD operations for the **Ms365TenantConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ms365TenantConnections
    * const ms365TenantConnections = await prisma.ms365TenantConnection.findMany()
    * ```
    */
  get ms365TenantConnection(): Prisma.Ms365TenantConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadExample`: Exposes CRUD operations for the **LeadExample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadExamples
    * const leadExamples = await prisma.leadExample.findMany()
    * ```
    */
  get leadExample(): Prisma.LeadExampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadTrainingExample`: Exposes CRUD operations for the **LeadTrainingExample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadTrainingExamples
    * const leadTrainingExamples = await prisma.leadTrainingExample.findMany()
    * ```
    */
  get leadTrainingExample(): Prisma.LeadTrainingExampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantSettings`: Exposes CRUD operations for the **TenantSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantSettings
    * const tenantSettings = await prisma.tenantSettings.findMany()
    * ```
    */
  get tenantSettings(): Prisma.TenantSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followUpLog`: Exposes CRUD operations for the **FollowUpLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowUpLogs
    * const followUpLogs = await prisma.followUpLog.findMany()
    * ```
    */
  get followUpLog(): Prisma.FollowUpLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadSourceCost`: Exposes CRUD operations for the **LeadSourceCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadSourceCosts
    * const leadSourceCosts = await prisma.leadSourceCost.findMany()
    * ```
    */
  get leadSourceCost(): Prisma.LeadSourceCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadSourceSpend`: Exposes CRUD operations for the **LeadSourceSpend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadSourceSpends
    * const leadSourceSpends = await prisma.leadSourceSpend.findMany()
    * ```
    */
  get leadSourceSpend(): Prisma.LeadSourceSpendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadSourceConfig`: Exposes CRUD operations for the **LeadSourceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadSourceConfigs
    * const leadSourceConfigs = await prisma.leadSourceConfig.findMany()
    * ```
    */
  get leadSourceConfig(): Prisma.LeadSourceConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followupExperiment`: Exposes CRUD operations for the **FollowupExperiment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowupExperiments
    * const followupExperiments = await prisma.followupExperiment.findMany()
    * ```
    */
  get followupExperiment(): Prisma.FollowupExperimentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailThread`: Exposes CRUD operations for the **EmailThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailThreads
    * const emailThreads = await prisma.emailThread.findMany()
    * ```
    */
  get emailThread(): Prisma.EmailThreadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailMessage`: Exposes CRUD operations for the **EmailMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailMessages
    * const emailMessages = await prisma.emailMessage.findMany()
    * ```
    */
  get emailMessage(): Prisma.EmailMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quoteLine`: Exposes CRUD operations for the **QuoteLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteLines
    * const quoteLines = await prisma.quoteLine.findMany()
    * ```
    */
  get quoteLine(): Prisma.QuoteLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uploadedFile`: Exposes CRUD operations for the **UploadedFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UploadedFiles
    * const uploadedFiles = await prisma.uploadedFile.findMany()
    * ```
    */
  get uploadedFile(): Prisma.UploadedFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Lead: 'Lead',
    Opportunity: 'Opportunity',
    EmailIngest: 'EmailIngest',
    LeadFieldDef: 'LeadFieldDef',
    GmailTenantConnection: 'GmailTenantConnection',
    Ms365TenantConnection: 'Ms365TenantConnection',
    LeadExample: 'LeadExample',
    LeadTrainingExample: 'LeadTrainingExample',
    TenantSettings: 'TenantSettings',
    FollowUpLog: 'FollowUpLog',
    LeadSourceCost: 'LeadSourceCost',
    LeadSourceSpend: 'LeadSourceSpend',
    LeadSourceConfig: 'LeadSourceConfig',
    FollowupExperiment: 'FollowupExperiment',
    EmailThread: 'EmailThread',
    EmailMessage: 'EmailMessage',
    Quote: 'Quote',
    QuoteLine: 'QuoteLine',
    UploadedFile: 'UploadedFile',
    PasswordResetToken: 'PasswordResetToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "lead" | "opportunity" | "emailIngest" | "leadFieldDef" | "gmailTenantConnection" | "ms365TenantConnection" | "leadExample" | "leadTrainingExample" | "tenantSettings" | "followUpLog" | "leadSourceCost" | "leadSourceSpend" | "leadSourceConfig" | "followupExperiment" | "emailThread" | "emailMessage" | "quote" | "quoteLine" | "uploadedFile" | "passwordResetToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpportunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      EmailIngest: {
        payload: Prisma.$EmailIngestPayload<ExtArgs>
        fields: Prisma.EmailIngestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailIngestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailIngestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>
          }
          findFirst: {
            args: Prisma.EmailIngestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailIngestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>
          }
          findMany: {
            args: Prisma.EmailIngestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>[]
          }
          create: {
            args: Prisma.EmailIngestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>
          }
          createMany: {
            args: Prisma.EmailIngestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailIngestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>[]
          }
          delete: {
            args: Prisma.EmailIngestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>
          }
          update: {
            args: Prisma.EmailIngestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>
          }
          deleteMany: {
            args: Prisma.EmailIngestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailIngestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailIngestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>[]
          }
          upsert: {
            args: Prisma.EmailIngestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIngestPayload>
          }
          aggregate: {
            args: Prisma.EmailIngestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailIngest>
          }
          groupBy: {
            args: Prisma.EmailIngestGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailIngestGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailIngestCountArgs<ExtArgs>
            result: $Utils.Optional<EmailIngestCountAggregateOutputType> | number
          }
        }
      }
      LeadFieldDef: {
        payload: Prisma.$LeadFieldDefPayload<ExtArgs>
        fields: Prisma.LeadFieldDefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFieldDefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFieldDefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>
          }
          findFirst: {
            args: Prisma.LeadFieldDefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFieldDefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>
          }
          findMany: {
            args: Prisma.LeadFieldDefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>[]
          }
          create: {
            args: Prisma.LeadFieldDefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>
          }
          createMany: {
            args: Prisma.LeadFieldDefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadFieldDefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>[]
          }
          delete: {
            args: Prisma.LeadFieldDefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>
          }
          update: {
            args: Prisma.LeadFieldDefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>
          }
          deleteMany: {
            args: Prisma.LeadFieldDefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadFieldDefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadFieldDefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>[]
          }
          upsert: {
            args: Prisma.LeadFieldDefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadFieldDefPayload>
          }
          aggregate: {
            args: Prisma.LeadFieldDefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadFieldDef>
          }
          groupBy: {
            args: Prisma.LeadFieldDefGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadFieldDefGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadFieldDefCountArgs<ExtArgs>
            result: $Utils.Optional<LeadFieldDefCountAggregateOutputType> | number
          }
        }
      }
      GmailTenantConnection: {
        payload: Prisma.$GmailTenantConnectionPayload<ExtArgs>
        fields: Prisma.GmailTenantConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GmailTenantConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GmailTenantConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>
          }
          findFirst: {
            args: Prisma.GmailTenantConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GmailTenantConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>
          }
          findMany: {
            args: Prisma.GmailTenantConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>[]
          }
          create: {
            args: Prisma.GmailTenantConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>
          }
          createMany: {
            args: Prisma.GmailTenantConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GmailTenantConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>[]
          }
          delete: {
            args: Prisma.GmailTenantConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>
          }
          update: {
            args: Prisma.GmailTenantConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>
          }
          deleteMany: {
            args: Prisma.GmailTenantConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GmailTenantConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GmailTenantConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>[]
          }
          upsert: {
            args: Prisma.GmailTenantConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailTenantConnectionPayload>
          }
          aggregate: {
            args: Prisma.GmailTenantConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGmailTenantConnection>
          }
          groupBy: {
            args: Prisma.GmailTenantConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GmailTenantConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GmailTenantConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<GmailTenantConnectionCountAggregateOutputType> | number
          }
        }
      }
      Ms365TenantConnection: {
        payload: Prisma.$Ms365TenantConnectionPayload<ExtArgs>
        fields: Prisma.Ms365TenantConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Ms365TenantConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Ms365TenantConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>
          }
          findFirst: {
            args: Prisma.Ms365TenantConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Ms365TenantConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>
          }
          findMany: {
            args: Prisma.Ms365TenantConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>[]
          }
          create: {
            args: Prisma.Ms365TenantConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>
          }
          createMany: {
            args: Prisma.Ms365TenantConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Ms365TenantConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>[]
          }
          delete: {
            args: Prisma.Ms365TenantConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>
          }
          update: {
            args: Prisma.Ms365TenantConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>
          }
          deleteMany: {
            args: Prisma.Ms365TenantConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Ms365TenantConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Ms365TenantConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>[]
          }
          upsert: {
            args: Prisma.Ms365TenantConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Ms365TenantConnectionPayload>
          }
          aggregate: {
            args: Prisma.Ms365TenantConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMs365TenantConnection>
          }
          groupBy: {
            args: Prisma.Ms365TenantConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ms365TenantConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.Ms365TenantConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<Ms365TenantConnectionCountAggregateOutputType> | number
          }
        }
      }
      LeadExample: {
        payload: Prisma.$LeadExamplePayload<ExtArgs>
        fields: Prisma.LeadExampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadExampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadExampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>
          }
          findFirst: {
            args: Prisma.LeadExampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadExampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>
          }
          findMany: {
            args: Prisma.LeadExampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>[]
          }
          create: {
            args: Prisma.LeadExampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>
          }
          createMany: {
            args: Prisma.LeadExampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadExampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>[]
          }
          delete: {
            args: Prisma.LeadExampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>
          }
          update: {
            args: Prisma.LeadExampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>
          }
          deleteMany: {
            args: Prisma.LeadExampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadExampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadExampleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>[]
          }
          upsert: {
            args: Prisma.LeadExampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadExamplePayload>
          }
          aggregate: {
            args: Prisma.LeadExampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadExample>
          }
          groupBy: {
            args: Prisma.LeadExampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadExampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadExampleCountArgs<ExtArgs>
            result: $Utils.Optional<LeadExampleCountAggregateOutputType> | number
          }
        }
      }
      LeadTrainingExample: {
        payload: Prisma.$LeadTrainingExamplePayload<ExtArgs>
        fields: Prisma.LeadTrainingExampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadTrainingExampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadTrainingExampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>
          }
          findFirst: {
            args: Prisma.LeadTrainingExampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadTrainingExampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>
          }
          findMany: {
            args: Prisma.LeadTrainingExampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>[]
          }
          create: {
            args: Prisma.LeadTrainingExampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>
          }
          createMany: {
            args: Prisma.LeadTrainingExampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadTrainingExampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>[]
          }
          delete: {
            args: Prisma.LeadTrainingExampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>
          }
          update: {
            args: Prisma.LeadTrainingExampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>
          }
          deleteMany: {
            args: Prisma.LeadTrainingExampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadTrainingExampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadTrainingExampleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>[]
          }
          upsert: {
            args: Prisma.LeadTrainingExampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTrainingExamplePayload>
          }
          aggregate: {
            args: Prisma.LeadTrainingExampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadTrainingExample>
          }
          groupBy: {
            args: Prisma.LeadTrainingExampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadTrainingExampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadTrainingExampleCountArgs<ExtArgs>
            result: $Utils.Optional<LeadTrainingExampleCountAggregateOutputType> | number
          }
        }
      }
      TenantSettings: {
        payload: Prisma.$TenantSettingsPayload<ExtArgs>
        fields: Prisma.TenantSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          findFirst: {
            args: Prisma.TenantSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          findMany: {
            args: Prisma.TenantSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          create: {
            args: Prisma.TenantSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          createMany: {
            args: Prisma.TenantSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          delete: {
            args: Prisma.TenantSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          update: {
            args: Prisma.TenantSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          deleteMany: {
            args: Prisma.TenantSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          upsert: {
            args: Prisma.TenantSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          aggregate: {
            args: Prisma.TenantSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantSettings>
          }
          groupBy: {
            args: Prisma.TenantSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<TenantSettingsCountAggregateOutputType> | number
          }
        }
      }
      FollowUpLog: {
        payload: Prisma.$FollowUpLogPayload<ExtArgs>
        fields: Prisma.FollowUpLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowUpLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowUpLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>
          }
          findFirst: {
            args: Prisma.FollowUpLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowUpLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>
          }
          findMany: {
            args: Prisma.FollowUpLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>[]
          }
          create: {
            args: Prisma.FollowUpLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>
          }
          createMany: {
            args: Prisma.FollowUpLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowUpLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>[]
          }
          delete: {
            args: Prisma.FollowUpLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>
          }
          update: {
            args: Prisma.FollowUpLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>
          }
          deleteMany: {
            args: Prisma.FollowUpLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpLogPayload>
          }
          aggregate: {
            args: Prisma.FollowUpLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowUpLog>
          }
          groupBy: {
            args: Prisma.FollowUpLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowUpLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowUpLogCountArgs<ExtArgs>
            result: $Utils.Optional<FollowUpLogCountAggregateOutputType> | number
          }
        }
      }
      LeadSourceCost: {
        payload: Prisma.$LeadSourceCostPayload<ExtArgs>
        fields: Prisma.LeadSourceCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadSourceCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadSourceCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>
          }
          findFirst: {
            args: Prisma.LeadSourceCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadSourceCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>
          }
          findMany: {
            args: Prisma.LeadSourceCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>[]
          }
          create: {
            args: Prisma.LeadSourceCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>
          }
          createMany: {
            args: Prisma.LeadSourceCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadSourceCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>[]
          }
          delete: {
            args: Prisma.LeadSourceCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>
          }
          update: {
            args: Prisma.LeadSourceCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>
          }
          deleteMany: {
            args: Prisma.LeadSourceCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadSourceCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadSourceCostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>[]
          }
          upsert: {
            args: Prisma.LeadSourceCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceCostPayload>
          }
          aggregate: {
            args: Prisma.LeadSourceCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadSourceCost>
          }
          groupBy: {
            args: Prisma.LeadSourceCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadSourceCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadSourceCostCountArgs<ExtArgs>
            result: $Utils.Optional<LeadSourceCostCountAggregateOutputType> | number
          }
        }
      }
      LeadSourceSpend: {
        payload: Prisma.$LeadSourceSpendPayload<ExtArgs>
        fields: Prisma.LeadSourceSpendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadSourceSpendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadSourceSpendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>
          }
          findFirst: {
            args: Prisma.LeadSourceSpendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadSourceSpendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>
          }
          findMany: {
            args: Prisma.LeadSourceSpendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>[]
          }
          create: {
            args: Prisma.LeadSourceSpendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>
          }
          createMany: {
            args: Prisma.LeadSourceSpendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadSourceSpendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>[]
          }
          delete: {
            args: Prisma.LeadSourceSpendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>
          }
          update: {
            args: Prisma.LeadSourceSpendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>
          }
          deleteMany: {
            args: Prisma.LeadSourceSpendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadSourceSpendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadSourceSpendUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>[]
          }
          upsert: {
            args: Prisma.LeadSourceSpendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceSpendPayload>
          }
          aggregate: {
            args: Prisma.LeadSourceSpendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadSourceSpend>
          }
          groupBy: {
            args: Prisma.LeadSourceSpendGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadSourceSpendGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadSourceSpendCountArgs<ExtArgs>
            result: $Utils.Optional<LeadSourceSpendCountAggregateOutputType> | number
          }
        }
      }
      LeadSourceConfig: {
        payload: Prisma.$LeadSourceConfigPayload<ExtArgs>
        fields: Prisma.LeadSourceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadSourceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadSourceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>
          }
          findFirst: {
            args: Prisma.LeadSourceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadSourceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>
          }
          findMany: {
            args: Prisma.LeadSourceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>[]
          }
          create: {
            args: Prisma.LeadSourceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>
          }
          createMany: {
            args: Prisma.LeadSourceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadSourceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>[]
          }
          delete: {
            args: Prisma.LeadSourceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>
          }
          update: {
            args: Prisma.LeadSourceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>
          }
          deleteMany: {
            args: Prisma.LeadSourceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadSourceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadSourceConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>[]
          }
          upsert: {
            args: Prisma.LeadSourceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadSourceConfigPayload>
          }
          aggregate: {
            args: Prisma.LeadSourceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadSourceConfig>
          }
          groupBy: {
            args: Prisma.LeadSourceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadSourceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadSourceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<LeadSourceConfigCountAggregateOutputType> | number
          }
        }
      }
      FollowupExperiment: {
        payload: Prisma.$FollowupExperimentPayload<ExtArgs>
        fields: Prisma.FollowupExperimentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowupExperimentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowupExperimentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>
          }
          findFirst: {
            args: Prisma.FollowupExperimentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowupExperimentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>
          }
          findMany: {
            args: Prisma.FollowupExperimentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>[]
          }
          create: {
            args: Prisma.FollowupExperimentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>
          }
          createMany: {
            args: Prisma.FollowupExperimentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowupExperimentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>[]
          }
          delete: {
            args: Prisma.FollowupExperimentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>
          }
          update: {
            args: Prisma.FollowupExperimentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>
          }
          deleteMany: {
            args: Prisma.FollowupExperimentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowupExperimentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowupExperimentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>[]
          }
          upsert: {
            args: Prisma.FollowupExperimentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupExperimentPayload>
          }
          aggregate: {
            args: Prisma.FollowupExperimentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowupExperiment>
          }
          groupBy: {
            args: Prisma.FollowupExperimentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowupExperimentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowupExperimentCountArgs<ExtArgs>
            result: $Utils.Optional<FollowupExperimentCountAggregateOutputType> | number
          }
        }
      }
      EmailThread: {
        payload: Prisma.$EmailThreadPayload<ExtArgs>
        fields: Prisma.EmailThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          findFirst: {
            args: Prisma.EmailThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          findMany: {
            args: Prisma.EmailThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
          }
          create: {
            args: Prisma.EmailThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          createMany: {
            args: Prisma.EmailThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
          }
          delete: {
            args: Prisma.EmailThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          update: {
            args: Prisma.EmailThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          deleteMany: {
            args: Prisma.EmailThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailThreadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
          }
          upsert: {
            args: Prisma.EmailThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          aggregate: {
            args: Prisma.EmailThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailThread>
          }
          groupBy: {
            args: Prisma.EmailThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailThreadCountArgs<ExtArgs>
            result: $Utils.Optional<EmailThreadCountAggregateOutputType> | number
          }
        }
      }
      EmailMessage: {
        payload: Prisma.$EmailMessagePayload<ExtArgs>
        fields: Prisma.EmailMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          findFirst: {
            args: Prisma.EmailMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          findMany: {
            args: Prisma.EmailMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
          }
          create: {
            args: Prisma.EmailMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          createMany: {
            args: Prisma.EmailMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
          }
          delete: {
            args: Prisma.EmailMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          update: {
            args: Prisma.EmailMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          deleteMany: {
            args: Prisma.EmailMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
          }
          upsert: {
            args: Prisma.EmailMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          aggregate: {
            args: Prisma.EmailMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailMessage>
          }
          groupBy: {
            args: Prisma.EmailMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailMessageCountArgs<ExtArgs>
            result: $Utils.Optional<EmailMessageCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      QuoteLine: {
        payload: Prisma.$QuoteLinePayload<ExtArgs>
        fields: Prisma.QuoteLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>
          }
          findFirst: {
            args: Prisma.QuoteLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>
          }
          findMany: {
            args: Prisma.QuoteLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>[]
          }
          create: {
            args: Prisma.QuoteLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>
          }
          createMany: {
            args: Prisma.QuoteLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>[]
          }
          delete: {
            args: Prisma.QuoteLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>
          }
          update: {
            args: Prisma.QuoteLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>
          }
          deleteMany: {
            args: Prisma.QuoteLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>[]
          }
          upsert: {
            args: Prisma.QuoteLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteLinePayload>
          }
          aggregate: {
            args: Prisma.QuoteLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteLine>
          }
          groupBy: {
            args: Prisma.QuoteLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteLineCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteLineCountAggregateOutputType> | number
          }
        }
      }
      UploadedFile: {
        payload: Prisma.$UploadedFilePayload<ExtArgs>
        fields: Prisma.UploadedFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadedFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadedFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          findFirst: {
            args: Prisma.UploadedFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadedFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          findMany: {
            args: Prisma.UploadedFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          create: {
            args: Prisma.UploadedFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          createMany: {
            args: Prisma.UploadedFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UploadedFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          delete: {
            args: Prisma.UploadedFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          update: {
            args: Prisma.UploadedFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          deleteMany: {
            args: Prisma.UploadedFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadedFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UploadedFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          upsert: {
            args: Prisma.UploadedFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          aggregate: {
            args: Prisma.UploadedFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUploadedFile>
          }
          groupBy: {
            args: Prisma.UploadedFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadedFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadedFileCountArgs<ExtArgs>
            result: $Utils.Optional<UploadedFileCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    lead?: LeadOmit
    opportunity?: OpportunityOmit
    emailIngest?: EmailIngestOmit
    leadFieldDef?: LeadFieldDefOmit
    gmailTenantConnection?: GmailTenantConnectionOmit
    ms365TenantConnection?: Ms365TenantConnectionOmit
    leadExample?: LeadExampleOmit
    leadTrainingExample?: LeadTrainingExampleOmit
    tenantSettings?: TenantSettingsOmit
    followUpLog?: FollowUpLogOmit
    leadSourceCost?: LeadSourceCostOmit
    leadSourceSpend?: LeadSourceSpendOmit
    leadSourceConfig?: LeadSourceConfigOmit
    followupExperiment?: FollowupExperimentOmit
    emailThread?: EmailThreadOmit
    emailMessage?: EmailMessageOmit
    quote?: QuoteOmit
    quoteLine?: QuoteLineOmit
    uploadedFile?: UploadedFileOmit
    passwordResetToken?: PasswordResetTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    leads: number
    opportunities: number
    leadFieldDefs: number
    emailIngests: number
    emailThreads: number
    emailMessages: number
    quotes: number
    UploadedFile: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    leads?: boolean | TenantCountOutputTypeCountLeadsArgs
    opportunities?: boolean | TenantCountOutputTypeCountOpportunitiesArgs
    leadFieldDefs?: boolean | TenantCountOutputTypeCountLeadFieldDefsArgs
    emailIngests?: boolean | TenantCountOutputTypeCountEmailIngestsArgs
    emailThreads?: boolean | TenantCountOutputTypeCountEmailThreadsArgs
    emailMessages?: boolean | TenantCountOutputTypeCountEmailMessagesArgs
    quotes?: boolean | TenantCountOutputTypeCountQuotesArgs
    UploadedFile?: boolean | TenantCountOutputTypeCountUploadedFileArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeadFieldDefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadFieldDefWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmailIngestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailIngestWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmailMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUploadedFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedFileWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    GmailTenantConnection: number
    Ms365TenantConnection: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    GmailTenantConnection?: boolean | UserCountOutputTypeCountGmailTenantConnectionArgs
    Ms365TenantConnection?: boolean | UserCountOutputTypeCountMs365TenantConnectionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGmailTenantConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GmailTenantConnectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMs365TenantConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Ms365TenantConnectionWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    emailIngests: number
    followUpLogs: number
    emailThreads: number
    emailMessages: number
    Quote: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailIngests?: boolean | LeadCountOutputTypeCountEmailIngestsArgs
    followUpLogs?: boolean | LeadCountOutputTypeCountFollowUpLogsArgs
    emailThreads?: boolean | LeadCountOutputTypeCountEmailThreadsArgs
    emailMessages?: boolean | LeadCountOutputTypeCountEmailMessagesArgs
    Quote?: boolean | LeadCountOutputTypeCountQuoteArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountEmailIngestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailIngestWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountFollowUpLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpLogWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountEmailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountEmailMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountQuoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }


  /**
   * Count Type OpportunityCountOutputType
   */

  export type OpportunityCountOutputType = {
    emailThreads: number
    emailMessages: number
  }

  export type OpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailThreads?: boolean | OpportunityCountOutputTypeCountEmailThreadsArgs
    emailMessages?: boolean | OpportunityCountOutputTypeCountEmailMessagesArgs
  }

  // Custom InputTypes
  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityCountOutputType
     */
    select?: OpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountEmailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountEmailMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }


  /**
   * Count Type EmailThreadCountOutputType
   */

  export type EmailThreadCountOutputType = {
    messages: number
  }

  export type EmailThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | EmailThreadCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThreadCountOutputType
     */
    select?: EmailThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }


  /**
   * Count Type QuoteCountOutputType
   */

  export type QuoteCountOutputType = {
    supplierFiles: number
    lines: number
  }

  export type QuoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplierFiles?: boolean | QuoteCountOutputTypeCountSupplierFilesArgs
    lines?: boolean | QuoteCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteCountOutputType
     */
    select?: QuoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountSupplierFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedFileWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteLineWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    seatsOffice: number | null
    seatsWorkshop: number | null
    seatsDisplay: number | null
  }

  export type TenantSumAggregateOutputType = {
    seatsOffice: number | null
    seatsWorkshop: number | null
    seatsDisplay: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    plan: $Enums.Plan | null
    trialEndsAt: Date | null
    discountCodeUsed: string | null
    seatsOffice: number | null
    seatsWorkshop: number | null
    seatsDisplay: number | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    plan: $Enums.Plan | null
    trialEndsAt: Date | null
    discountCodeUsed: string | null
    seatsOffice: number | null
    seatsWorkshop: number | null
    seatsDisplay: number | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    subscriptionStatus: number
    plan: number
    trialEndsAt: number
    discountCodeUsed: number
    seatsOffice: number
    seatsWorkshop: number
    seatsDisplay: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    seatsOffice?: true
    seatsWorkshop?: true
    seatsDisplay?: true
  }

  export type TenantSumAggregateInputType = {
    seatsOffice?: true
    seatsWorkshop?: true
    seatsDisplay?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    plan?: true
    trialEndsAt?: true
    discountCodeUsed?: true
    seatsOffice?: true
    seatsWorkshop?: true
    seatsDisplay?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    plan?: true
    trialEndsAt?: true
    discountCodeUsed?: true
    seatsOffice?: true
    seatsWorkshop?: true
    seatsDisplay?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    plan?: true
    trialEndsAt?: true
    discountCodeUsed?: true
    seatsOffice?: true
    seatsWorkshop?: true
    seatsDisplay?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    plan: $Enums.Plan | null
    trialEndsAt: Date | null
    discountCodeUsed: string | null
    seatsOffice: number
    seatsWorkshop: number
    seatsDisplay: number
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    plan?: boolean
    trialEndsAt?: boolean
    discountCodeUsed?: boolean
    seatsOffice?: boolean
    seatsWorkshop?: boolean
    seatsDisplay?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    opportunities?: boolean | Tenant$opportunitiesArgs<ExtArgs>
    leadFieldDefs?: boolean | Tenant$leadFieldDefsArgs<ExtArgs>
    GmailTenantConnection?: boolean | Tenant$GmailTenantConnectionArgs<ExtArgs>
    Ms365TenantConnection?: boolean | Tenant$Ms365TenantConnectionArgs<ExtArgs>
    emailIngests?: boolean | Tenant$emailIngestsArgs<ExtArgs>
    emailThreads?: boolean | Tenant$emailThreadsArgs<ExtArgs>
    emailMessages?: boolean | Tenant$emailMessagesArgs<ExtArgs>
    quotes?: boolean | Tenant$quotesArgs<ExtArgs>
    UploadedFile?: boolean | Tenant$UploadedFileArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    plan?: boolean
    trialEndsAt?: boolean
    discountCodeUsed?: boolean
    seatsOffice?: boolean
    seatsWorkshop?: boolean
    seatsDisplay?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    plan?: boolean
    trialEndsAt?: boolean
    discountCodeUsed?: boolean
    seatsOffice?: boolean
    seatsWorkshop?: boolean
    seatsDisplay?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    plan?: boolean
    trialEndsAt?: boolean
    discountCodeUsed?: boolean
    seatsOffice?: boolean
    seatsWorkshop?: boolean
    seatsDisplay?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "stripeCustomerId" | "stripeSubscriptionId" | "subscriptionStatus" | "plan" | "trialEndsAt" | "discountCodeUsed" | "seatsOffice" | "seatsWorkshop" | "seatsDisplay", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    opportunities?: boolean | Tenant$opportunitiesArgs<ExtArgs>
    leadFieldDefs?: boolean | Tenant$leadFieldDefsArgs<ExtArgs>
    GmailTenantConnection?: boolean | Tenant$GmailTenantConnectionArgs<ExtArgs>
    Ms365TenantConnection?: boolean | Tenant$Ms365TenantConnectionArgs<ExtArgs>
    emailIngests?: boolean | Tenant$emailIngestsArgs<ExtArgs>
    emailThreads?: boolean | Tenant$emailThreadsArgs<ExtArgs>
    emailMessages?: boolean | Tenant$emailMessagesArgs<ExtArgs>
    quotes?: boolean | Tenant$quotesArgs<ExtArgs>
    UploadedFile?: boolean | Tenant$UploadedFileArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      leadFieldDefs: Prisma.$LeadFieldDefPayload<ExtArgs>[]
      GmailTenantConnection: Prisma.$GmailTenantConnectionPayload<ExtArgs> | null
      Ms365TenantConnection: Prisma.$Ms365TenantConnectionPayload<ExtArgs> | null
      emailIngests: Prisma.$EmailIngestPayload<ExtArgs>[]
      emailThreads: Prisma.$EmailThreadPayload<ExtArgs>[]
      emailMessages: Prisma.$EmailMessagePayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      UploadedFile: Prisma.$UploadedFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      subscriptionStatus: $Enums.SubscriptionStatus | null
      plan: $Enums.Plan | null
      trialEndsAt: Date | null
      discountCodeUsed: string | null
      seatsOffice: number
      seatsWorkshop: number
      seatsDisplay: number
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Tenant$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    opportunities<T extends Tenant$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leadFieldDefs<T extends Tenant$leadFieldDefsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$leadFieldDefsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GmailTenantConnection<T extends Tenant$GmailTenantConnectionArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$GmailTenantConnectionArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Ms365TenantConnection<T extends Tenant$Ms365TenantConnectionArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$Ms365TenantConnectionArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailIngests<T extends Tenant$emailIngestsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$emailIngestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailThreads<T extends Tenant$emailThreadsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$emailThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailMessages<T extends Tenant$emailMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$emailMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Tenant$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UploadedFile<T extends Tenant$UploadedFileArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$UploadedFileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly stripeCustomerId: FieldRef<"Tenant", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Tenant", 'String'>
    readonly subscriptionStatus: FieldRef<"Tenant", 'SubscriptionStatus'>
    readonly plan: FieldRef<"Tenant", 'Plan'>
    readonly trialEndsAt: FieldRef<"Tenant", 'DateTime'>
    readonly discountCodeUsed: FieldRef<"Tenant", 'String'>
    readonly seatsOffice: FieldRef<"Tenant", 'Int'>
    readonly seatsWorkshop: FieldRef<"Tenant", 'Int'>
    readonly seatsDisplay: FieldRef<"Tenant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.leads
   */
  export type Tenant$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Tenant.opportunities
   */
  export type Tenant$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Tenant.leadFieldDefs
   */
  export type Tenant$leadFieldDefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    where?: LeadFieldDefWhereInput
    orderBy?: LeadFieldDefOrderByWithRelationInput | LeadFieldDefOrderByWithRelationInput[]
    cursor?: LeadFieldDefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadFieldDefScalarFieldEnum | LeadFieldDefScalarFieldEnum[]
  }

  /**
   * Tenant.GmailTenantConnection
   */
  export type Tenant$GmailTenantConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    where?: GmailTenantConnectionWhereInput
  }

  /**
   * Tenant.Ms365TenantConnection
   */
  export type Tenant$Ms365TenantConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    where?: Ms365TenantConnectionWhereInput
  }

  /**
   * Tenant.emailIngests
   */
  export type Tenant$emailIngestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    where?: EmailIngestWhereInput
    orderBy?: EmailIngestOrderByWithRelationInput | EmailIngestOrderByWithRelationInput[]
    cursor?: EmailIngestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailIngestScalarFieldEnum | EmailIngestScalarFieldEnum[]
  }

  /**
   * Tenant.emailThreads
   */
  export type Tenant$emailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    cursor?: EmailThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * Tenant.emailMessages
   */
  export type Tenant$emailMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * Tenant.quotes
   */
  export type Tenant$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Tenant.UploadedFile
   */
  export type Tenant$UploadedFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    where?: UploadedFileWhereInput
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    cursor?: UploadedFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    role: string | null
    passwordHash: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    role: string | null
    passwordHash: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    name: number
    role: number
    passwordHash: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    name: string | null
    role: string
    passwordHash: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    GmailTenantConnection?: boolean | User$GmailTenantConnectionArgs<ExtArgs>
    Ms365TenantConnection?: boolean | User$Ms365TenantConnectionArgs<ExtArgs>
    passwordResetToken?: boolean | User$passwordResetTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "email" | "name" | "role" | "passwordHash", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    GmailTenantConnection?: boolean | User$GmailTenantConnectionArgs<ExtArgs>
    Ms365TenantConnection?: boolean | User$Ms365TenantConnectionArgs<ExtArgs>
    passwordResetToken?: boolean | User$passwordResetTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      GmailTenantConnection: Prisma.$GmailTenantConnectionPayload<ExtArgs>[]
      Ms365TenantConnection: Prisma.$Ms365TenantConnectionPayload<ExtArgs>[]
      passwordResetToken: Prisma.$PasswordResetTokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      name: string | null
      role: string
      passwordHash: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    GmailTenantConnection<T extends User$GmailTenantConnectionArgs<ExtArgs> = {}>(args?: Subset<T, User$GmailTenantConnectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Ms365TenantConnection<T extends User$Ms365TenantConnectionArgs<ExtArgs> = {}>(args?: Subset<T, User$Ms365TenantConnectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetToken<T extends User$passwordResetTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokenArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.GmailTenantConnection
   */
  export type User$GmailTenantConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    where?: GmailTenantConnectionWhereInput
    orderBy?: GmailTenantConnectionOrderByWithRelationInput | GmailTenantConnectionOrderByWithRelationInput[]
    cursor?: GmailTenantConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GmailTenantConnectionScalarFieldEnum | GmailTenantConnectionScalarFieldEnum[]
  }

  /**
   * User.Ms365TenantConnection
   */
  export type User$Ms365TenantConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    where?: Ms365TenantConnectionWhereInput
    orderBy?: Ms365TenantConnectionOrderByWithRelationInput | Ms365TenantConnectionOrderByWithRelationInput[]
    cursor?: Ms365TenantConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ms365TenantConnectionScalarFieldEnum | Ms365TenantConnectionScalarFieldEnum[]
  }

  /**
   * User.passwordResetToken
   */
  export type User$passwordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    createdById: string | null
    contactName: string | null
    email: string | null
    status: $Enums.LeadStatus | null
    capturedAt: Date | null
    nextActionAt: Date | null
    nextAction: string | null
    description: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    createdById: string | null
    contactName: string | null
    email: string | null
    status: $Enums.LeadStatus | null
    capturedAt: Date | null
    nextActionAt: Date | null
    nextAction: string | null
    description: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    tenantId: number
    createdById: number
    contactName: number
    email: number
    status: number
    capturedAt: number
    nextActionAt: number
    nextAction: number
    briefJson: number
    custom: number
    description: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    tenantId?: true
    createdById?: true
    contactName?: true
    email?: true
    status?: true
    capturedAt?: true
    nextActionAt?: true
    nextAction?: true
    description?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    tenantId?: true
    createdById?: true
    contactName?: true
    email?: true
    status?: true
    capturedAt?: true
    nextActionAt?: true
    nextAction?: true
    description?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    tenantId?: true
    createdById?: true
    contactName?: true
    email?: true
    status?: true
    capturedAt?: true
    nextActionAt?: true
    nextAction?: true
    briefJson?: true
    custom?: true
    description?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    tenantId: string
    createdById: string
    contactName: string
    email: string | null
    status: $Enums.LeadStatus
    capturedAt: Date
    nextActionAt: Date | null
    nextAction: string | null
    briefJson: JsonValue | null
    custom: JsonValue | null
    description: string | null
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdById?: boolean
    contactName?: boolean
    email?: boolean
    status?: boolean
    capturedAt?: boolean
    nextActionAt?: boolean
    nextAction?: boolean
    briefJson?: boolean
    custom?: boolean
    description?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    opportunity?: boolean | Lead$opportunityArgs<ExtArgs>
    emailIngests?: boolean | Lead$emailIngestsArgs<ExtArgs>
    followUpLogs?: boolean | Lead$followUpLogsArgs<ExtArgs>
    emailThreads?: boolean | Lead$emailThreadsArgs<ExtArgs>
    emailMessages?: boolean | Lead$emailMessagesArgs<ExtArgs>
    Quote?: boolean | Lead$QuoteArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdById?: boolean
    contactName?: boolean
    email?: boolean
    status?: boolean
    capturedAt?: boolean
    nextActionAt?: boolean
    nextAction?: boolean
    briefJson?: boolean
    custom?: boolean
    description?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdById?: boolean
    contactName?: boolean
    email?: boolean
    status?: boolean
    capturedAt?: boolean
    nextActionAt?: boolean
    nextAction?: boolean
    briefJson?: boolean
    custom?: boolean
    description?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    tenantId?: boolean
    createdById?: boolean
    contactName?: boolean
    email?: boolean
    status?: boolean
    capturedAt?: boolean
    nextActionAt?: boolean
    nextAction?: boolean
    briefJson?: boolean
    custom?: boolean
    description?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "createdById" | "contactName" | "email" | "status" | "capturedAt" | "nextActionAt" | "nextAction" | "briefJson" | "custom" | "description", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    opportunity?: boolean | Lead$opportunityArgs<ExtArgs>
    emailIngests?: boolean | Lead$emailIngestsArgs<ExtArgs>
    followUpLogs?: boolean | Lead$followUpLogsArgs<ExtArgs>
    emailThreads?: boolean | Lead$emailThreadsArgs<ExtArgs>
    emailMessages?: boolean | Lead$emailMessagesArgs<ExtArgs>
    Quote?: boolean | Lead$QuoteArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      emailIngests: Prisma.$EmailIngestPayload<ExtArgs>[]
      followUpLogs: Prisma.$FollowUpLogPayload<ExtArgs>[]
      emailThreads: Prisma.$EmailThreadPayload<ExtArgs>[]
      emailMessages: Prisma.$EmailMessagePayload<ExtArgs>[]
      Quote: Prisma.$QuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      createdById: string
      contactName: string
      email: string | null
      status: $Enums.LeadStatus
      capturedAt: Date
      nextActionAt: Date | null
      nextAction: string | null
      briefJson: Prisma.JsonValue | null
      custom: Prisma.JsonValue | null
      description: string | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opportunity<T extends Lead$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, Lead$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailIngests<T extends Lead$emailIngestsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$emailIngestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followUpLogs<T extends Lead$followUpLogsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$followUpLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailThreads<T extends Lead$emailThreadsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$emailThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailMessages<T extends Lead$emailMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$emailMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Quote<T extends Lead$QuoteArgs<ExtArgs> = {}>(args?: Subset<T, Lead$QuoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly tenantId: FieldRef<"Lead", 'String'>
    readonly createdById: FieldRef<"Lead", 'String'>
    readonly contactName: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly capturedAt: FieldRef<"Lead", 'DateTime'>
    readonly nextActionAt: FieldRef<"Lead", 'DateTime'>
    readonly nextAction: FieldRef<"Lead", 'String'>
    readonly briefJson: FieldRef<"Lead", 'Json'>
    readonly custom: FieldRef<"Lead", 'Json'>
    readonly description: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.opportunity
   */
  export type Lead$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * Lead.emailIngests
   */
  export type Lead$emailIngestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    where?: EmailIngestWhereInput
    orderBy?: EmailIngestOrderByWithRelationInput | EmailIngestOrderByWithRelationInput[]
    cursor?: EmailIngestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailIngestScalarFieldEnum | EmailIngestScalarFieldEnum[]
  }

  /**
   * Lead.followUpLogs
   */
  export type Lead$followUpLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    where?: FollowUpLogWhereInput
    orderBy?: FollowUpLogOrderByWithRelationInput | FollowUpLogOrderByWithRelationInput[]
    cursor?: FollowUpLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowUpLogScalarFieldEnum | FollowUpLogScalarFieldEnum[]
  }

  /**
   * Lead.emailThreads
   */
  export type Lead$emailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    cursor?: EmailThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * Lead.emailMessages
   */
  export type Lead$emailMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * Lead.Quote
   */
  export type Lead$QuoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityAvgAggregateOutputType = {
    valueGBP: Decimal | null
  }

  export type OpportunitySumAggregateOutputType = {
    valueGBP: Decimal | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    title: string | null
    valueGBP: Decimal | null
    stage: $Enums.OppStage | null
    wonAt: Date | null
    lostAt: Date | null
    createdAt: Date | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    title: string | null
    valueGBP: Decimal | null
    stage: $Enums.OppStage | null
    wonAt: Date | null
    lostAt: Date | null
    createdAt: Date | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    tenantId: number
    leadId: number
    title: number
    valueGBP: number
    stage: number
    wonAt: number
    lostAt: number
    createdAt: number
    _all: number
  }


  export type OpportunityAvgAggregateInputType = {
    valueGBP?: true
  }

  export type OpportunitySumAggregateInputType = {
    valueGBP?: true
  }

  export type OpportunityMinAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    title?: true
    valueGBP?: true
    stage?: true
    wonAt?: true
    lostAt?: true
    createdAt?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    title?: true
    valueGBP?: true
    stage?: true
    wonAt?: true
    lostAt?: true
    createdAt?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    title?: true
    valueGBP?: true
    stage?: true
    wonAt?: true
    lostAt?: true
    createdAt?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _avg?: OpportunityAvgAggregateInputType
    _sum?: OpportunitySumAggregateInputType
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: string
    tenantId: string
    leadId: string
    title: string
    valueGBP: Decimal | null
    stage: $Enums.OppStage
    wonAt: Date | null
    lostAt: Date | null
    createdAt: Date
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    valueGBP?: boolean
    stage?: boolean
    wonAt?: boolean
    lostAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    emailThreads?: boolean | Opportunity$emailThreadsArgs<ExtArgs>
    emailMessages?: boolean | Opportunity$emailMessagesArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    valueGBP?: boolean
    stage?: boolean
    wonAt?: boolean
    lostAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    valueGBP?: boolean
    stage?: boolean
    wonAt?: boolean
    lostAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    valueGBP?: boolean
    stage?: boolean
    wonAt?: boolean
    lostAt?: boolean
    createdAt?: boolean
  }

  export type OpportunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "leadId" | "title" | "valueGBP" | "stage" | "wonAt" | "lostAt" | "createdAt", ExtArgs["result"]["opportunity"]>
  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    emailThreads?: boolean | Opportunity$emailThreadsArgs<ExtArgs>
    emailMessages?: boolean | Opportunity$emailMessagesArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs>
      emailThreads: Prisma.$EmailThreadPayload<ExtArgs>[]
      emailMessages: Prisma.$EmailMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      leadId: string
      title: string
      valueGBP: Prisma.Decimal | null
      stage: $Enums.OppStage
      wonAt: Date | null
      lostAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities and returns the data updated in the database.
     * @param {OpportunityUpdateManyAndReturnArgs} args - Arguments to update many Opportunities.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpportunityUpdateManyAndReturnArgs>(args: SelectSubset<T, OpportunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emailThreads<T extends Opportunity$emailThreadsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$emailThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailMessages<T extends Opportunity$emailMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$emailMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'String'>
    readonly tenantId: FieldRef<"Opportunity", 'String'>
    readonly leadId: FieldRef<"Opportunity", 'String'>
    readonly title: FieldRef<"Opportunity", 'String'>
    readonly valueGBP: FieldRef<"Opportunity", 'Decimal'>
    readonly stage: FieldRef<"Opportunity", 'OppStage'>
    readonly wonAt: FieldRef<"Opportunity", 'DateTime'>
    readonly lostAt: FieldRef<"Opportunity", 'DateTime'>
    readonly createdAt: FieldRef<"Opportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
  }

  /**
   * Opportunity updateManyAndReturn
   */
  export type OpportunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to delete.
     */
    limit?: number
  }

  /**
   * Opportunity.emailThreads
   */
  export type Opportunity$emailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    cursor?: EmailThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * Opportunity.emailMessages
   */
  export type Opportunity$emailMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model EmailIngest
   */

  export type AggregateEmailIngest = {
    _count: EmailIngestCountAggregateOutputType | null
    _min: EmailIngestMinAggregateOutputType | null
    _max: EmailIngestMaxAggregateOutputType | null
  }

  export type EmailIngestMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    messageId: string | null
    fromEmail: string | null
    subject: string | null
    snippet: string | null
    processedAt: Date | null
    leadId: string | null
    aiPredictedIsLead: boolean | null
    userLabelIsLead: boolean | null
    userLabeledAt: Date | null
    createdAt: Date | null
  }

  export type EmailIngestMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    messageId: string | null
    fromEmail: string | null
    subject: string | null
    snippet: string | null
    processedAt: Date | null
    leadId: string | null
    aiPredictedIsLead: boolean | null
    userLabelIsLead: boolean | null
    userLabeledAt: Date | null
    createdAt: Date | null
  }

  export type EmailIngestCountAggregateOutputType = {
    id: number
    tenantId: number
    provider: number
    messageId: number
    fromEmail: number
    subject: number
    snippet: number
    processedAt: number
    leadId: number
    aiPredictedIsLead: number
    userLabelIsLead: number
    userLabeledAt: number
    createdAt: number
    _all: number
  }


  export type EmailIngestMinAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    fromEmail?: true
    subject?: true
    snippet?: true
    processedAt?: true
    leadId?: true
    aiPredictedIsLead?: true
    userLabelIsLead?: true
    userLabeledAt?: true
    createdAt?: true
  }

  export type EmailIngestMaxAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    fromEmail?: true
    subject?: true
    snippet?: true
    processedAt?: true
    leadId?: true
    aiPredictedIsLead?: true
    userLabelIsLead?: true
    userLabeledAt?: true
    createdAt?: true
  }

  export type EmailIngestCountAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    fromEmail?: true
    subject?: true
    snippet?: true
    processedAt?: true
    leadId?: true
    aiPredictedIsLead?: true
    userLabelIsLead?: true
    userLabeledAt?: true
    createdAt?: true
    _all?: true
  }

  export type EmailIngestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailIngest to aggregate.
     */
    where?: EmailIngestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIngests to fetch.
     */
    orderBy?: EmailIngestOrderByWithRelationInput | EmailIngestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailIngestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIngests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIngests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailIngests
    **/
    _count?: true | EmailIngestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailIngestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailIngestMaxAggregateInputType
  }

  export type GetEmailIngestAggregateType<T extends EmailIngestAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailIngest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailIngest[P]>
      : GetScalarType<T[P], AggregateEmailIngest[P]>
  }




  export type EmailIngestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailIngestWhereInput
    orderBy?: EmailIngestOrderByWithAggregationInput | EmailIngestOrderByWithAggregationInput[]
    by: EmailIngestScalarFieldEnum[] | EmailIngestScalarFieldEnum
    having?: EmailIngestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailIngestCountAggregateInputType | true
    _min?: EmailIngestMinAggregateInputType
    _max?: EmailIngestMaxAggregateInputType
  }

  export type EmailIngestGroupByOutputType = {
    id: string
    tenantId: string
    provider: string
    messageId: string
    fromEmail: string | null
    subject: string | null
    snippet: string | null
    processedAt: Date | null
    leadId: string | null
    aiPredictedIsLead: boolean | null
    userLabelIsLead: boolean | null
    userLabeledAt: Date | null
    createdAt: Date
    _count: EmailIngestCountAggregateOutputType | null
    _min: EmailIngestMinAggregateOutputType | null
    _max: EmailIngestMaxAggregateOutputType | null
  }

  type GetEmailIngestGroupByPayload<T extends EmailIngestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailIngestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailIngestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailIngestGroupByOutputType[P]>
            : GetScalarType<T[P], EmailIngestGroupByOutputType[P]>
        }
      >
    >


  export type EmailIngestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    subject?: boolean
    snippet?: boolean
    processedAt?: boolean
    leadId?: boolean
    aiPredictedIsLead?: boolean
    userLabelIsLead?: boolean
    userLabeledAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailIngest$leadArgs<ExtArgs>
  }, ExtArgs["result"]["emailIngest"]>

  export type EmailIngestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    subject?: boolean
    snippet?: boolean
    processedAt?: boolean
    leadId?: boolean
    aiPredictedIsLead?: boolean
    userLabelIsLead?: boolean
    userLabeledAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailIngest$leadArgs<ExtArgs>
  }, ExtArgs["result"]["emailIngest"]>

  export type EmailIngestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    subject?: boolean
    snippet?: boolean
    processedAt?: boolean
    leadId?: boolean
    aiPredictedIsLead?: boolean
    userLabelIsLead?: boolean
    userLabeledAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailIngest$leadArgs<ExtArgs>
  }, ExtArgs["result"]["emailIngest"]>

  export type EmailIngestSelectScalar = {
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    subject?: boolean
    snippet?: boolean
    processedAt?: boolean
    leadId?: boolean
    aiPredictedIsLead?: boolean
    userLabelIsLead?: boolean
    userLabeledAt?: boolean
    createdAt?: boolean
  }

  export type EmailIngestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "provider" | "messageId" | "fromEmail" | "subject" | "snippet" | "processedAt" | "leadId" | "aiPredictedIsLead" | "userLabelIsLead" | "userLabeledAt" | "createdAt", ExtArgs["result"]["emailIngest"]>
  export type EmailIngestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailIngest$leadArgs<ExtArgs>
  }
  export type EmailIngestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailIngest$leadArgs<ExtArgs>
  }
  export type EmailIngestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailIngest$leadArgs<ExtArgs>
  }

  export type $EmailIngestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailIngest"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      provider: string
      messageId: string
      fromEmail: string | null
      subject: string | null
      snippet: string | null
      processedAt: Date | null
      leadId: string | null
      aiPredictedIsLead: boolean | null
      userLabelIsLead: boolean | null
      userLabeledAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["emailIngest"]>
    composites: {}
  }

  type EmailIngestGetPayload<S extends boolean | null | undefined | EmailIngestDefaultArgs> = $Result.GetResult<Prisma.$EmailIngestPayload, S>

  type EmailIngestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailIngestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailIngestCountAggregateInputType | true
    }

  export interface EmailIngestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailIngest'], meta: { name: 'EmailIngest' } }
    /**
     * Find zero or one EmailIngest that matches the filter.
     * @param {EmailIngestFindUniqueArgs} args - Arguments to find a EmailIngest
     * @example
     * // Get one EmailIngest
     * const emailIngest = await prisma.emailIngest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailIngestFindUniqueArgs>(args: SelectSubset<T, EmailIngestFindUniqueArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailIngest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailIngestFindUniqueOrThrowArgs} args - Arguments to find a EmailIngest
     * @example
     * // Get one EmailIngest
     * const emailIngest = await prisma.emailIngest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailIngestFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailIngestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailIngest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIngestFindFirstArgs} args - Arguments to find a EmailIngest
     * @example
     * // Get one EmailIngest
     * const emailIngest = await prisma.emailIngest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailIngestFindFirstArgs>(args?: SelectSubset<T, EmailIngestFindFirstArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailIngest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIngestFindFirstOrThrowArgs} args - Arguments to find a EmailIngest
     * @example
     * // Get one EmailIngest
     * const emailIngest = await prisma.emailIngest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailIngestFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailIngestFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailIngests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIngestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailIngests
     * const emailIngests = await prisma.emailIngest.findMany()
     * 
     * // Get first 10 EmailIngests
     * const emailIngests = await prisma.emailIngest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailIngestWithIdOnly = await prisma.emailIngest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailIngestFindManyArgs>(args?: SelectSubset<T, EmailIngestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailIngest.
     * @param {EmailIngestCreateArgs} args - Arguments to create a EmailIngest.
     * @example
     * // Create one EmailIngest
     * const EmailIngest = await prisma.emailIngest.create({
     *   data: {
     *     // ... data to create a EmailIngest
     *   }
     * })
     * 
     */
    create<T extends EmailIngestCreateArgs>(args: SelectSubset<T, EmailIngestCreateArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailIngests.
     * @param {EmailIngestCreateManyArgs} args - Arguments to create many EmailIngests.
     * @example
     * // Create many EmailIngests
     * const emailIngest = await prisma.emailIngest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailIngestCreateManyArgs>(args?: SelectSubset<T, EmailIngestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailIngests and returns the data saved in the database.
     * @param {EmailIngestCreateManyAndReturnArgs} args - Arguments to create many EmailIngests.
     * @example
     * // Create many EmailIngests
     * const emailIngest = await prisma.emailIngest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailIngests and only return the `id`
     * const emailIngestWithIdOnly = await prisma.emailIngest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailIngestCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailIngestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailIngest.
     * @param {EmailIngestDeleteArgs} args - Arguments to delete one EmailIngest.
     * @example
     * // Delete one EmailIngest
     * const EmailIngest = await prisma.emailIngest.delete({
     *   where: {
     *     // ... filter to delete one EmailIngest
     *   }
     * })
     * 
     */
    delete<T extends EmailIngestDeleteArgs>(args: SelectSubset<T, EmailIngestDeleteArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailIngest.
     * @param {EmailIngestUpdateArgs} args - Arguments to update one EmailIngest.
     * @example
     * // Update one EmailIngest
     * const emailIngest = await prisma.emailIngest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailIngestUpdateArgs>(args: SelectSubset<T, EmailIngestUpdateArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailIngests.
     * @param {EmailIngestDeleteManyArgs} args - Arguments to filter EmailIngests to delete.
     * @example
     * // Delete a few EmailIngests
     * const { count } = await prisma.emailIngest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailIngestDeleteManyArgs>(args?: SelectSubset<T, EmailIngestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailIngests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIngestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailIngests
     * const emailIngest = await prisma.emailIngest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailIngestUpdateManyArgs>(args: SelectSubset<T, EmailIngestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailIngests and returns the data updated in the database.
     * @param {EmailIngestUpdateManyAndReturnArgs} args - Arguments to update many EmailIngests.
     * @example
     * // Update many EmailIngests
     * const emailIngest = await prisma.emailIngest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailIngests and only return the `id`
     * const emailIngestWithIdOnly = await prisma.emailIngest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailIngestUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailIngestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailIngest.
     * @param {EmailIngestUpsertArgs} args - Arguments to update or create a EmailIngest.
     * @example
     * // Update or create a EmailIngest
     * const emailIngest = await prisma.emailIngest.upsert({
     *   create: {
     *     // ... data to create a EmailIngest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailIngest we want to update
     *   }
     * })
     */
    upsert<T extends EmailIngestUpsertArgs>(args: SelectSubset<T, EmailIngestUpsertArgs<ExtArgs>>): Prisma__EmailIngestClient<$Result.GetResult<Prisma.$EmailIngestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailIngests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIngestCountArgs} args - Arguments to filter EmailIngests to count.
     * @example
     * // Count the number of EmailIngests
     * const count = await prisma.emailIngest.count({
     *   where: {
     *     // ... the filter for the EmailIngests we want to count
     *   }
     * })
    **/
    count<T extends EmailIngestCountArgs>(
      args?: Subset<T, EmailIngestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailIngestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailIngest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIngestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailIngestAggregateArgs>(args: Subset<T, EmailIngestAggregateArgs>): Prisma.PrismaPromise<GetEmailIngestAggregateType<T>>

    /**
     * Group by EmailIngest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIngestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailIngestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailIngestGroupByArgs['orderBy'] }
        : { orderBy?: EmailIngestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailIngestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailIngestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailIngest model
   */
  readonly fields: EmailIngestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailIngest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailIngestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends EmailIngest$leadArgs<ExtArgs> = {}>(args?: Subset<T, EmailIngest$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailIngest model
   */
  interface EmailIngestFieldRefs {
    readonly id: FieldRef<"EmailIngest", 'String'>
    readonly tenantId: FieldRef<"EmailIngest", 'String'>
    readonly provider: FieldRef<"EmailIngest", 'String'>
    readonly messageId: FieldRef<"EmailIngest", 'String'>
    readonly fromEmail: FieldRef<"EmailIngest", 'String'>
    readonly subject: FieldRef<"EmailIngest", 'String'>
    readonly snippet: FieldRef<"EmailIngest", 'String'>
    readonly processedAt: FieldRef<"EmailIngest", 'DateTime'>
    readonly leadId: FieldRef<"EmailIngest", 'String'>
    readonly aiPredictedIsLead: FieldRef<"EmailIngest", 'Boolean'>
    readonly userLabelIsLead: FieldRef<"EmailIngest", 'Boolean'>
    readonly userLabeledAt: FieldRef<"EmailIngest", 'DateTime'>
    readonly createdAt: FieldRef<"EmailIngest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailIngest findUnique
   */
  export type EmailIngestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * Filter, which EmailIngest to fetch.
     */
    where: EmailIngestWhereUniqueInput
  }

  /**
   * EmailIngest findUniqueOrThrow
   */
  export type EmailIngestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * Filter, which EmailIngest to fetch.
     */
    where: EmailIngestWhereUniqueInput
  }

  /**
   * EmailIngest findFirst
   */
  export type EmailIngestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * Filter, which EmailIngest to fetch.
     */
    where?: EmailIngestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIngests to fetch.
     */
    orderBy?: EmailIngestOrderByWithRelationInput | EmailIngestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailIngests.
     */
    cursor?: EmailIngestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIngests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIngests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailIngests.
     */
    distinct?: EmailIngestScalarFieldEnum | EmailIngestScalarFieldEnum[]
  }

  /**
   * EmailIngest findFirstOrThrow
   */
  export type EmailIngestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * Filter, which EmailIngest to fetch.
     */
    where?: EmailIngestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIngests to fetch.
     */
    orderBy?: EmailIngestOrderByWithRelationInput | EmailIngestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailIngests.
     */
    cursor?: EmailIngestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIngests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIngests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailIngests.
     */
    distinct?: EmailIngestScalarFieldEnum | EmailIngestScalarFieldEnum[]
  }

  /**
   * EmailIngest findMany
   */
  export type EmailIngestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * Filter, which EmailIngests to fetch.
     */
    where?: EmailIngestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIngests to fetch.
     */
    orderBy?: EmailIngestOrderByWithRelationInput | EmailIngestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailIngests.
     */
    cursor?: EmailIngestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIngests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIngests.
     */
    skip?: number
    distinct?: EmailIngestScalarFieldEnum | EmailIngestScalarFieldEnum[]
  }

  /**
   * EmailIngest create
   */
  export type EmailIngestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailIngest.
     */
    data: XOR<EmailIngestCreateInput, EmailIngestUncheckedCreateInput>
  }

  /**
   * EmailIngest createMany
   */
  export type EmailIngestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailIngests.
     */
    data: EmailIngestCreateManyInput | EmailIngestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailIngest createManyAndReturn
   */
  export type EmailIngestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * The data used to create many EmailIngests.
     */
    data: EmailIngestCreateManyInput | EmailIngestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailIngest update
   */
  export type EmailIngestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailIngest.
     */
    data: XOR<EmailIngestUpdateInput, EmailIngestUncheckedUpdateInput>
    /**
     * Choose, which EmailIngest to update.
     */
    where: EmailIngestWhereUniqueInput
  }

  /**
   * EmailIngest updateMany
   */
  export type EmailIngestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailIngests.
     */
    data: XOR<EmailIngestUpdateManyMutationInput, EmailIngestUncheckedUpdateManyInput>
    /**
     * Filter which EmailIngests to update
     */
    where?: EmailIngestWhereInput
    /**
     * Limit how many EmailIngests to update.
     */
    limit?: number
  }

  /**
   * EmailIngest updateManyAndReturn
   */
  export type EmailIngestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * The data used to update EmailIngests.
     */
    data: XOR<EmailIngestUpdateManyMutationInput, EmailIngestUncheckedUpdateManyInput>
    /**
     * Filter which EmailIngests to update
     */
    where?: EmailIngestWhereInput
    /**
     * Limit how many EmailIngests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailIngest upsert
   */
  export type EmailIngestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailIngest to update in case it exists.
     */
    where: EmailIngestWhereUniqueInput
    /**
     * In case the EmailIngest found by the `where` argument doesn't exist, create a new EmailIngest with this data.
     */
    create: XOR<EmailIngestCreateInput, EmailIngestUncheckedCreateInput>
    /**
     * In case the EmailIngest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailIngestUpdateInput, EmailIngestUncheckedUpdateInput>
  }

  /**
   * EmailIngest delete
   */
  export type EmailIngestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
    /**
     * Filter which EmailIngest to delete.
     */
    where: EmailIngestWhereUniqueInput
  }

  /**
   * EmailIngest deleteMany
   */
  export type EmailIngestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailIngests to delete
     */
    where?: EmailIngestWhereInput
    /**
     * Limit how many EmailIngests to delete.
     */
    limit?: number
  }

  /**
   * EmailIngest.lead
   */
  export type EmailIngest$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * EmailIngest without action
   */
  export type EmailIngestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIngest
     */
    select?: EmailIngestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIngest
     */
    omit?: EmailIngestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIngestInclude<ExtArgs> | null
  }


  /**
   * Model LeadFieldDef
   */

  export type AggregateLeadFieldDef = {
    _count: LeadFieldDefCountAggregateOutputType | null
    _avg: LeadFieldDefAvgAggregateOutputType | null
    _sum: LeadFieldDefSumAggregateOutputType | null
    _min: LeadFieldDefMinAggregateOutputType | null
    _max: LeadFieldDefMaxAggregateOutputType | null
  }

  export type LeadFieldDefAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type LeadFieldDefSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type LeadFieldDefMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    key: string | null
    label: string | null
    type: string | null
    required: boolean | null
    sortOrder: number | null
  }

  export type LeadFieldDefMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    key: string | null
    label: string | null
    type: string | null
    required: boolean | null
    sortOrder: number | null
  }

  export type LeadFieldDefCountAggregateOutputType = {
    id: number
    tenantId: number
    key: number
    label: number
    type: number
    required: number
    config: number
    sortOrder: number
    _all: number
  }


  export type LeadFieldDefAvgAggregateInputType = {
    sortOrder?: true
  }

  export type LeadFieldDefSumAggregateInputType = {
    sortOrder?: true
  }

  export type LeadFieldDefMinAggregateInputType = {
    id?: true
    tenantId?: true
    key?: true
    label?: true
    type?: true
    required?: true
    sortOrder?: true
  }

  export type LeadFieldDefMaxAggregateInputType = {
    id?: true
    tenantId?: true
    key?: true
    label?: true
    type?: true
    required?: true
    sortOrder?: true
  }

  export type LeadFieldDefCountAggregateInputType = {
    id?: true
    tenantId?: true
    key?: true
    label?: true
    type?: true
    required?: true
    config?: true
    sortOrder?: true
    _all?: true
  }

  export type LeadFieldDefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadFieldDef to aggregate.
     */
    where?: LeadFieldDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadFieldDefs to fetch.
     */
    orderBy?: LeadFieldDefOrderByWithRelationInput | LeadFieldDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadFieldDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadFieldDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadFieldDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadFieldDefs
    **/
    _count?: true | LeadFieldDefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadFieldDefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadFieldDefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadFieldDefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadFieldDefMaxAggregateInputType
  }

  export type GetLeadFieldDefAggregateType<T extends LeadFieldDefAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadFieldDef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadFieldDef[P]>
      : GetScalarType<T[P], AggregateLeadFieldDef[P]>
  }




  export type LeadFieldDefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadFieldDefWhereInput
    orderBy?: LeadFieldDefOrderByWithAggregationInput | LeadFieldDefOrderByWithAggregationInput[]
    by: LeadFieldDefScalarFieldEnum[] | LeadFieldDefScalarFieldEnum
    having?: LeadFieldDefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadFieldDefCountAggregateInputType | true
    _avg?: LeadFieldDefAvgAggregateInputType
    _sum?: LeadFieldDefSumAggregateInputType
    _min?: LeadFieldDefMinAggregateInputType
    _max?: LeadFieldDefMaxAggregateInputType
  }

  export type LeadFieldDefGroupByOutputType = {
    id: string
    tenantId: string
    key: string
    label: string
    type: string
    required: boolean
    config: JsonValue | null
    sortOrder: number
    _count: LeadFieldDefCountAggregateOutputType | null
    _avg: LeadFieldDefAvgAggregateOutputType | null
    _sum: LeadFieldDefSumAggregateOutputType | null
    _min: LeadFieldDefMinAggregateOutputType | null
    _max: LeadFieldDefMaxAggregateOutputType | null
  }

  type GetLeadFieldDefGroupByPayload<T extends LeadFieldDefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadFieldDefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadFieldDefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadFieldDefGroupByOutputType[P]>
            : GetScalarType<T[P], LeadFieldDefGroupByOutputType[P]>
        }
      >
    >


  export type LeadFieldDefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    key?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    config?: boolean
    sortOrder?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadFieldDef"]>

  export type LeadFieldDefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    key?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    config?: boolean
    sortOrder?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadFieldDef"]>

  export type LeadFieldDefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    key?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    config?: boolean
    sortOrder?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadFieldDef"]>

  export type LeadFieldDefSelectScalar = {
    id?: boolean
    tenantId?: boolean
    key?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    config?: boolean
    sortOrder?: boolean
  }

  export type LeadFieldDefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "key" | "label" | "type" | "required" | "config" | "sortOrder", ExtArgs["result"]["leadFieldDef"]>
  export type LeadFieldDefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LeadFieldDefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LeadFieldDefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $LeadFieldDefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadFieldDef"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      key: string
      label: string
      type: string
      required: boolean
      config: Prisma.JsonValue | null
      sortOrder: number
    }, ExtArgs["result"]["leadFieldDef"]>
    composites: {}
  }

  type LeadFieldDefGetPayload<S extends boolean | null | undefined | LeadFieldDefDefaultArgs> = $Result.GetResult<Prisma.$LeadFieldDefPayload, S>

  type LeadFieldDefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFieldDefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadFieldDefCountAggregateInputType | true
    }

  export interface LeadFieldDefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadFieldDef'], meta: { name: 'LeadFieldDef' } }
    /**
     * Find zero or one LeadFieldDef that matches the filter.
     * @param {LeadFieldDefFindUniqueArgs} args - Arguments to find a LeadFieldDef
     * @example
     * // Get one LeadFieldDef
     * const leadFieldDef = await prisma.leadFieldDef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFieldDefFindUniqueArgs>(args: SelectSubset<T, LeadFieldDefFindUniqueArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadFieldDef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFieldDefFindUniqueOrThrowArgs} args - Arguments to find a LeadFieldDef
     * @example
     * // Get one LeadFieldDef
     * const leadFieldDef = await prisma.leadFieldDef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFieldDefFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFieldDefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadFieldDef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFieldDefFindFirstArgs} args - Arguments to find a LeadFieldDef
     * @example
     * // Get one LeadFieldDef
     * const leadFieldDef = await prisma.leadFieldDef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFieldDefFindFirstArgs>(args?: SelectSubset<T, LeadFieldDefFindFirstArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadFieldDef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFieldDefFindFirstOrThrowArgs} args - Arguments to find a LeadFieldDef
     * @example
     * // Get one LeadFieldDef
     * const leadFieldDef = await prisma.leadFieldDef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFieldDefFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFieldDefFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadFieldDefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFieldDefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadFieldDefs
     * const leadFieldDefs = await prisma.leadFieldDef.findMany()
     * 
     * // Get first 10 LeadFieldDefs
     * const leadFieldDefs = await prisma.leadFieldDef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadFieldDefWithIdOnly = await prisma.leadFieldDef.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFieldDefFindManyArgs>(args?: SelectSubset<T, LeadFieldDefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadFieldDef.
     * @param {LeadFieldDefCreateArgs} args - Arguments to create a LeadFieldDef.
     * @example
     * // Create one LeadFieldDef
     * const LeadFieldDef = await prisma.leadFieldDef.create({
     *   data: {
     *     // ... data to create a LeadFieldDef
     *   }
     * })
     * 
     */
    create<T extends LeadFieldDefCreateArgs>(args: SelectSubset<T, LeadFieldDefCreateArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadFieldDefs.
     * @param {LeadFieldDefCreateManyArgs} args - Arguments to create many LeadFieldDefs.
     * @example
     * // Create many LeadFieldDefs
     * const leadFieldDef = await prisma.leadFieldDef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadFieldDefCreateManyArgs>(args?: SelectSubset<T, LeadFieldDefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadFieldDefs and returns the data saved in the database.
     * @param {LeadFieldDefCreateManyAndReturnArgs} args - Arguments to create many LeadFieldDefs.
     * @example
     * // Create many LeadFieldDefs
     * const leadFieldDef = await prisma.leadFieldDef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadFieldDefs and only return the `id`
     * const leadFieldDefWithIdOnly = await prisma.leadFieldDef.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadFieldDefCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadFieldDefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadFieldDef.
     * @param {LeadFieldDefDeleteArgs} args - Arguments to delete one LeadFieldDef.
     * @example
     * // Delete one LeadFieldDef
     * const LeadFieldDef = await prisma.leadFieldDef.delete({
     *   where: {
     *     // ... filter to delete one LeadFieldDef
     *   }
     * })
     * 
     */
    delete<T extends LeadFieldDefDeleteArgs>(args: SelectSubset<T, LeadFieldDefDeleteArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadFieldDef.
     * @param {LeadFieldDefUpdateArgs} args - Arguments to update one LeadFieldDef.
     * @example
     * // Update one LeadFieldDef
     * const leadFieldDef = await prisma.leadFieldDef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadFieldDefUpdateArgs>(args: SelectSubset<T, LeadFieldDefUpdateArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadFieldDefs.
     * @param {LeadFieldDefDeleteManyArgs} args - Arguments to filter LeadFieldDefs to delete.
     * @example
     * // Delete a few LeadFieldDefs
     * const { count } = await prisma.leadFieldDef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadFieldDefDeleteManyArgs>(args?: SelectSubset<T, LeadFieldDefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadFieldDefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFieldDefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadFieldDefs
     * const leadFieldDef = await prisma.leadFieldDef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadFieldDefUpdateManyArgs>(args: SelectSubset<T, LeadFieldDefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadFieldDefs and returns the data updated in the database.
     * @param {LeadFieldDefUpdateManyAndReturnArgs} args - Arguments to update many LeadFieldDefs.
     * @example
     * // Update many LeadFieldDefs
     * const leadFieldDef = await prisma.leadFieldDef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadFieldDefs and only return the `id`
     * const leadFieldDefWithIdOnly = await prisma.leadFieldDef.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadFieldDefUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadFieldDefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadFieldDef.
     * @param {LeadFieldDefUpsertArgs} args - Arguments to update or create a LeadFieldDef.
     * @example
     * // Update or create a LeadFieldDef
     * const leadFieldDef = await prisma.leadFieldDef.upsert({
     *   create: {
     *     // ... data to create a LeadFieldDef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadFieldDef we want to update
     *   }
     * })
     */
    upsert<T extends LeadFieldDefUpsertArgs>(args: SelectSubset<T, LeadFieldDefUpsertArgs<ExtArgs>>): Prisma__LeadFieldDefClient<$Result.GetResult<Prisma.$LeadFieldDefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadFieldDefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFieldDefCountArgs} args - Arguments to filter LeadFieldDefs to count.
     * @example
     * // Count the number of LeadFieldDefs
     * const count = await prisma.leadFieldDef.count({
     *   where: {
     *     // ... the filter for the LeadFieldDefs we want to count
     *   }
     * })
    **/
    count<T extends LeadFieldDefCountArgs>(
      args?: Subset<T, LeadFieldDefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadFieldDefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadFieldDef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFieldDefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadFieldDefAggregateArgs>(args: Subset<T, LeadFieldDefAggregateArgs>): Prisma.PrismaPromise<GetLeadFieldDefAggregateType<T>>

    /**
     * Group by LeadFieldDef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFieldDefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadFieldDefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadFieldDefGroupByArgs['orderBy'] }
        : { orderBy?: LeadFieldDefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadFieldDefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadFieldDefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadFieldDef model
   */
  readonly fields: LeadFieldDefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadFieldDef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadFieldDefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadFieldDef model
   */
  interface LeadFieldDefFieldRefs {
    readonly id: FieldRef<"LeadFieldDef", 'String'>
    readonly tenantId: FieldRef<"LeadFieldDef", 'String'>
    readonly key: FieldRef<"LeadFieldDef", 'String'>
    readonly label: FieldRef<"LeadFieldDef", 'String'>
    readonly type: FieldRef<"LeadFieldDef", 'String'>
    readonly required: FieldRef<"LeadFieldDef", 'Boolean'>
    readonly config: FieldRef<"LeadFieldDef", 'Json'>
    readonly sortOrder: FieldRef<"LeadFieldDef", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LeadFieldDef findUnique
   */
  export type LeadFieldDefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * Filter, which LeadFieldDef to fetch.
     */
    where: LeadFieldDefWhereUniqueInput
  }

  /**
   * LeadFieldDef findUniqueOrThrow
   */
  export type LeadFieldDefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * Filter, which LeadFieldDef to fetch.
     */
    where: LeadFieldDefWhereUniqueInput
  }

  /**
   * LeadFieldDef findFirst
   */
  export type LeadFieldDefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * Filter, which LeadFieldDef to fetch.
     */
    where?: LeadFieldDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadFieldDefs to fetch.
     */
    orderBy?: LeadFieldDefOrderByWithRelationInput | LeadFieldDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadFieldDefs.
     */
    cursor?: LeadFieldDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadFieldDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadFieldDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadFieldDefs.
     */
    distinct?: LeadFieldDefScalarFieldEnum | LeadFieldDefScalarFieldEnum[]
  }

  /**
   * LeadFieldDef findFirstOrThrow
   */
  export type LeadFieldDefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * Filter, which LeadFieldDef to fetch.
     */
    where?: LeadFieldDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadFieldDefs to fetch.
     */
    orderBy?: LeadFieldDefOrderByWithRelationInput | LeadFieldDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadFieldDefs.
     */
    cursor?: LeadFieldDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadFieldDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadFieldDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadFieldDefs.
     */
    distinct?: LeadFieldDefScalarFieldEnum | LeadFieldDefScalarFieldEnum[]
  }

  /**
   * LeadFieldDef findMany
   */
  export type LeadFieldDefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * Filter, which LeadFieldDefs to fetch.
     */
    where?: LeadFieldDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadFieldDefs to fetch.
     */
    orderBy?: LeadFieldDefOrderByWithRelationInput | LeadFieldDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadFieldDefs.
     */
    cursor?: LeadFieldDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadFieldDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadFieldDefs.
     */
    skip?: number
    distinct?: LeadFieldDefScalarFieldEnum | LeadFieldDefScalarFieldEnum[]
  }

  /**
   * LeadFieldDef create
   */
  export type LeadFieldDefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadFieldDef.
     */
    data: XOR<LeadFieldDefCreateInput, LeadFieldDefUncheckedCreateInput>
  }

  /**
   * LeadFieldDef createMany
   */
  export type LeadFieldDefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadFieldDefs.
     */
    data: LeadFieldDefCreateManyInput | LeadFieldDefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadFieldDef createManyAndReturn
   */
  export type LeadFieldDefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * The data used to create many LeadFieldDefs.
     */
    data: LeadFieldDefCreateManyInput | LeadFieldDefCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadFieldDef update
   */
  export type LeadFieldDefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadFieldDef.
     */
    data: XOR<LeadFieldDefUpdateInput, LeadFieldDefUncheckedUpdateInput>
    /**
     * Choose, which LeadFieldDef to update.
     */
    where: LeadFieldDefWhereUniqueInput
  }

  /**
   * LeadFieldDef updateMany
   */
  export type LeadFieldDefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadFieldDefs.
     */
    data: XOR<LeadFieldDefUpdateManyMutationInput, LeadFieldDefUncheckedUpdateManyInput>
    /**
     * Filter which LeadFieldDefs to update
     */
    where?: LeadFieldDefWhereInput
    /**
     * Limit how many LeadFieldDefs to update.
     */
    limit?: number
  }

  /**
   * LeadFieldDef updateManyAndReturn
   */
  export type LeadFieldDefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * The data used to update LeadFieldDefs.
     */
    data: XOR<LeadFieldDefUpdateManyMutationInput, LeadFieldDefUncheckedUpdateManyInput>
    /**
     * Filter which LeadFieldDefs to update
     */
    where?: LeadFieldDefWhereInput
    /**
     * Limit how many LeadFieldDefs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadFieldDef upsert
   */
  export type LeadFieldDefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadFieldDef to update in case it exists.
     */
    where: LeadFieldDefWhereUniqueInput
    /**
     * In case the LeadFieldDef found by the `where` argument doesn't exist, create a new LeadFieldDef with this data.
     */
    create: XOR<LeadFieldDefCreateInput, LeadFieldDefUncheckedCreateInput>
    /**
     * In case the LeadFieldDef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadFieldDefUpdateInput, LeadFieldDefUncheckedUpdateInput>
  }

  /**
   * LeadFieldDef delete
   */
  export type LeadFieldDefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
    /**
     * Filter which LeadFieldDef to delete.
     */
    where: LeadFieldDefWhereUniqueInput
  }

  /**
   * LeadFieldDef deleteMany
   */
  export type LeadFieldDefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadFieldDefs to delete
     */
    where?: LeadFieldDefWhereInput
    /**
     * Limit how many LeadFieldDefs to delete.
     */
    limit?: number
  }

  /**
   * LeadFieldDef without action
   */
  export type LeadFieldDefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadFieldDef
     */
    select?: LeadFieldDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadFieldDef
     */
    omit?: LeadFieldDefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadFieldDefInclude<ExtArgs> | null
  }


  /**
   * Model GmailTenantConnection
   */

  export type AggregateGmailTenantConnection = {
    _count: GmailTenantConnectionCountAggregateOutputType | null
    _min: GmailTenantConnectionMinAggregateOutputType | null
    _max: GmailTenantConnectionMaxAggregateOutputType | null
  }

  export type GmailTenantConnectionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    connectedById: string | null
    gmailAddress: string | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmailTenantConnectionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    connectedById: string | null
    gmailAddress: string | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmailTenantConnectionCountAggregateOutputType = {
    id: number
    tenantId: number
    connectedById: number
    gmailAddress: number
    refreshToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GmailTenantConnectionMinAggregateInputType = {
    id?: true
    tenantId?: true
    connectedById?: true
    gmailAddress?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmailTenantConnectionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    connectedById?: true
    gmailAddress?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmailTenantConnectionCountAggregateInputType = {
    id?: true
    tenantId?: true
    connectedById?: true
    gmailAddress?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GmailTenantConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmailTenantConnection to aggregate.
     */
    where?: GmailTenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailTenantConnections to fetch.
     */
    orderBy?: GmailTenantConnectionOrderByWithRelationInput | GmailTenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GmailTenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailTenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailTenantConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GmailTenantConnections
    **/
    _count?: true | GmailTenantConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GmailTenantConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GmailTenantConnectionMaxAggregateInputType
  }

  export type GetGmailTenantConnectionAggregateType<T extends GmailTenantConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateGmailTenantConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGmailTenantConnection[P]>
      : GetScalarType<T[P], AggregateGmailTenantConnection[P]>
  }




  export type GmailTenantConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GmailTenantConnectionWhereInput
    orderBy?: GmailTenantConnectionOrderByWithAggregationInput | GmailTenantConnectionOrderByWithAggregationInput[]
    by: GmailTenantConnectionScalarFieldEnum[] | GmailTenantConnectionScalarFieldEnum
    having?: GmailTenantConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GmailTenantConnectionCountAggregateInputType | true
    _min?: GmailTenantConnectionMinAggregateInputType
    _max?: GmailTenantConnectionMaxAggregateInputType
  }

  export type GmailTenantConnectionGroupByOutputType = {
    id: string
    tenantId: string
    connectedById: string | null
    gmailAddress: string | null
    refreshToken: string
    createdAt: Date
    updatedAt: Date
    _count: GmailTenantConnectionCountAggregateOutputType | null
    _min: GmailTenantConnectionMinAggregateOutputType | null
    _max: GmailTenantConnectionMaxAggregateOutputType | null
  }

  type GetGmailTenantConnectionGroupByPayload<T extends GmailTenantConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GmailTenantConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GmailTenantConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GmailTenantConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], GmailTenantConnectionGroupByOutputType[P]>
        }
      >
    >


  export type GmailTenantConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    gmailAddress?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | GmailTenantConnection$connectedByArgs<ExtArgs>
  }, ExtArgs["result"]["gmailTenantConnection"]>

  export type GmailTenantConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    gmailAddress?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | GmailTenantConnection$connectedByArgs<ExtArgs>
  }, ExtArgs["result"]["gmailTenantConnection"]>

  export type GmailTenantConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    gmailAddress?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | GmailTenantConnection$connectedByArgs<ExtArgs>
  }, ExtArgs["result"]["gmailTenantConnection"]>

  export type GmailTenantConnectionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    gmailAddress?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GmailTenantConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "connectedById" | "gmailAddress" | "refreshToken" | "createdAt" | "updatedAt", ExtArgs["result"]["gmailTenantConnection"]>
  export type GmailTenantConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | GmailTenantConnection$connectedByArgs<ExtArgs>
  }
  export type GmailTenantConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | GmailTenantConnection$connectedByArgs<ExtArgs>
  }
  export type GmailTenantConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | GmailTenantConnection$connectedByArgs<ExtArgs>
  }

  export type $GmailTenantConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GmailTenantConnection"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      connectedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      connectedById: string | null
      gmailAddress: string | null
      refreshToken: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gmailTenantConnection"]>
    composites: {}
  }

  type GmailTenantConnectionGetPayload<S extends boolean | null | undefined | GmailTenantConnectionDefaultArgs> = $Result.GetResult<Prisma.$GmailTenantConnectionPayload, S>

  type GmailTenantConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GmailTenantConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GmailTenantConnectionCountAggregateInputType | true
    }

  export interface GmailTenantConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GmailTenantConnection'], meta: { name: 'GmailTenantConnection' } }
    /**
     * Find zero or one GmailTenantConnection that matches the filter.
     * @param {GmailTenantConnectionFindUniqueArgs} args - Arguments to find a GmailTenantConnection
     * @example
     * // Get one GmailTenantConnection
     * const gmailTenantConnection = await prisma.gmailTenantConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GmailTenantConnectionFindUniqueArgs>(args: SelectSubset<T, GmailTenantConnectionFindUniqueArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GmailTenantConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GmailTenantConnectionFindUniqueOrThrowArgs} args - Arguments to find a GmailTenantConnection
     * @example
     * // Get one GmailTenantConnection
     * const gmailTenantConnection = await prisma.gmailTenantConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GmailTenantConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, GmailTenantConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GmailTenantConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailTenantConnectionFindFirstArgs} args - Arguments to find a GmailTenantConnection
     * @example
     * // Get one GmailTenantConnection
     * const gmailTenantConnection = await prisma.gmailTenantConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GmailTenantConnectionFindFirstArgs>(args?: SelectSubset<T, GmailTenantConnectionFindFirstArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GmailTenantConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailTenantConnectionFindFirstOrThrowArgs} args - Arguments to find a GmailTenantConnection
     * @example
     * // Get one GmailTenantConnection
     * const gmailTenantConnection = await prisma.gmailTenantConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GmailTenantConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, GmailTenantConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GmailTenantConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailTenantConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GmailTenantConnections
     * const gmailTenantConnections = await prisma.gmailTenantConnection.findMany()
     * 
     * // Get first 10 GmailTenantConnections
     * const gmailTenantConnections = await prisma.gmailTenantConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gmailTenantConnectionWithIdOnly = await prisma.gmailTenantConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GmailTenantConnectionFindManyArgs>(args?: SelectSubset<T, GmailTenantConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GmailTenantConnection.
     * @param {GmailTenantConnectionCreateArgs} args - Arguments to create a GmailTenantConnection.
     * @example
     * // Create one GmailTenantConnection
     * const GmailTenantConnection = await prisma.gmailTenantConnection.create({
     *   data: {
     *     // ... data to create a GmailTenantConnection
     *   }
     * })
     * 
     */
    create<T extends GmailTenantConnectionCreateArgs>(args: SelectSubset<T, GmailTenantConnectionCreateArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GmailTenantConnections.
     * @param {GmailTenantConnectionCreateManyArgs} args - Arguments to create many GmailTenantConnections.
     * @example
     * // Create many GmailTenantConnections
     * const gmailTenantConnection = await prisma.gmailTenantConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GmailTenantConnectionCreateManyArgs>(args?: SelectSubset<T, GmailTenantConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GmailTenantConnections and returns the data saved in the database.
     * @param {GmailTenantConnectionCreateManyAndReturnArgs} args - Arguments to create many GmailTenantConnections.
     * @example
     * // Create many GmailTenantConnections
     * const gmailTenantConnection = await prisma.gmailTenantConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GmailTenantConnections and only return the `id`
     * const gmailTenantConnectionWithIdOnly = await prisma.gmailTenantConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GmailTenantConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, GmailTenantConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GmailTenantConnection.
     * @param {GmailTenantConnectionDeleteArgs} args - Arguments to delete one GmailTenantConnection.
     * @example
     * // Delete one GmailTenantConnection
     * const GmailTenantConnection = await prisma.gmailTenantConnection.delete({
     *   where: {
     *     // ... filter to delete one GmailTenantConnection
     *   }
     * })
     * 
     */
    delete<T extends GmailTenantConnectionDeleteArgs>(args: SelectSubset<T, GmailTenantConnectionDeleteArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GmailTenantConnection.
     * @param {GmailTenantConnectionUpdateArgs} args - Arguments to update one GmailTenantConnection.
     * @example
     * // Update one GmailTenantConnection
     * const gmailTenantConnection = await prisma.gmailTenantConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GmailTenantConnectionUpdateArgs>(args: SelectSubset<T, GmailTenantConnectionUpdateArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GmailTenantConnections.
     * @param {GmailTenantConnectionDeleteManyArgs} args - Arguments to filter GmailTenantConnections to delete.
     * @example
     * // Delete a few GmailTenantConnections
     * const { count } = await prisma.gmailTenantConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GmailTenantConnectionDeleteManyArgs>(args?: SelectSubset<T, GmailTenantConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GmailTenantConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailTenantConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GmailTenantConnections
     * const gmailTenantConnection = await prisma.gmailTenantConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GmailTenantConnectionUpdateManyArgs>(args: SelectSubset<T, GmailTenantConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GmailTenantConnections and returns the data updated in the database.
     * @param {GmailTenantConnectionUpdateManyAndReturnArgs} args - Arguments to update many GmailTenantConnections.
     * @example
     * // Update many GmailTenantConnections
     * const gmailTenantConnection = await prisma.gmailTenantConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GmailTenantConnections and only return the `id`
     * const gmailTenantConnectionWithIdOnly = await prisma.gmailTenantConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GmailTenantConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, GmailTenantConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GmailTenantConnection.
     * @param {GmailTenantConnectionUpsertArgs} args - Arguments to update or create a GmailTenantConnection.
     * @example
     * // Update or create a GmailTenantConnection
     * const gmailTenantConnection = await prisma.gmailTenantConnection.upsert({
     *   create: {
     *     // ... data to create a GmailTenantConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GmailTenantConnection we want to update
     *   }
     * })
     */
    upsert<T extends GmailTenantConnectionUpsertArgs>(args: SelectSubset<T, GmailTenantConnectionUpsertArgs<ExtArgs>>): Prisma__GmailTenantConnectionClient<$Result.GetResult<Prisma.$GmailTenantConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GmailTenantConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailTenantConnectionCountArgs} args - Arguments to filter GmailTenantConnections to count.
     * @example
     * // Count the number of GmailTenantConnections
     * const count = await prisma.gmailTenantConnection.count({
     *   where: {
     *     // ... the filter for the GmailTenantConnections we want to count
     *   }
     * })
    **/
    count<T extends GmailTenantConnectionCountArgs>(
      args?: Subset<T, GmailTenantConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GmailTenantConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GmailTenantConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailTenantConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GmailTenantConnectionAggregateArgs>(args: Subset<T, GmailTenantConnectionAggregateArgs>): Prisma.PrismaPromise<GetGmailTenantConnectionAggregateType<T>>

    /**
     * Group by GmailTenantConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailTenantConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GmailTenantConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GmailTenantConnectionGroupByArgs['orderBy'] }
        : { orderBy?: GmailTenantConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GmailTenantConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGmailTenantConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GmailTenantConnection model
   */
  readonly fields: GmailTenantConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GmailTenantConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GmailTenantConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    connectedBy<T extends GmailTenantConnection$connectedByArgs<ExtArgs> = {}>(args?: Subset<T, GmailTenantConnection$connectedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GmailTenantConnection model
   */
  interface GmailTenantConnectionFieldRefs {
    readonly id: FieldRef<"GmailTenantConnection", 'String'>
    readonly tenantId: FieldRef<"GmailTenantConnection", 'String'>
    readonly connectedById: FieldRef<"GmailTenantConnection", 'String'>
    readonly gmailAddress: FieldRef<"GmailTenantConnection", 'String'>
    readonly refreshToken: FieldRef<"GmailTenantConnection", 'String'>
    readonly createdAt: FieldRef<"GmailTenantConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"GmailTenantConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GmailTenantConnection findUnique
   */
  export type GmailTenantConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailTenantConnection to fetch.
     */
    where: GmailTenantConnectionWhereUniqueInput
  }

  /**
   * GmailTenantConnection findUniqueOrThrow
   */
  export type GmailTenantConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailTenantConnection to fetch.
     */
    where: GmailTenantConnectionWhereUniqueInput
  }

  /**
   * GmailTenantConnection findFirst
   */
  export type GmailTenantConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailTenantConnection to fetch.
     */
    where?: GmailTenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailTenantConnections to fetch.
     */
    orderBy?: GmailTenantConnectionOrderByWithRelationInput | GmailTenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmailTenantConnections.
     */
    cursor?: GmailTenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailTenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailTenantConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmailTenantConnections.
     */
    distinct?: GmailTenantConnectionScalarFieldEnum | GmailTenantConnectionScalarFieldEnum[]
  }

  /**
   * GmailTenantConnection findFirstOrThrow
   */
  export type GmailTenantConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailTenantConnection to fetch.
     */
    where?: GmailTenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailTenantConnections to fetch.
     */
    orderBy?: GmailTenantConnectionOrderByWithRelationInput | GmailTenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmailTenantConnections.
     */
    cursor?: GmailTenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailTenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailTenantConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmailTenantConnections.
     */
    distinct?: GmailTenantConnectionScalarFieldEnum | GmailTenantConnectionScalarFieldEnum[]
  }

  /**
   * GmailTenantConnection findMany
   */
  export type GmailTenantConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailTenantConnections to fetch.
     */
    where?: GmailTenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailTenantConnections to fetch.
     */
    orderBy?: GmailTenantConnectionOrderByWithRelationInput | GmailTenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GmailTenantConnections.
     */
    cursor?: GmailTenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailTenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailTenantConnections.
     */
    skip?: number
    distinct?: GmailTenantConnectionScalarFieldEnum | GmailTenantConnectionScalarFieldEnum[]
  }

  /**
   * GmailTenantConnection create
   */
  export type GmailTenantConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a GmailTenantConnection.
     */
    data: XOR<GmailTenantConnectionCreateInput, GmailTenantConnectionUncheckedCreateInput>
  }

  /**
   * GmailTenantConnection createMany
   */
  export type GmailTenantConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GmailTenantConnections.
     */
    data: GmailTenantConnectionCreateManyInput | GmailTenantConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GmailTenantConnection createManyAndReturn
   */
  export type GmailTenantConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many GmailTenantConnections.
     */
    data: GmailTenantConnectionCreateManyInput | GmailTenantConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GmailTenantConnection update
   */
  export type GmailTenantConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a GmailTenantConnection.
     */
    data: XOR<GmailTenantConnectionUpdateInput, GmailTenantConnectionUncheckedUpdateInput>
    /**
     * Choose, which GmailTenantConnection to update.
     */
    where: GmailTenantConnectionWhereUniqueInput
  }

  /**
   * GmailTenantConnection updateMany
   */
  export type GmailTenantConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GmailTenantConnections.
     */
    data: XOR<GmailTenantConnectionUpdateManyMutationInput, GmailTenantConnectionUncheckedUpdateManyInput>
    /**
     * Filter which GmailTenantConnections to update
     */
    where?: GmailTenantConnectionWhereInput
    /**
     * Limit how many GmailTenantConnections to update.
     */
    limit?: number
  }

  /**
   * GmailTenantConnection updateManyAndReturn
   */
  export type GmailTenantConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * The data used to update GmailTenantConnections.
     */
    data: XOR<GmailTenantConnectionUpdateManyMutationInput, GmailTenantConnectionUncheckedUpdateManyInput>
    /**
     * Filter which GmailTenantConnections to update
     */
    where?: GmailTenantConnectionWhereInput
    /**
     * Limit how many GmailTenantConnections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GmailTenantConnection upsert
   */
  export type GmailTenantConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the GmailTenantConnection to update in case it exists.
     */
    where: GmailTenantConnectionWhereUniqueInput
    /**
     * In case the GmailTenantConnection found by the `where` argument doesn't exist, create a new GmailTenantConnection with this data.
     */
    create: XOR<GmailTenantConnectionCreateInput, GmailTenantConnectionUncheckedCreateInput>
    /**
     * In case the GmailTenantConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GmailTenantConnectionUpdateInput, GmailTenantConnectionUncheckedUpdateInput>
  }

  /**
   * GmailTenantConnection delete
   */
  export type GmailTenantConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
    /**
     * Filter which GmailTenantConnection to delete.
     */
    where: GmailTenantConnectionWhereUniqueInput
  }

  /**
   * GmailTenantConnection deleteMany
   */
  export type GmailTenantConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmailTenantConnections to delete
     */
    where?: GmailTenantConnectionWhereInput
    /**
     * Limit how many GmailTenantConnections to delete.
     */
    limit?: number
  }

  /**
   * GmailTenantConnection.connectedBy
   */
  export type GmailTenantConnection$connectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GmailTenantConnection without action
   */
  export type GmailTenantConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailTenantConnection
     */
    select?: GmailTenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmailTenantConnection
     */
    omit?: GmailTenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailTenantConnectionInclude<ExtArgs> | null
  }


  /**
   * Model Ms365TenantConnection
   */

  export type AggregateMs365TenantConnection = {
    _count: Ms365TenantConnectionCountAggregateOutputType | null
    _min: Ms365TenantConnectionMinAggregateOutputType | null
    _max: Ms365TenantConnectionMaxAggregateOutputType | null
  }

  export type Ms365TenantConnectionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    connectedById: string | null
    ms365Address: string | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Ms365TenantConnectionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    connectedById: string | null
    ms365Address: string | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Ms365TenantConnectionCountAggregateOutputType = {
    id: number
    tenantId: number
    connectedById: number
    ms365Address: number
    refreshToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Ms365TenantConnectionMinAggregateInputType = {
    id?: true
    tenantId?: true
    connectedById?: true
    ms365Address?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Ms365TenantConnectionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    connectedById?: true
    ms365Address?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Ms365TenantConnectionCountAggregateInputType = {
    id?: true
    tenantId?: true
    connectedById?: true
    ms365Address?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Ms365TenantConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ms365TenantConnection to aggregate.
     */
    where?: Ms365TenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ms365TenantConnections to fetch.
     */
    orderBy?: Ms365TenantConnectionOrderByWithRelationInput | Ms365TenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Ms365TenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ms365TenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ms365TenantConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ms365TenantConnections
    **/
    _count?: true | Ms365TenantConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ms365TenantConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ms365TenantConnectionMaxAggregateInputType
  }

  export type GetMs365TenantConnectionAggregateType<T extends Ms365TenantConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateMs365TenantConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMs365TenantConnection[P]>
      : GetScalarType<T[P], AggregateMs365TenantConnection[P]>
  }




  export type Ms365TenantConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Ms365TenantConnectionWhereInput
    orderBy?: Ms365TenantConnectionOrderByWithAggregationInput | Ms365TenantConnectionOrderByWithAggregationInput[]
    by: Ms365TenantConnectionScalarFieldEnum[] | Ms365TenantConnectionScalarFieldEnum
    having?: Ms365TenantConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ms365TenantConnectionCountAggregateInputType | true
    _min?: Ms365TenantConnectionMinAggregateInputType
    _max?: Ms365TenantConnectionMaxAggregateInputType
  }

  export type Ms365TenantConnectionGroupByOutputType = {
    id: string
    tenantId: string
    connectedById: string | null
    ms365Address: string | null
    refreshToken: string
    createdAt: Date
    updatedAt: Date
    _count: Ms365TenantConnectionCountAggregateOutputType | null
    _min: Ms365TenantConnectionMinAggregateOutputType | null
    _max: Ms365TenantConnectionMaxAggregateOutputType | null
  }

  type GetMs365TenantConnectionGroupByPayload<T extends Ms365TenantConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ms365TenantConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ms365TenantConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ms365TenantConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], Ms365TenantConnectionGroupByOutputType[P]>
        }
      >
    >


  export type Ms365TenantConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    ms365Address?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | Ms365TenantConnection$connectedByArgs<ExtArgs>
  }, ExtArgs["result"]["ms365TenantConnection"]>

  export type Ms365TenantConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    ms365Address?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | Ms365TenantConnection$connectedByArgs<ExtArgs>
  }, ExtArgs["result"]["ms365TenantConnection"]>

  export type Ms365TenantConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    ms365Address?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | Ms365TenantConnection$connectedByArgs<ExtArgs>
  }, ExtArgs["result"]["ms365TenantConnection"]>

  export type Ms365TenantConnectionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    connectedById?: boolean
    ms365Address?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Ms365TenantConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "connectedById" | "ms365Address" | "refreshToken" | "createdAt" | "updatedAt", ExtArgs["result"]["ms365TenantConnection"]>
  export type Ms365TenantConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | Ms365TenantConnection$connectedByArgs<ExtArgs>
  }
  export type Ms365TenantConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | Ms365TenantConnection$connectedByArgs<ExtArgs>
  }
  export type Ms365TenantConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    connectedBy?: boolean | Ms365TenantConnection$connectedByArgs<ExtArgs>
  }

  export type $Ms365TenantConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ms365TenantConnection"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      connectedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      connectedById: string | null
      ms365Address: string | null
      refreshToken: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ms365TenantConnection"]>
    composites: {}
  }

  type Ms365TenantConnectionGetPayload<S extends boolean | null | undefined | Ms365TenantConnectionDefaultArgs> = $Result.GetResult<Prisma.$Ms365TenantConnectionPayload, S>

  type Ms365TenantConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Ms365TenantConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ms365TenantConnectionCountAggregateInputType | true
    }

  export interface Ms365TenantConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ms365TenantConnection'], meta: { name: 'Ms365TenantConnection' } }
    /**
     * Find zero or one Ms365TenantConnection that matches the filter.
     * @param {Ms365TenantConnectionFindUniqueArgs} args - Arguments to find a Ms365TenantConnection
     * @example
     * // Get one Ms365TenantConnection
     * const ms365TenantConnection = await prisma.ms365TenantConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Ms365TenantConnectionFindUniqueArgs>(args: SelectSubset<T, Ms365TenantConnectionFindUniqueArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ms365TenantConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Ms365TenantConnectionFindUniqueOrThrowArgs} args - Arguments to find a Ms365TenantConnection
     * @example
     * // Get one Ms365TenantConnection
     * const ms365TenantConnection = await prisma.ms365TenantConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Ms365TenantConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, Ms365TenantConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ms365TenantConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ms365TenantConnectionFindFirstArgs} args - Arguments to find a Ms365TenantConnection
     * @example
     * // Get one Ms365TenantConnection
     * const ms365TenantConnection = await prisma.ms365TenantConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Ms365TenantConnectionFindFirstArgs>(args?: SelectSubset<T, Ms365TenantConnectionFindFirstArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ms365TenantConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ms365TenantConnectionFindFirstOrThrowArgs} args - Arguments to find a Ms365TenantConnection
     * @example
     * // Get one Ms365TenantConnection
     * const ms365TenantConnection = await prisma.ms365TenantConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Ms365TenantConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, Ms365TenantConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ms365TenantConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ms365TenantConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ms365TenantConnections
     * const ms365TenantConnections = await prisma.ms365TenantConnection.findMany()
     * 
     * // Get first 10 Ms365TenantConnections
     * const ms365TenantConnections = await prisma.ms365TenantConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ms365TenantConnectionWithIdOnly = await prisma.ms365TenantConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Ms365TenantConnectionFindManyArgs>(args?: SelectSubset<T, Ms365TenantConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ms365TenantConnection.
     * @param {Ms365TenantConnectionCreateArgs} args - Arguments to create a Ms365TenantConnection.
     * @example
     * // Create one Ms365TenantConnection
     * const Ms365TenantConnection = await prisma.ms365TenantConnection.create({
     *   data: {
     *     // ... data to create a Ms365TenantConnection
     *   }
     * })
     * 
     */
    create<T extends Ms365TenantConnectionCreateArgs>(args: SelectSubset<T, Ms365TenantConnectionCreateArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ms365TenantConnections.
     * @param {Ms365TenantConnectionCreateManyArgs} args - Arguments to create many Ms365TenantConnections.
     * @example
     * // Create many Ms365TenantConnections
     * const ms365TenantConnection = await prisma.ms365TenantConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Ms365TenantConnectionCreateManyArgs>(args?: SelectSubset<T, Ms365TenantConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ms365TenantConnections and returns the data saved in the database.
     * @param {Ms365TenantConnectionCreateManyAndReturnArgs} args - Arguments to create many Ms365TenantConnections.
     * @example
     * // Create many Ms365TenantConnections
     * const ms365TenantConnection = await prisma.ms365TenantConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ms365TenantConnections and only return the `id`
     * const ms365TenantConnectionWithIdOnly = await prisma.ms365TenantConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Ms365TenantConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, Ms365TenantConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ms365TenantConnection.
     * @param {Ms365TenantConnectionDeleteArgs} args - Arguments to delete one Ms365TenantConnection.
     * @example
     * // Delete one Ms365TenantConnection
     * const Ms365TenantConnection = await prisma.ms365TenantConnection.delete({
     *   where: {
     *     // ... filter to delete one Ms365TenantConnection
     *   }
     * })
     * 
     */
    delete<T extends Ms365TenantConnectionDeleteArgs>(args: SelectSubset<T, Ms365TenantConnectionDeleteArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ms365TenantConnection.
     * @param {Ms365TenantConnectionUpdateArgs} args - Arguments to update one Ms365TenantConnection.
     * @example
     * // Update one Ms365TenantConnection
     * const ms365TenantConnection = await prisma.ms365TenantConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Ms365TenantConnectionUpdateArgs>(args: SelectSubset<T, Ms365TenantConnectionUpdateArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ms365TenantConnections.
     * @param {Ms365TenantConnectionDeleteManyArgs} args - Arguments to filter Ms365TenantConnections to delete.
     * @example
     * // Delete a few Ms365TenantConnections
     * const { count } = await prisma.ms365TenantConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Ms365TenantConnectionDeleteManyArgs>(args?: SelectSubset<T, Ms365TenantConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ms365TenantConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ms365TenantConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ms365TenantConnections
     * const ms365TenantConnection = await prisma.ms365TenantConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Ms365TenantConnectionUpdateManyArgs>(args: SelectSubset<T, Ms365TenantConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ms365TenantConnections and returns the data updated in the database.
     * @param {Ms365TenantConnectionUpdateManyAndReturnArgs} args - Arguments to update many Ms365TenantConnections.
     * @example
     * // Update many Ms365TenantConnections
     * const ms365TenantConnection = await prisma.ms365TenantConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ms365TenantConnections and only return the `id`
     * const ms365TenantConnectionWithIdOnly = await prisma.ms365TenantConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Ms365TenantConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, Ms365TenantConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ms365TenantConnection.
     * @param {Ms365TenantConnectionUpsertArgs} args - Arguments to update or create a Ms365TenantConnection.
     * @example
     * // Update or create a Ms365TenantConnection
     * const ms365TenantConnection = await prisma.ms365TenantConnection.upsert({
     *   create: {
     *     // ... data to create a Ms365TenantConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ms365TenantConnection we want to update
     *   }
     * })
     */
    upsert<T extends Ms365TenantConnectionUpsertArgs>(args: SelectSubset<T, Ms365TenantConnectionUpsertArgs<ExtArgs>>): Prisma__Ms365TenantConnectionClient<$Result.GetResult<Prisma.$Ms365TenantConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ms365TenantConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ms365TenantConnectionCountArgs} args - Arguments to filter Ms365TenantConnections to count.
     * @example
     * // Count the number of Ms365TenantConnections
     * const count = await prisma.ms365TenantConnection.count({
     *   where: {
     *     // ... the filter for the Ms365TenantConnections we want to count
     *   }
     * })
    **/
    count<T extends Ms365TenantConnectionCountArgs>(
      args?: Subset<T, Ms365TenantConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ms365TenantConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ms365TenantConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ms365TenantConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ms365TenantConnectionAggregateArgs>(args: Subset<T, Ms365TenantConnectionAggregateArgs>): Prisma.PrismaPromise<GetMs365TenantConnectionAggregateType<T>>

    /**
     * Group by Ms365TenantConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ms365TenantConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ms365TenantConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ms365TenantConnectionGroupByArgs['orderBy'] }
        : { orderBy?: Ms365TenantConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ms365TenantConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMs365TenantConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ms365TenantConnection model
   */
  readonly fields: Ms365TenantConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ms365TenantConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Ms365TenantConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    connectedBy<T extends Ms365TenantConnection$connectedByArgs<ExtArgs> = {}>(args?: Subset<T, Ms365TenantConnection$connectedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ms365TenantConnection model
   */
  interface Ms365TenantConnectionFieldRefs {
    readonly id: FieldRef<"Ms365TenantConnection", 'String'>
    readonly tenantId: FieldRef<"Ms365TenantConnection", 'String'>
    readonly connectedById: FieldRef<"Ms365TenantConnection", 'String'>
    readonly ms365Address: FieldRef<"Ms365TenantConnection", 'String'>
    readonly refreshToken: FieldRef<"Ms365TenantConnection", 'String'>
    readonly createdAt: FieldRef<"Ms365TenantConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"Ms365TenantConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ms365TenantConnection findUnique
   */
  export type Ms365TenantConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Ms365TenantConnection to fetch.
     */
    where: Ms365TenantConnectionWhereUniqueInput
  }

  /**
   * Ms365TenantConnection findUniqueOrThrow
   */
  export type Ms365TenantConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Ms365TenantConnection to fetch.
     */
    where: Ms365TenantConnectionWhereUniqueInput
  }

  /**
   * Ms365TenantConnection findFirst
   */
  export type Ms365TenantConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Ms365TenantConnection to fetch.
     */
    where?: Ms365TenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ms365TenantConnections to fetch.
     */
    orderBy?: Ms365TenantConnectionOrderByWithRelationInput | Ms365TenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ms365TenantConnections.
     */
    cursor?: Ms365TenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ms365TenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ms365TenantConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ms365TenantConnections.
     */
    distinct?: Ms365TenantConnectionScalarFieldEnum | Ms365TenantConnectionScalarFieldEnum[]
  }

  /**
   * Ms365TenantConnection findFirstOrThrow
   */
  export type Ms365TenantConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Ms365TenantConnection to fetch.
     */
    where?: Ms365TenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ms365TenantConnections to fetch.
     */
    orderBy?: Ms365TenantConnectionOrderByWithRelationInput | Ms365TenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ms365TenantConnections.
     */
    cursor?: Ms365TenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ms365TenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ms365TenantConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ms365TenantConnections.
     */
    distinct?: Ms365TenantConnectionScalarFieldEnum | Ms365TenantConnectionScalarFieldEnum[]
  }

  /**
   * Ms365TenantConnection findMany
   */
  export type Ms365TenantConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Ms365TenantConnections to fetch.
     */
    where?: Ms365TenantConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ms365TenantConnections to fetch.
     */
    orderBy?: Ms365TenantConnectionOrderByWithRelationInput | Ms365TenantConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ms365TenantConnections.
     */
    cursor?: Ms365TenantConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ms365TenantConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ms365TenantConnections.
     */
    skip?: number
    distinct?: Ms365TenantConnectionScalarFieldEnum | Ms365TenantConnectionScalarFieldEnum[]
  }

  /**
   * Ms365TenantConnection create
   */
  export type Ms365TenantConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Ms365TenantConnection.
     */
    data: XOR<Ms365TenantConnectionCreateInput, Ms365TenantConnectionUncheckedCreateInput>
  }

  /**
   * Ms365TenantConnection createMany
   */
  export type Ms365TenantConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ms365TenantConnections.
     */
    data: Ms365TenantConnectionCreateManyInput | Ms365TenantConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ms365TenantConnection createManyAndReturn
   */
  export type Ms365TenantConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many Ms365TenantConnections.
     */
    data: Ms365TenantConnectionCreateManyInput | Ms365TenantConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ms365TenantConnection update
   */
  export type Ms365TenantConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Ms365TenantConnection.
     */
    data: XOR<Ms365TenantConnectionUpdateInput, Ms365TenantConnectionUncheckedUpdateInput>
    /**
     * Choose, which Ms365TenantConnection to update.
     */
    where: Ms365TenantConnectionWhereUniqueInput
  }

  /**
   * Ms365TenantConnection updateMany
   */
  export type Ms365TenantConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ms365TenantConnections.
     */
    data: XOR<Ms365TenantConnectionUpdateManyMutationInput, Ms365TenantConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Ms365TenantConnections to update
     */
    where?: Ms365TenantConnectionWhereInput
    /**
     * Limit how many Ms365TenantConnections to update.
     */
    limit?: number
  }

  /**
   * Ms365TenantConnection updateManyAndReturn
   */
  export type Ms365TenantConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * The data used to update Ms365TenantConnections.
     */
    data: XOR<Ms365TenantConnectionUpdateManyMutationInput, Ms365TenantConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Ms365TenantConnections to update
     */
    where?: Ms365TenantConnectionWhereInput
    /**
     * Limit how many Ms365TenantConnections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ms365TenantConnection upsert
   */
  export type Ms365TenantConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Ms365TenantConnection to update in case it exists.
     */
    where: Ms365TenantConnectionWhereUniqueInput
    /**
     * In case the Ms365TenantConnection found by the `where` argument doesn't exist, create a new Ms365TenantConnection with this data.
     */
    create: XOR<Ms365TenantConnectionCreateInput, Ms365TenantConnectionUncheckedCreateInput>
    /**
     * In case the Ms365TenantConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Ms365TenantConnectionUpdateInput, Ms365TenantConnectionUncheckedUpdateInput>
  }

  /**
   * Ms365TenantConnection delete
   */
  export type Ms365TenantConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
    /**
     * Filter which Ms365TenantConnection to delete.
     */
    where: Ms365TenantConnectionWhereUniqueInput
  }

  /**
   * Ms365TenantConnection deleteMany
   */
  export type Ms365TenantConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ms365TenantConnections to delete
     */
    where?: Ms365TenantConnectionWhereInput
    /**
     * Limit how many Ms365TenantConnections to delete.
     */
    limit?: number
  }

  /**
   * Ms365TenantConnection.connectedBy
   */
  export type Ms365TenantConnection$connectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ms365TenantConnection without action
   */
  export type Ms365TenantConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ms365TenantConnection
     */
    select?: Ms365TenantConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ms365TenantConnection
     */
    omit?: Ms365TenantConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Ms365TenantConnectionInclude<ExtArgs> | null
  }


  /**
   * Model LeadExample
   */

  export type AggregateLeadExample = {
    _count: LeadExampleCountAggregateOutputType | null
    _min: LeadExampleMinAggregateOutputType | null
    _max: LeadExampleMaxAggregateOutputType | null
  }

  export type LeadExampleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    messageId: string | null
    subject: string | null
    body: string | null
    label: $Enums.LeadLabel | null
    createdAt: Date | null
  }

  export type LeadExampleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    messageId: string | null
    subject: string | null
    body: string | null
    label: $Enums.LeadLabel | null
    createdAt: Date | null
  }

  export type LeadExampleCountAggregateOutputType = {
    id: number
    tenantId: number
    provider: number
    messageId: number
    subject: number
    body: number
    extracted: number
    label: number
    createdAt: number
    _all: number
  }


  export type LeadExampleMinAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    subject?: true
    body?: true
    label?: true
    createdAt?: true
  }

  export type LeadExampleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    subject?: true
    body?: true
    label?: true
    createdAt?: true
  }

  export type LeadExampleCountAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    subject?: true
    body?: true
    extracted?: true
    label?: true
    createdAt?: true
    _all?: true
  }

  export type LeadExampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadExample to aggregate.
     */
    where?: LeadExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadExamples to fetch.
     */
    orderBy?: LeadExampleOrderByWithRelationInput | LeadExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadExamples
    **/
    _count?: true | LeadExampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadExampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadExampleMaxAggregateInputType
  }

  export type GetLeadExampleAggregateType<T extends LeadExampleAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadExample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadExample[P]>
      : GetScalarType<T[P], AggregateLeadExample[P]>
  }




  export type LeadExampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadExampleWhereInput
    orderBy?: LeadExampleOrderByWithAggregationInput | LeadExampleOrderByWithAggregationInput[]
    by: LeadExampleScalarFieldEnum[] | LeadExampleScalarFieldEnum
    having?: LeadExampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadExampleCountAggregateInputType | true
    _min?: LeadExampleMinAggregateInputType
    _max?: LeadExampleMaxAggregateInputType
  }

  export type LeadExampleGroupByOutputType = {
    id: string
    tenantId: string
    provider: string
    messageId: string
    subject: string | null
    body: string | null
    extracted: JsonValue | null
    label: $Enums.LeadLabel
    createdAt: Date
    _count: LeadExampleCountAggregateOutputType | null
    _min: LeadExampleMinAggregateOutputType | null
    _max: LeadExampleMaxAggregateOutputType | null
  }

  type GetLeadExampleGroupByPayload<T extends LeadExampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadExampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadExampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadExampleGroupByOutputType[P]>
            : GetScalarType<T[P], LeadExampleGroupByOutputType[P]>
        }
      >
    >


  export type LeadExampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    subject?: boolean
    body?: boolean
    extracted?: boolean
    label?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["leadExample"]>

  export type LeadExampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    subject?: boolean
    body?: boolean
    extracted?: boolean
    label?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["leadExample"]>

  export type LeadExampleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    subject?: boolean
    body?: boolean
    extracted?: boolean
    label?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["leadExample"]>

  export type LeadExampleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    subject?: boolean
    body?: boolean
    extracted?: boolean
    label?: boolean
    createdAt?: boolean
  }

  export type LeadExampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "provider" | "messageId" | "subject" | "body" | "extracted" | "label" | "createdAt", ExtArgs["result"]["leadExample"]>

  export type $LeadExamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadExample"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      provider: string
      messageId: string
      subject: string | null
      body: string | null
      extracted: Prisma.JsonValue | null
      label: $Enums.LeadLabel
      createdAt: Date
    }, ExtArgs["result"]["leadExample"]>
    composites: {}
  }

  type LeadExampleGetPayload<S extends boolean | null | undefined | LeadExampleDefaultArgs> = $Result.GetResult<Prisma.$LeadExamplePayload, S>

  type LeadExampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadExampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadExampleCountAggregateInputType | true
    }

  export interface LeadExampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadExample'], meta: { name: 'LeadExample' } }
    /**
     * Find zero or one LeadExample that matches the filter.
     * @param {LeadExampleFindUniqueArgs} args - Arguments to find a LeadExample
     * @example
     * // Get one LeadExample
     * const leadExample = await prisma.leadExample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadExampleFindUniqueArgs>(args: SelectSubset<T, LeadExampleFindUniqueArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadExample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadExampleFindUniqueOrThrowArgs} args - Arguments to find a LeadExample
     * @example
     * // Get one LeadExample
     * const leadExample = await prisma.leadExample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadExampleFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadExampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadExample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadExampleFindFirstArgs} args - Arguments to find a LeadExample
     * @example
     * // Get one LeadExample
     * const leadExample = await prisma.leadExample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadExampleFindFirstArgs>(args?: SelectSubset<T, LeadExampleFindFirstArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadExample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadExampleFindFirstOrThrowArgs} args - Arguments to find a LeadExample
     * @example
     * // Get one LeadExample
     * const leadExample = await prisma.leadExample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadExampleFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadExampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadExamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadExampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadExamples
     * const leadExamples = await prisma.leadExample.findMany()
     * 
     * // Get first 10 LeadExamples
     * const leadExamples = await prisma.leadExample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadExampleWithIdOnly = await prisma.leadExample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadExampleFindManyArgs>(args?: SelectSubset<T, LeadExampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadExample.
     * @param {LeadExampleCreateArgs} args - Arguments to create a LeadExample.
     * @example
     * // Create one LeadExample
     * const LeadExample = await prisma.leadExample.create({
     *   data: {
     *     // ... data to create a LeadExample
     *   }
     * })
     * 
     */
    create<T extends LeadExampleCreateArgs>(args: SelectSubset<T, LeadExampleCreateArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadExamples.
     * @param {LeadExampleCreateManyArgs} args - Arguments to create many LeadExamples.
     * @example
     * // Create many LeadExamples
     * const leadExample = await prisma.leadExample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadExampleCreateManyArgs>(args?: SelectSubset<T, LeadExampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadExamples and returns the data saved in the database.
     * @param {LeadExampleCreateManyAndReturnArgs} args - Arguments to create many LeadExamples.
     * @example
     * // Create many LeadExamples
     * const leadExample = await prisma.leadExample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadExamples and only return the `id`
     * const leadExampleWithIdOnly = await prisma.leadExample.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadExampleCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadExampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadExample.
     * @param {LeadExampleDeleteArgs} args - Arguments to delete one LeadExample.
     * @example
     * // Delete one LeadExample
     * const LeadExample = await prisma.leadExample.delete({
     *   where: {
     *     // ... filter to delete one LeadExample
     *   }
     * })
     * 
     */
    delete<T extends LeadExampleDeleteArgs>(args: SelectSubset<T, LeadExampleDeleteArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadExample.
     * @param {LeadExampleUpdateArgs} args - Arguments to update one LeadExample.
     * @example
     * // Update one LeadExample
     * const leadExample = await prisma.leadExample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadExampleUpdateArgs>(args: SelectSubset<T, LeadExampleUpdateArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadExamples.
     * @param {LeadExampleDeleteManyArgs} args - Arguments to filter LeadExamples to delete.
     * @example
     * // Delete a few LeadExamples
     * const { count } = await prisma.leadExample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadExampleDeleteManyArgs>(args?: SelectSubset<T, LeadExampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadExamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadExampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadExamples
     * const leadExample = await prisma.leadExample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadExampleUpdateManyArgs>(args: SelectSubset<T, LeadExampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadExamples and returns the data updated in the database.
     * @param {LeadExampleUpdateManyAndReturnArgs} args - Arguments to update many LeadExamples.
     * @example
     * // Update many LeadExamples
     * const leadExample = await prisma.leadExample.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadExamples and only return the `id`
     * const leadExampleWithIdOnly = await prisma.leadExample.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadExampleUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadExampleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadExample.
     * @param {LeadExampleUpsertArgs} args - Arguments to update or create a LeadExample.
     * @example
     * // Update or create a LeadExample
     * const leadExample = await prisma.leadExample.upsert({
     *   create: {
     *     // ... data to create a LeadExample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadExample we want to update
     *   }
     * })
     */
    upsert<T extends LeadExampleUpsertArgs>(args: SelectSubset<T, LeadExampleUpsertArgs<ExtArgs>>): Prisma__LeadExampleClient<$Result.GetResult<Prisma.$LeadExamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadExamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadExampleCountArgs} args - Arguments to filter LeadExamples to count.
     * @example
     * // Count the number of LeadExamples
     * const count = await prisma.leadExample.count({
     *   where: {
     *     // ... the filter for the LeadExamples we want to count
     *   }
     * })
    **/
    count<T extends LeadExampleCountArgs>(
      args?: Subset<T, LeadExampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadExampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadExample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadExampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadExampleAggregateArgs>(args: Subset<T, LeadExampleAggregateArgs>): Prisma.PrismaPromise<GetLeadExampleAggregateType<T>>

    /**
     * Group by LeadExample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadExampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadExampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadExampleGroupByArgs['orderBy'] }
        : { orderBy?: LeadExampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadExampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadExampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadExample model
   */
  readonly fields: LeadExampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadExample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadExampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadExample model
   */
  interface LeadExampleFieldRefs {
    readonly id: FieldRef<"LeadExample", 'String'>
    readonly tenantId: FieldRef<"LeadExample", 'String'>
    readonly provider: FieldRef<"LeadExample", 'String'>
    readonly messageId: FieldRef<"LeadExample", 'String'>
    readonly subject: FieldRef<"LeadExample", 'String'>
    readonly body: FieldRef<"LeadExample", 'String'>
    readonly extracted: FieldRef<"LeadExample", 'Json'>
    readonly label: FieldRef<"LeadExample", 'LeadLabel'>
    readonly createdAt: FieldRef<"LeadExample", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadExample findUnique
   */
  export type LeadExampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadExample to fetch.
     */
    where: LeadExampleWhereUniqueInput
  }

  /**
   * LeadExample findUniqueOrThrow
   */
  export type LeadExampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadExample to fetch.
     */
    where: LeadExampleWhereUniqueInput
  }

  /**
   * LeadExample findFirst
   */
  export type LeadExampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadExample to fetch.
     */
    where?: LeadExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadExamples to fetch.
     */
    orderBy?: LeadExampleOrderByWithRelationInput | LeadExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadExamples.
     */
    cursor?: LeadExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadExamples.
     */
    distinct?: LeadExampleScalarFieldEnum | LeadExampleScalarFieldEnum[]
  }

  /**
   * LeadExample findFirstOrThrow
   */
  export type LeadExampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadExample to fetch.
     */
    where?: LeadExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadExamples to fetch.
     */
    orderBy?: LeadExampleOrderByWithRelationInput | LeadExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadExamples.
     */
    cursor?: LeadExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadExamples.
     */
    distinct?: LeadExampleScalarFieldEnum | LeadExampleScalarFieldEnum[]
  }

  /**
   * LeadExample findMany
   */
  export type LeadExampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadExamples to fetch.
     */
    where?: LeadExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadExamples to fetch.
     */
    orderBy?: LeadExampleOrderByWithRelationInput | LeadExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadExamples.
     */
    cursor?: LeadExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadExamples.
     */
    skip?: number
    distinct?: LeadExampleScalarFieldEnum | LeadExampleScalarFieldEnum[]
  }

  /**
   * LeadExample create
   */
  export type LeadExampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * The data needed to create a LeadExample.
     */
    data: XOR<LeadExampleCreateInput, LeadExampleUncheckedCreateInput>
  }

  /**
   * LeadExample createMany
   */
  export type LeadExampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadExamples.
     */
    data: LeadExampleCreateManyInput | LeadExampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadExample createManyAndReturn
   */
  export type LeadExampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * The data used to create many LeadExamples.
     */
    data: LeadExampleCreateManyInput | LeadExampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadExample update
   */
  export type LeadExampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * The data needed to update a LeadExample.
     */
    data: XOR<LeadExampleUpdateInput, LeadExampleUncheckedUpdateInput>
    /**
     * Choose, which LeadExample to update.
     */
    where: LeadExampleWhereUniqueInput
  }

  /**
   * LeadExample updateMany
   */
  export type LeadExampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadExamples.
     */
    data: XOR<LeadExampleUpdateManyMutationInput, LeadExampleUncheckedUpdateManyInput>
    /**
     * Filter which LeadExamples to update
     */
    where?: LeadExampleWhereInput
    /**
     * Limit how many LeadExamples to update.
     */
    limit?: number
  }

  /**
   * LeadExample updateManyAndReturn
   */
  export type LeadExampleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * The data used to update LeadExamples.
     */
    data: XOR<LeadExampleUpdateManyMutationInput, LeadExampleUncheckedUpdateManyInput>
    /**
     * Filter which LeadExamples to update
     */
    where?: LeadExampleWhereInput
    /**
     * Limit how many LeadExamples to update.
     */
    limit?: number
  }

  /**
   * LeadExample upsert
   */
  export type LeadExampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * The filter to search for the LeadExample to update in case it exists.
     */
    where: LeadExampleWhereUniqueInput
    /**
     * In case the LeadExample found by the `where` argument doesn't exist, create a new LeadExample with this data.
     */
    create: XOR<LeadExampleCreateInput, LeadExampleUncheckedCreateInput>
    /**
     * In case the LeadExample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadExampleUpdateInput, LeadExampleUncheckedUpdateInput>
  }

  /**
   * LeadExample delete
   */
  export type LeadExampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
    /**
     * Filter which LeadExample to delete.
     */
    where: LeadExampleWhereUniqueInput
  }

  /**
   * LeadExample deleteMany
   */
  export type LeadExampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadExamples to delete
     */
    where?: LeadExampleWhereInput
    /**
     * Limit how many LeadExamples to delete.
     */
    limit?: number
  }

  /**
   * LeadExample without action
   */
  export type LeadExampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadExample
     */
    select?: LeadExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadExample
     */
    omit?: LeadExampleOmit<ExtArgs> | null
  }


  /**
   * Model LeadTrainingExample
   */

  export type AggregateLeadTrainingExample = {
    _count: LeadTrainingExampleCountAggregateOutputType | null
    _min: LeadTrainingExampleMinAggregateOutputType | null
    _max: LeadTrainingExampleMaxAggregateOutputType | null
  }

  export type LeadTrainingExampleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    messageId: string | null
    label: string | null
    createdAt: Date | null
  }

  export type LeadTrainingExampleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    messageId: string | null
    label: string | null
    createdAt: Date | null
  }

  export type LeadTrainingExampleCountAggregateOutputType = {
    id: number
    tenantId: number
    provider: number
    messageId: number
    label: number
    extracted: number
    createdAt: number
    _all: number
  }


  export type LeadTrainingExampleMinAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    label?: true
    createdAt?: true
  }

  export type LeadTrainingExampleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    label?: true
    createdAt?: true
  }

  export type LeadTrainingExampleCountAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    messageId?: true
    label?: true
    extracted?: true
    createdAt?: true
    _all?: true
  }

  export type LeadTrainingExampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadTrainingExample to aggregate.
     */
    where?: LeadTrainingExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTrainingExamples to fetch.
     */
    orderBy?: LeadTrainingExampleOrderByWithRelationInput | LeadTrainingExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadTrainingExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTrainingExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTrainingExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadTrainingExamples
    **/
    _count?: true | LeadTrainingExampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadTrainingExampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadTrainingExampleMaxAggregateInputType
  }

  export type GetLeadTrainingExampleAggregateType<T extends LeadTrainingExampleAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadTrainingExample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadTrainingExample[P]>
      : GetScalarType<T[P], AggregateLeadTrainingExample[P]>
  }




  export type LeadTrainingExampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadTrainingExampleWhereInput
    orderBy?: LeadTrainingExampleOrderByWithAggregationInput | LeadTrainingExampleOrderByWithAggregationInput[]
    by: LeadTrainingExampleScalarFieldEnum[] | LeadTrainingExampleScalarFieldEnum
    having?: LeadTrainingExampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadTrainingExampleCountAggregateInputType | true
    _min?: LeadTrainingExampleMinAggregateInputType
    _max?: LeadTrainingExampleMaxAggregateInputType
  }

  export type LeadTrainingExampleGroupByOutputType = {
    id: string
    tenantId: string
    provider: string
    messageId: string
    label: string
    extracted: JsonValue | null
    createdAt: Date
    _count: LeadTrainingExampleCountAggregateOutputType | null
    _min: LeadTrainingExampleMinAggregateOutputType | null
    _max: LeadTrainingExampleMaxAggregateOutputType | null
  }

  type GetLeadTrainingExampleGroupByPayload<T extends LeadTrainingExampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadTrainingExampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadTrainingExampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadTrainingExampleGroupByOutputType[P]>
            : GetScalarType<T[P], LeadTrainingExampleGroupByOutputType[P]>
        }
      >
    >


  export type LeadTrainingExampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    label?: boolean
    extracted?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["leadTrainingExample"]>

  export type LeadTrainingExampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    label?: boolean
    extracted?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["leadTrainingExample"]>

  export type LeadTrainingExampleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    label?: boolean
    extracted?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["leadTrainingExample"]>

  export type LeadTrainingExampleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    messageId?: boolean
    label?: boolean
    extracted?: boolean
    createdAt?: boolean
  }

  export type LeadTrainingExampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "provider" | "messageId" | "label" | "extracted" | "createdAt", ExtArgs["result"]["leadTrainingExample"]>

  export type $LeadTrainingExamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadTrainingExample"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      provider: string
      messageId: string
      label: string
      extracted: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["leadTrainingExample"]>
    composites: {}
  }

  type LeadTrainingExampleGetPayload<S extends boolean | null | undefined | LeadTrainingExampleDefaultArgs> = $Result.GetResult<Prisma.$LeadTrainingExamplePayload, S>

  type LeadTrainingExampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadTrainingExampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadTrainingExampleCountAggregateInputType | true
    }

  export interface LeadTrainingExampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadTrainingExample'], meta: { name: 'LeadTrainingExample' } }
    /**
     * Find zero or one LeadTrainingExample that matches the filter.
     * @param {LeadTrainingExampleFindUniqueArgs} args - Arguments to find a LeadTrainingExample
     * @example
     * // Get one LeadTrainingExample
     * const leadTrainingExample = await prisma.leadTrainingExample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadTrainingExampleFindUniqueArgs>(args: SelectSubset<T, LeadTrainingExampleFindUniqueArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadTrainingExample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadTrainingExampleFindUniqueOrThrowArgs} args - Arguments to find a LeadTrainingExample
     * @example
     * // Get one LeadTrainingExample
     * const leadTrainingExample = await prisma.leadTrainingExample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadTrainingExampleFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadTrainingExampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadTrainingExample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTrainingExampleFindFirstArgs} args - Arguments to find a LeadTrainingExample
     * @example
     * // Get one LeadTrainingExample
     * const leadTrainingExample = await prisma.leadTrainingExample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadTrainingExampleFindFirstArgs>(args?: SelectSubset<T, LeadTrainingExampleFindFirstArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadTrainingExample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTrainingExampleFindFirstOrThrowArgs} args - Arguments to find a LeadTrainingExample
     * @example
     * // Get one LeadTrainingExample
     * const leadTrainingExample = await prisma.leadTrainingExample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadTrainingExampleFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadTrainingExampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadTrainingExamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTrainingExampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadTrainingExamples
     * const leadTrainingExamples = await prisma.leadTrainingExample.findMany()
     * 
     * // Get first 10 LeadTrainingExamples
     * const leadTrainingExamples = await prisma.leadTrainingExample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadTrainingExampleWithIdOnly = await prisma.leadTrainingExample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadTrainingExampleFindManyArgs>(args?: SelectSubset<T, LeadTrainingExampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadTrainingExample.
     * @param {LeadTrainingExampleCreateArgs} args - Arguments to create a LeadTrainingExample.
     * @example
     * // Create one LeadTrainingExample
     * const LeadTrainingExample = await prisma.leadTrainingExample.create({
     *   data: {
     *     // ... data to create a LeadTrainingExample
     *   }
     * })
     * 
     */
    create<T extends LeadTrainingExampleCreateArgs>(args: SelectSubset<T, LeadTrainingExampleCreateArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadTrainingExamples.
     * @param {LeadTrainingExampleCreateManyArgs} args - Arguments to create many LeadTrainingExamples.
     * @example
     * // Create many LeadTrainingExamples
     * const leadTrainingExample = await prisma.leadTrainingExample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadTrainingExampleCreateManyArgs>(args?: SelectSubset<T, LeadTrainingExampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadTrainingExamples and returns the data saved in the database.
     * @param {LeadTrainingExampleCreateManyAndReturnArgs} args - Arguments to create many LeadTrainingExamples.
     * @example
     * // Create many LeadTrainingExamples
     * const leadTrainingExample = await prisma.leadTrainingExample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadTrainingExamples and only return the `id`
     * const leadTrainingExampleWithIdOnly = await prisma.leadTrainingExample.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadTrainingExampleCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadTrainingExampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadTrainingExample.
     * @param {LeadTrainingExampleDeleteArgs} args - Arguments to delete one LeadTrainingExample.
     * @example
     * // Delete one LeadTrainingExample
     * const LeadTrainingExample = await prisma.leadTrainingExample.delete({
     *   where: {
     *     // ... filter to delete one LeadTrainingExample
     *   }
     * })
     * 
     */
    delete<T extends LeadTrainingExampleDeleteArgs>(args: SelectSubset<T, LeadTrainingExampleDeleteArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadTrainingExample.
     * @param {LeadTrainingExampleUpdateArgs} args - Arguments to update one LeadTrainingExample.
     * @example
     * // Update one LeadTrainingExample
     * const leadTrainingExample = await prisma.leadTrainingExample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadTrainingExampleUpdateArgs>(args: SelectSubset<T, LeadTrainingExampleUpdateArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadTrainingExamples.
     * @param {LeadTrainingExampleDeleteManyArgs} args - Arguments to filter LeadTrainingExamples to delete.
     * @example
     * // Delete a few LeadTrainingExamples
     * const { count } = await prisma.leadTrainingExample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadTrainingExampleDeleteManyArgs>(args?: SelectSubset<T, LeadTrainingExampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadTrainingExamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTrainingExampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadTrainingExamples
     * const leadTrainingExample = await prisma.leadTrainingExample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadTrainingExampleUpdateManyArgs>(args: SelectSubset<T, LeadTrainingExampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadTrainingExamples and returns the data updated in the database.
     * @param {LeadTrainingExampleUpdateManyAndReturnArgs} args - Arguments to update many LeadTrainingExamples.
     * @example
     * // Update many LeadTrainingExamples
     * const leadTrainingExample = await prisma.leadTrainingExample.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadTrainingExamples and only return the `id`
     * const leadTrainingExampleWithIdOnly = await prisma.leadTrainingExample.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadTrainingExampleUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadTrainingExampleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadTrainingExample.
     * @param {LeadTrainingExampleUpsertArgs} args - Arguments to update or create a LeadTrainingExample.
     * @example
     * // Update or create a LeadTrainingExample
     * const leadTrainingExample = await prisma.leadTrainingExample.upsert({
     *   create: {
     *     // ... data to create a LeadTrainingExample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadTrainingExample we want to update
     *   }
     * })
     */
    upsert<T extends LeadTrainingExampleUpsertArgs>(args: SelectSubset<T, LeadTrainingExampleUpsertArgs<ExtArgs>>): Prisma__LeadTrainingExampleClient<$Result.GetResult<Prisma.$LeadTrainingExamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadTrainingExamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTrainingExampleCountArgs} args - Arguments to filter LeadTrainingExamples to count.
     * @example
     * // Count the number of LeadTrainingExamples
     * const count = await prisma.leadTrainingExample.count({
     *   where: {
     *     // ... the filter for the LeadTrainingExamples we want to count
     *   }
     * })
    **/
    count<T extends LeadTrainingExampleCountArgs>(
      args?: Subset<T, LeadTrainingExampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadTrainingExampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadTrainingExample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTrainingExampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadTrainingExampleAggregateArgs>(args: Subset<T, LeadTrainingExampleAggregateArgs>): Prisma.PrismaPromise<GetLeadTrainingExampleAggregateType<T>>

    /**
     * Group by LeadTrainingExample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTrainingExampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadTrainingExampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadTrainingExampleGroupByArgs['orderBy'] }
        : { orderBy?: LeadTrainingExampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadTrainingExampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadTrainingExampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadTrainingExample model
   */
  readonly fields: LeadTrainingExampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadTrainingExample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadTrainingExampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadTrainingExample model
   */
  interface LeadTrainingExampleFieldRefs {
    readonly id: FieldRef<"LeadTrainingExample", 'String'>
    readonly tenantId: FieldRef<"LeadTrainingExample", 'String'>
    readonly provider: FieldRef<"LeadTrainingExample", 'String'>
    readonly messageId: FieldRef<"LeadTrainingExample", 'String'>
    readonly label: FieldRef<"LeadTrainingExample", 'String'>
    readonly extracted: FieldRef<"LeadTrainingExample", 'Json'>
    readonly createdAt: FieldRef<"LeadTrainingExample", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadTrainingExample findUnique
   */
  export type LeadTrainingExampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadTrainingExample to fetch.
     */
    where: LeadTrainingExampleWhereUniqueInput
  }

  /**
   * LeadTrainingExample findUniqueOrThrow
   */
  export type LeadTrainingExampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadTrainingExample to fetch.
     */
    where: LeadTrainingExampleWhereUniqueInput
  }

  /**
   * LeadTrainingExample findFirst
   */
  export type LeadTrainingExampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadTrainingExample to fetch.
     */
    where?: LeadTrainingExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTrainingExamples to fetch.
     */
    orderBy?: LeadTrainingExampleOrderByWithRelationInput | LeadTrainingExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadTrainingExamples.
     */
    cursor?: LeadTrainingExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTrainingExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTrainingExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadTrainingExamples.
     */
    distinct?: LeadTrainingExampleScalarFieldEnum | LeadTrainingExampleScalarFieldEnum[]
  }

  /**
   * LeadTrainingExample findFirstOrThrow
   */
  export type LeadTrainingExampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadTrainingExample to fetch.
     */
    where?: LeadTrainingExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTrainingExamples to fetch.
     */
    orderBy?: LeadTrainingExampleOrderByWithRelationInput | LeadTrainingExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadTrainingExamples.
     */
    cursor?: LeadTrainingExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTrainingExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTrainingExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadTrainingExamples.
     */
    distinct?: LeadTrainingExampleScalarFieldEnum | LeadTrainingExampleScalarFieldEnum[]
  }

  /**
   * LeadTrainingExample findMany
   */
  export type LeadTrainingExampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * Filter, which LeadTrainingExamples to fetch.
     */
    where?: LeadTrainingExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTrainingExamples to fetch.
     */
    orderBy?: LeadTrainingExampleOrderByWithRelationInput | LeadTrainingExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadTrainingExamples.
     */
    cursor?: LeadTrainingExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTrainingExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTrainingExamples.
     */
    skip?: number
    distinct?: LeadTrainingExampleScalarFieldEnum | LeadTrainingExampleScalarFieldEnum[]
  }

  /**
   * LeadTrainingExample create
   */
  export type LeadTrainingExampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * The data needed to create a LeadTrainingExample.
     */
    data: XOR<LeadTrainingExampleCreateInput, LeadTrainingExampleUncheckedCreateInput>
  }

  /**
   * LeadTrainingExample createMany
   */
  export type LeadTrainingExampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadTrainingExamples.
     */
    data: LeadTrainingExampleCreateManyInput | LeadTrainingExampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadTrainingExample createManyAndReturn
   */
  export type LeadTrainingExampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * The data used to create many LeadTrainingExamples.
     */
    data: LeadTrainingExampleCreateManyInput | LeadTrainingExampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadTrainingExample update
   */
  export type LeadTrainingExampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * The data needed to update a LeadTrainingExample.
     */
    data: XOR<LeadTrainingExampleUpdateInput, LeadTrainingExampleUncheckedUpdateInput>
    /**
     * Choose, which LeadTrainingExample to update.
     */
    where: LeadTrainingExampleWhereUniqueInput
  }

  /**
   * LeadTrainingExample updateMany
   */
  export type LeadTrainingExampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadTrainingExamples.
     */
    data: XOR<LeadTrainingExampleUpdateManyMutationInput, LeadTrainingExampleUncheckedUpdateManyInput>
    /**
     * Filter which LeadTrainingExamples to update
     */
    where?: LeadTrainingExampleWhereInput
    /**
     * Limit how many LeadTrainingExamples to update.
     */
    limit?: number
  }

  /**
   * LeadTrainingExample updateManyAndReturn
   */
  export type LeadTrainingExampleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * The data used to update LeadTrainingExamples.
     */
    data: XOR<LeadTrainingExampleUpdateManyMutationInput, LeadTrainingExampleUncheckedUpdateManyInput>
    /**
     * Filter which LeadTrainingExamples to update
     */
    where?: LeadTrainingExampleWhereInput
    /**
     * Limit how many LeadTrainingExamples to update.
     */
    limit?: number
  }

  /**
   * LeadTrainingExample upsert
   */
  export type LeadTrainingExampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * The filter to search for the LeadTrainingExample to update in case it exists.
     */
    where: LeadTrainingExampleWhereUniqueInput
    /**
     * In case the LeadTrainingExample found by the `where` argument doesn't exist, create a new LeadTrainingExample with this data.
     */
    create: XOR<LeadTrainingExampleCreateInput, LeadTrainingExampleUncheckedCreateInput>
    /**
     * In case the LeadTrainingExample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadTrainingExampleUpdateInput, LeadTrainingExampleUncheckedUpdateInput>
  }

  /**
   * LeadTrainingExample delete
   */
  export type LeadTrainingExampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
    /**
     * Filter which LeadTrainingExample to delete.
     */
    where: LeadTrainingExampleWhereUniqueInput
  }

  /**
   * LeadTrainingExample deleteMany
   */
  export type LeadTrainingExampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadTrainingExamples to delete
     */
    where?: LeadTrainingExampleWhereInput
    /**
     * Limit how many LeadTrainingExamples to delete.
     */
    limit?: number
  }

  /**
   * LeadTrainingExample without action
   */
  export type LeadTrainingExampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTrainingExample
     */
    select?: LeadTrainingExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTrainingExample
     */
    omit?: LeadTrainingExampleOmit<ExtArgs> | null
  }


  /**
   * Model TenantSettings
   */

  export type AggregateTenantSettings = {
    _count: TenantSettingsCountAggregateOutputType | null
    _min: TenantSettingsMinAggregateOutputType | null
    _max: TenantSettingsMaxAggregateOutputType | null
  }

  export type TenantSettingsMinAggregateOutputType = {
    tenantId: string | null
    slug: string | null
    brandName: string | null
    introHtml: string | null
    website: string | null
    phone: string | null
    logoUrl: string | null
    inboxWatchEnabled: boolean | null
    inboxLastRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantSettingsMaxAggregateOutputType = {
    tenantId: string | null
    slug: string | null
    brandName: string | null
    introHtml: string | null
    website: string | null
    phone: string | null
    logoUrl: string | null
    inboxWatchEnabled: boolean | null
    inboxLastRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantSettingsCountAggregateOutputType = {
    tenantId: number
    slug: number
    brandName: number
    introHtml: number
    website: number
    phone: number
    logoUrl: number
    links: number
    questionnaire: number
    inbox: number
    inboxWatchEnabled: number
    inboxLastRun: number
    quoteDefaults: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantSettingsMinAggregateInputType = {
    tenantId?: true
    slug?: true
    brandName?: true
    introHtml?: true
    website?: true
    phone?: true
    logoUrl?: true
    inboxWatchEnabled?: true
    inboxLastRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantSettingsMaxAggregateInputType = {
    tenantId?: true
    slug?: true
    brandName?: true
    introHtml?: true
    website?: true
    phone?: true
    logoUrl?: true
    inboxWatchEnabled?: true
    inboxLastRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantSettingsCountAggregateInputType = {
    tenantId?: true
    slug?: true
    brandName?: true
    introHtml?: true
    website?: true
    phone?: true
    logoUrl?: true
    links?: true
    questionnaire?: true
    inbox?: true
    inboxWatchEnabled?: true
    inboxLastRun?: true
    quoteDefaults?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSettings to aggregate.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantSettings
    **/
    _count?: true | TenantSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantSettingsMaxAggregateInputType
  }

  export type GetTenantSettingsAggregateType<T extends TenantSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantSettings[P]>
      : GetScalarType<T[P], AggregateTenantSettings[P]>
  }




  export type TenantSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantSettingsWhereInput
    orderBy?: TenantSettingsOrderByWithAggregationInput | TenantSettingsOrderByWithAggregationInput[]
    by: TenantSettingsScalarFieldEnum[] | TenantSettingsScalarFieldEnum
    having?: TenantSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantSettingsCountAggregateInputType | true
    _min?: TenantSettingsMinAggregateInputType
    _max?: TenantSettingsMaxAggregateInputType
  }

  export type TenantSettingsGroupByOutputType = {
    tenantId: string
    slug: string
    brandName: string
    introHtml: string | null
    website: string | null
    phone: string | null
    logoUrl: string | null
    links: JsonValue | null
    questionnaire: JsonValue | null
    inbox: JsonValue | null
    inboxWatchEnabled: boolean
    inboxLastRun: Date | null
    quoteDefaults: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TenantSettingsCountAggregateOutputType | null
    _min: TenantSettingsMinAggregateOutputType | null
    _max: TenantSettingsMaxAggregateOutputType | null
  }

  type GetTenantSettingsGroupByPayload<T extends TenantSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], TenantSettingsGroupByOutputType[P]>
        }
      >
    >


  export type TenantSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenantId?: boolean
    slug?: boolean
    brandName?: boolean
    introHtml?: boolean
    website?: boolean
    phone?: boolean
    logoUrl?: boolean
    links?: boolean
    questionnaire?: boolean
    inbox?: boolean
    inboxWatchEnabled?: boolean
    inboxLastRun?: boolean
    quoteDefaults?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenantId?: boolean
    slug?: boolean
    brandName?: boolean
    introHtml?: boolean
    website?: boolean
    phone?: boolean
    logoUrl?: boolean
    links?: boolean
    questionnaire?: boolean
    inbox?: boolean
    inboxWatchEnabled?: boolean
    inboxLastRun?: boolean
    quoteDefaults?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenantId?: boolean
    slug?: boolean
    brandName?: boolean
    introHtml?: boolean
    website?: boolean
    phone?: boolean
    logoUrl?: boolean
    links?: boolean
    questionnaire?: boolean
    inbox?: boolean
    inboxWatchEnabled?: boolean
    inboxLastRun?: boolean
    quoteDefaults?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectScalar = {
    tenantId?: boolean
    slug?: boolean
    brandName?: boolean
    introHtml?: boolean
    website?: boolean
    phone?: boolean
    logoUrl?: boolean
    links?: boolean
    questionnaire?: boolean
    inbox?: boolean
    inboxWatchEnabled?: boolean
    inboxLastRun?: boolean
    quoteDefaults?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tenantId" | "slug" | "brandName" | "introHtml" | "website" | "phone" | "logoUrl" | "links" | "questionnaire" | "inbox" | "inboxWatchEnabled" | "inboxLastRun" | "quoteDefaults" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantSettings"]>

  export type $TenantSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      tenantId: string
      slug: string
      brandName: string
      introHtml: string | null
      website: string | null
      phone: string | null
      logoUrl: string | null
      links: Prisma.JsonValue | null
      questionnaire: Prisma.JsonValue | null
      inbox: Prisma.JsonValue | null
      inboxWatchEnabled: boolean
      inboxLastRun: Date | null
      quoteDefaults: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantSettings"]>
    composites: {}
  }

  type TenantSettingsGetPayload<S extends boolean | null | undefined | TenantSettingsDefaultArgs> = $Result.GetResult<Prisma.$TenantSettingsPayload, S>

  type TenantSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantSettingsCountAggregateInputType | true
    }

  export interface TenantSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantSettings'], meta: { name: 'TenantSettings' } }
    /**
     * Find zero or one TenantSettings that matches the filter.
     * @param {TenantSettingsFindUniqueArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantSettingsFindUniqueArgs>(args: SelectSubset<T, TenantSettingsFindUniqueArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantSettingsFindUniqueOrThrowArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindFirstArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantSettingsFindFirstArgs>(args?: SelectSubset<T, TenantSettingsFindFirstArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindFirstOrThrowArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findMany()
     * 
     * // Get first 10 TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findMany({ take: 10 })
     * 
     * // Only select the `tenantId`
     * const tenantSettingsWithTenantIdOnly = await prisma.tenantSettings.findMany({ select: { tenantId: true } })
     * 
     */
    findMany<T extends TenantSettingsFindManyArgs>(args?: SelectSubset<T, TenantSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantSettings.
     * @param {TenantSettingsCreateArgs} args - Arguments to create a TenantSettings.
     * @example
     * // Create one TenantSettings
     * const TenantSettings = await prisma.tenantSettings.create({
     *   data: {
     *     // ... data to create a TenantSettings
     *   }
     * })
     * 
     */
    create<T extends TenantSettingsCreateArgs>(args: SelectSubset<T, TenantSettingsCreateArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantSettings.
     * @param {TenantSettingsCreateManyArgs} args - Arguments to create many TenantSettings.
     * @example
     * // Create many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantSettingsCreateManyArgs>(args?: SelectSubset<T, TenantSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantSettings and returns the data saved in the database.
     * @param {TenantSettingsCreateManyAndReturnArgs} args - Arguments to create many TenantSettings.
     * @example
     * // Create many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantSettings and only return the `tenantId`
     * const tenantSettingsWithTenantIdOnly = await prisma.tenantSettings.createManyAndReturn({
     *   select: { tenantId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantSettings.
     * @param {TenantSettingsDeleteArgs} args - Arguments to delete one TenantSettings.
     * @example
     * // Delete one TenantSettings
     * const TenantSettings = await prisma.tenantSettings.delete({
     *   where: {
     *     // ... filter to delete one TenantSettings
     *   }
     * })
     * 
     */
    delete<T extends TenantSettingsDeleteArgs>(args: SelectSubset<T, TenantSettingsDeleteArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantSettings.
     * @param {TenantSettingsUpdateArgs} args - Arguments to update one TenantSettings.
     * @example
     * // Update one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantSettingsUpdateArgs>(args: SelectSubset<T, TenantSettingsUpdateArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantSettings.
     * @param {TenantSettingsDeleteManyArgs} args - Arguments to filter TenantSettings to delete.
     * @example
     * // Delete a few TenantSettings
     * const { count } = await prisma.tenantSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantSettingsDeleteManyArgs>(args?: SelectSubset<T, TenantSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantSettingsUpdateManyArgs>(args: SelectSubset<T, TenantSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantSettings and returns the data updated in the database.
     * @param {TenantSettingsUpdateManyAndReturnArgs} args - Arguments to update many TenantSettings.
     * @example
     * // Update many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantSettings and only return the `tenantId`
     * const tenantSettingsWithTenantIdOnly = await prisma.tenantSettings.updateManyAndReturn({
     *   select: { tenantId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantSettings.
     * @param {TenantSettingsUpsertArgs} args - Arguments to update or create a TenantSettings.
     * @example
     * // Update or create a TenantSettings
     * const tenantSettings = await prisma.tenantSettings.upsert({
     *   create: {
     *     // ... data to create a TenantSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantSettings we want to update
     *   }
     * })
     */
    upsert<T extends TenantSettingsUpsertArgs>(args: SelectSubset<T, TenantSettingsUpsertArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsCountArgs} args - Arguments to filter TenantSettings to count.
     * @example
     * // Count the number of TenantSettings
     * const count = await prisma.tenantSettings.count({
     *   where: {
     *     // ... the filter for the TenantSettings we want to count
     *   }
     * })
    **/
    count<T extends TenantSettingsCountArgs>(
      args?: Subset<T, TenantSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantSettingsAggregateArgs>(args: Subset<T, TenantSettingsAggregateArgs>): Prisma.PrismaPromise<GetTenantSettingsAggregateType<T>>

    /**
     * Group by TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantSettingsGroupByArgs['orderBy'] }
        : { orderBy?: TenantSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantSettings model
   */
  readonly fields: TenantSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantSettings model
   */
  interface TenantSettingsFieldRefs {
    readonly tenantId: FieldRef<"TenantSettings", 'String'>
    readonly slug: FieldRef<"TenantSettings", 'String'>
    readonly brandName: FieldRef<"TenantSettings", 'String'>
    readonly introHtml: FieldRef<"TenantSettings", 'String'>
    readonly website: FieldRef<"TenantSettings", 'String'>
    readonly phone: FieldRef<"TenantSettings", 'String'>
    readonly logoUrl: FieldRef<"TenantSettings", 'String'>
    readonly links: FieldRef<"TenantSettings", 'Json'>
    readonly questionnaire: FieldRef<"TenantSettings", 'Json'>
    readonly inbox: FieldRef<"TenantSettings", 'Json'>
    readonly inboxWatchEnabled: FieldRef<"TenantSettings", 'Boolean'>
    readonly inboxLastRun: FieldRef<"TenantSettings", 'DateTime'>
    readonly quoteDefaults: FieldRef<"TenantSettings", 'Json'>
    readonly createdAt: FieldRef<"TenantSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantSettings findUnique
   */
  export type TenantSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings findUniqueOrThrow
   */
  export type TenantSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings findFirst
   */
  export type TenantSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSettings.
     */
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings findFirstOrThrow
   */
  export type TenantSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSettings.
     */
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings findMany
   */
  export type TenantSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings create
   */
  export type TenantSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a TenantSettings.
     */
    data: XOR<TenantSettingsCreateInput, TenantSettingsUncheckedCreateInput>
  }

  /**
   * TenantSettings createMany
   */
  export type TenantSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantSettings.
     */
    data: TenantSettingsCreateManyInput | TenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantSettings createManyAndReturn
   */
  export type TenantSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many TenantSettings.
     */
    data: TenantSettingsCreateManyInput | TenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantSettings update
   */
  export type TenantSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a TenantSettings.
     */
    data: XOR<TenantSettingsUpdateInput, TenantSettingsUncheckedUpdateInput>
    /**
     * Choose, which TenantSettings to update.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings updateMany
   */
  export type TenantSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantSettings.
     */
    data: XOR<TenantSettingsUpdateManyMutationInput, TenantSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TenantSettings to update
     */
    where?: TenantSettingsWhereInput
    /**
     * Limit how many TenantSettings to update.
     */
    limit?: number
  }

  /**
   * TenantSettings updateManyAndReturn
   */
  export type TenantSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * The data used to update TenantSettings.
     */
    data: XOR<TenantSettingsUpdateManyMutationInput, TenantSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TenantSettings to update
     */
    where?: TenantSettingsWhereInput
    /**
     * Limit how many TenantSettings to update.
     */
    limit?: number
  }

  /**
   * TenantSettings upsert
   */
  export type TenantSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the TenantSettings to update in case it exists.
     */
    where: TenantSettingsWhereUniqueInput
    /**
     * In case the TenantSettings found by the `where` argument doesn't exist, create a new TenantSettings with this data.
     */
    create: XOR<TenantSettingsCreateInput, TenantSettingsUncheckedCreateInput>
    /**
     * In case the TenantSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantSettingsUpdateInput, TenantSettingsUncheckedUpdateInput>
  }

  /**
   * TenantSettings delete
   */
  export type TenantSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Filter which TenantSettings to delete.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings deleteMany
   */
  export type TenantSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSettings to delete
     */
    where?: TenantSettingsWhereInput
    /**
     * Limit how many TenantSettings to delete.
     */
    limit?: number
  }

  /**
   * TenantSettings without action
   */
  export type TenantSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
  }


  /**
   * Model FollowUpLog
   */

  export type AggregateFollowUpLog = {
    _count: FollowUpLogCountAggregateOutputType | null
    _avg: FollowUpLogAvgAggregateOutputType | null
    _sum: FollowUpLogSumAggregateOutputType | null
    _min: FollowUpLogMinAggregateOutputType | null
    _max: FollowUpLogMaxAggregateOutputType | null
  }

  export type FollowUpLogAvgAggregateOutputType = {
    delayDays: number | null
  }

  export type FollowUpLogSumAggregateOutputType = {
    delayDays: number | null
  }

  export type FollowUpLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    variant: string | null
    subject: string | null
    body: string | null
    sentAt: Date | null
    opened: boolean | null
    replied: boolean | null
    converted: boolean | null
    delayDays: number | null
    provider: string | null
    messageId: string | null
    threadId: string | null
  }

  export type FollowUpLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    variant: string | null
    subject: string | null
    body: string | null
    sentAt: Date | null
    opened: boolean | null
    replied: boolean | null
    converted: boolean | null
    delayDays: number | null
    provider: string | null
    messageId: string | null
    threadId: string | null
  }

  export type FollowUpLogCountAggregateOutputType = {
    id: number
    tenantId: number
    leadId: number
    variant: number
    subject: number
    body: number
    sentAt: number
    opened: number
    replied: number
    converted: number
    delayDays: number
    provider: number
    messageId: number
    threadId: number
    _all: number
  }


  export type FollowUpLogAvgAggregateInputType = {
    delayDays?: true
  }

  export type FollowUpLogSumAggregateInputType = {
    delayDays?: true
  }

  export type FollowUpLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    variant?: true
    subject?: true
    body?: true
    sentAt?: true
    opened?: true
    replied?: true
    converted?: true
    delayDays?: true
    provider?: true
    messageId?: true
    threadId?: true
  }

  export type FollowUpLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    variant?: true
    subject?: true
    body?: true
    sentAt?: true
    opened?: true
    replied?: true
    converted?: true
    delayDays?: true
    provider?: true
    messageId?: true
    threadId?: true
  }

  export type FollowUpLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    variant?: true
    subject?: true
    body?: true
    sentAt?: true
    opened?: true
    replied?: true
    converted?: true
    delayDays?: true
    provider?: true
    messageId?: true
    threadId?: true
    _all?: true
  }

  export type FollowUpLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUpLog to aggregate.
     */
    where?: FollowUpLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpLogs to fetch.
     */
    orderBy?: FollowUpLogOrderByWithRelationInput | FollowUpLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowUpLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FollowUpLogs
    **/
    _count?: true | FollowUpLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FollowUpLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FollowUpLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowUpLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowUpLogMaxAggregateInputType
  }

  export type GetFollowUpLogAggregateType<T extends FollowUpLogAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowUpLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowUpLog[P]>
      : GetScalarType<T[P], AggregateFollowUpLog[P]>
  }




  export type FollowUpLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpLogWhereInput
    orderBy?: FollowUpLogOrderByWithAggregationInput | FollowUpLogOrderByWithAggregationInput[]
    by: FollowUpLogScalarFieldEnum[] | FollowUpLogScalarFieldEnum
    having?: FollowUpLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowUpLogCountAggregateInputType | true
    _avg?: FollowUpLogAvgAggregateInputType
    _sum?: FollowUpLogSumAggregateInputType
    _min?: FollowUpLogMinAggregateInputType
    _max?: FollowUpLogMaxAggregateInputType
  }

  export type FollowUpLogGroupByOutputType = {
    id: string
    tenantId: string
    leadId: string
    variant: string
    subject: string
    body: string
    sentAt: Date
    opened: boolean | null
    replied: boolean | null
    converted: boolean | null
    delayDays: number | null
    provider: string | null
    messageId: string | null
    threadId: string | null
    _count: FollowUpLogCountAggregateOutputType | null
    _avg: FollowUpLogAvgAggregateOutputType | null
    _sum: FollowUpLogSumAggregateOutputType | null
    _min: FollowUpLogMinAggregateOutputType | null
    _max: FollowUpLogMaxAggregateOutputType | null
  }

  type GetFollowUpLogGroupByPayload<T extends FollowUpLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowUpLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowUpLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowUpLogGroupByOutputType[P]>
            : GetScalarType<T[P], FollowUpLogGroupByOutputType[P]>
        }
      >
    >


  export type FollowUpLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    variant?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    opened?: boolean
    replied?: boolean
    converted?: boolean
    delayDays?: boolean
    provider?: boolean
    messageId?: boolean
    threadId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUpLog"]>

  export type FollowUpLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    variant?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    opened?: boolean
    replied?: boolean
    converted?: boolean
    delayDays?: boolean
    provider?: boolean
    messageId?: boolean
    threadId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUpLog"]>

  export type FollowUpLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    variant?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    opened?: boolean
    replied?: boolean
    converted?: boolean
    delayDays?: boolean
    provider?: boolean
    messageId?: boolean
    threadId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUpLog"]>

  export type FollowUpLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    variant?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    opened?: boolean
    replied?: boolean
    converted?: boolean
    delayDays?: boolean
    provider?: boolean
    messageId?: boolean
    threadId?: boolean
  }

  export type FollowUpLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "leadId" | "variant" | "subject" | "body" | "sentAt" | "opened" | "replied" | "converted" | "delayDays" | "provider" | "messageId" | "threadId", ExtArgs["result"]["followUpLog"]>
  export type FollowUpLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type FollowUpLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type FollowUpLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $FollowUpLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FollowUpLog"
    objects: {
      lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      leadId: string
      variant: string
      subject: string
      body: string
      sentAt: Date
      opened: boolean | null
      replied: boolean | null
      converted: boolean | null
      delayDays: number | null
      provider: string | null
      messageId: string | null
      threadId: string | null
    }, ExtArgs["result"]["followUpLog"]>
    composites: {}
  }

  type FollowUpLogGetPayload<S extends boolean | null | undefined | FollowUpLogDefaultArgs> = $Result.GetResult<Prisma.$FollowUpLogPayload, S>

  type FollowUpLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowUpLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowUpLogCountAggregateInputType | true
    }

  export interface FollowUpLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FollowUpLog'], meta: { name: 'FollowUpLog' } }
    /**
     * Find zero or one FollowUpLog that matches the filter.
     * @param {FollowUpLogFindUniqueArgs} args - Arguments to find a FollowUpLog
     * @example
     * // Get one FollowUpLog
     * const followUpLog = await prisma.followUpLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowUpLogFindUniqueArgs>(args: SelectSubset<T, FollowUpLogFindUniqueArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FollowUpLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowUpLogFindUniqueOrThrowArgs} args - Arguments to find a FollowUpLog
     * @example
     * // Get one FollowUpLog
     * const followUpLog = await prisma.followUpLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowUpLogFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowUpLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUpLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpLogFindFirstArgs} args - Arguments to find a FollowUpLog
     * @example
     * // Get one FollowUpLog
     * const followUpLog = await prisma.followUpLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowUpLogFindFirstArgs>(args?: SelectSubset<T, FollowUpLogFindFirstArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUpLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpLogFindFirstOrThrowArgs} args - Arguments to find a FollowUpLog
     * @example
     * // Get one FollowUpLog
     * const followUpLog = await prisma.followUpLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowUpLogFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowUpLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FollowUpLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowUpLogs
     * const followUpLogs = await prisma.followUpLog.findMany()
     * 
     * // Get first 10 FollowUpLogs
     * const followUpLogs = await prisma.followUpLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followUpLogWithIdOnly = await prisma.followUpLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowUpLogFindManyArgs>(args?: SelectSubset<T, FollowUpLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FollowUpLog.
     * @param {FollowUpLogCreateArgs} args - Arguments to create a FollowUpLog.
     * @example
     * // Create one FollowUpLog
     * const FollowUpLog = await prisma.followUpLog.create({
     *   data: {
     *     // ... data to create a FollowUpLog
     *   }
     * })
     * 
     */
    create<T extends FollowUpLogCreateArgs>(args: SelectSubset<T, FollowUpLogCreateArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FollowUpLogs.
     * @param {FollowUpLogCreateManyArgs} args - Arguments to create many FollowUpLogs.
     * @example
     * // Create many FollowUpLogs
     * const followUpLog = await prisma.followUpLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowUpLogCreateManyArgs>(args?: SelectSubset<T, FollowUpLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FollowUpLogs and returns the data saved in the database.
     * @param {FollowUpLogCreateManyAndReturnArgs} args - Arguments to create many FollowUpLogs.
     * @example
     * // Create many FollowUpLogs
     * const followUpLog = await prisma.followUpLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FollowUpLogs and only return the `id`
     * const followUpLogWithIdOnly = await prisma.followUpLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowUpLogCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowUpLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FollowUpLog.
     * @param {FollowUpLogDeleteArgs} args - Arguments to delete one FollowUpLog.
     * @example
     * // Delete one FollowUpLog
     * const FollowUpLog = await prisma.followUpLog.delete({
     *   where: {
     *     // ... filter to delete one FollowUpLog
     *   }
     * })
     * 
     */
    delete<T extends FollowUpLogDeleteArgs>(args: SelectSubset<T, FollowUpLogDeleteArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FollowUpLog.
     * @param {FollowUpLogUpdateArgs} args - Arguments to update one FollowUpLog.
     * @example
     * // Update one FollowUpLog
     * const followUpLog = await prisma.followUpLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpLogUpdateArgs>(args: SelectSubset<T, FollowUpLogUpdateArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FollowUpLogs.
     * @param {FollowUpLogDeleteManyArgs} args - Arguments to filter FollowUpLogs to delete.
     * @example
     * // Delete a few FollowUpLogs
     * const { count } = await prisma.followUpLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowUpLogDeleteManyArgs>(args?: SelectSubset<T, FollowUpLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUpLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowUpLogs
     * const followUpLog = await prisma.followUpLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpLogUpdateManyArgs>(args: SelectSubset<T, FollowUpLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUpLogs and returns the data updated in the database.
     * @param {FollowUpLogUpdateManyAndReturnArgs} args - Arguments to update many FollowUpLogs.
     * @example
     * // Update many FollowUpLogs
     * const followUpLog = await prisma.followUpLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FollowUpLogs and only return the `id`
     * const followUpLogWithIdOnly = await prisma.followUpLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpLogUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FollowUpLog.
     * @param {FollowUpLogUpsertArgs} args - Arguments to update or create a FollowUpLog.
     * @example
     * // Update or create a FollowUpLog
     * const followUpLog = await prisma.followUpLog.upsert({
     *   create: {
     *     // ... data to create a FollowUpLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowUpLog we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpLogUpsertArgs>(args: SelectSubset<T, FollowUpLogUpsertArgs<ExtArgs>>): Prisma__FollowUpLogClient<$Result.GetResult<Prisma.$FollowUpLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FollowUpLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpLogCountArgs} args - Arguments to filter FollowUpLogs to count.
     * @example
     * // Count the number of FollowUpLogs
     * const count = await prisma.followUpLog.count({
     *   where: {
     *     // ... the filter for the FollowUpLogs we want to count
     *   }
     * })
    **/
    count<T extends FollowUpLogCountArgs>(
      args?: Subset<T, FollowUpLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowUpLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowUpLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowUpLogAggregateArgs>(args: Subset<T, FollowUpLogAggregateArgs>): Prisma.PrismaPromise<GetFollowUpLogAggregateType<T>>

    /**
     * Group by FollowUpLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowUpLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowUpLogGroupByArgs['orderBy'] }
        : { orderBy?: FollowUpLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowUpLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowUpLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FollowUpLog model
   */
  readonly fields: FollowUpLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowUpLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowUpLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FollowUpLog model
   */
  interface FollowUpLogFieldRefs {
    readonly id: FieldRef<"FollowUpLog", 'String'>
    readonly tenantId: FieldRef<"FollowUpLog", 'String'>
    readonly leadId: FieldRef<"FollowUpLog", 'String'>
    readonly variant: FieldRef<"FollowUpLog", 'String'>
    readonly subject: FieldRef<"FollowUpLog", 'String'>
    readonly body: FieldRef<"FollowUpLog", 'String'>
    readonly sentAt: FieldRef<"FollowUpLog", 'DateTime'>
    readonly opened: FieldRef<"FollowUpLog", 'Boolean'>
    readonly replied: FieldRef<"FollowUpLog", 'Boolean'>
    readonly converted: FieldRef<"FollowUpLog", 'Boolean'>
    readonly delayDays: FieldRef<"FollowUpLog", 'Int'>
    readonly provider: FieldRef<"FollowUpLog", 'String'>
    readonly messageId: FieldRef<"FollowUpLog", 'String'>
    readonly threadId: FieldRef<"FollowUpLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FollowUpLog findUnique
   */
  export type FollowUpLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpLog to fetch.
     */
    where: FollowUpLogWhereUniqueInput
  }

  /**
   * FollowUpLog findUniqueOrThrow
   */
  export type FollowUpLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpLog to fetch.
     */
    where: FollowUpLogWhereUniqueInput
  }

  /**
   * FollowUpLog findFirst
   */
  export type FollowUpLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpLog to fetch.
     */
    where?: FollowUpLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpLogs to fetch.
     */
    orderBy?: FollowUpLogOrderByWithRelationInput | FollowUpLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUpLogs.
     */
    cursor?: FollowUpLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUpLogs.
     */
    distinct?: FollowUpLogScalarFieldEnum | FollowUpLogScalarFieldEnum[]
  }

  /**
   * FollowUpLog findFirstOrThrow
   */
  export type FollowUpLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpLog to fetch.
     */
    where?: FollowUpLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpLogs to fetch.
     */
    orderBy?: FollowUpLogOrderByWithRelationInput | FollowUpLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUpLogs.
     */
    cursor?: FollowUpLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUpLogs.
     */
    distinct?: FollowUpLogScalarFieldEnum | FollowUpLogScalarFieldEnum[]
  }

  /**
   * FollowUpLog findMany
   */
  export type FollowUpLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpLogs to fetch.
     */
    where?: FollowUpLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpLogs to fetch.
     */
    orderBy?: FollowUpLogOrderByWithRelationInput | FollowUpLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FollowUpLogs.
     */
    cursor?: FollowUpLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpLogs.
     */
    skip?: number
    distinct?: FollowUpLogScalarFieldEnum | FollowUpLogScalarFieldEnum[]
  }

  /**
   * FollowUpLog create
   */
  export type FollowUpLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * The data needed to create a FollowUpLog.
     */
    data: XOR<FollowUpLogCreateInput, FollowUpLogUncheckedCreateInput>
  }

  /**
   * FollowUpLog createMany
   */
  export type FollowUpLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FollowUpLogs.
     */
    data: FollowUpLogCreateManyInput | FollowUpLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowUpLog createManyAndReturn
   */
  export type FollowUpLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * The data used to create many FollowUpLogs.
     */
    data: FollowUpLogCreateManyInput | FollowUpLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUpLog update
   */
  export type FollowUpLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * The data needed to update a FollowUpLog.
     */
    data: XOR<FollowUpLogUpdateInput, FollowUpLogUncheckedUpdateInput>
    /**
     * Choose, which FollowUpLog to update.
     */
    where: FollowUpLogWhereUniqueInput
  }

  /**
   * FollowUpLog updateMany
   */
  export type FollowUpLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FollowUpLogs.
     */
    data: XOR<FollowUpLogUpdateManyMutationInput, FollowUpLogUncheckedUpdateManyInput>
    /**
     * Filter which FollowUpLogs to update
     */
    where?: FollowUpLogWhereInput
    /**
     * Limit how many FollowUpLogs to update.
     */
    limit?: number
  }

  /**
   * FollowUpLog updateManyAndReturn
   */
  export type FollowUpLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * The data used to update FollowUpLogs.
     */
    data: XOR<FollowUpLogUpdateManyMutationInput, FollowUpLogUncheckedUpdateManyInput>
    /**
     * Filter which FollowUpLogs to update
     */
    where?: FollowUpLogWhereInput
    /**
     * Limit how many FollowUpLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUpLog upsert
   */
  export type FollowUpLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * The filter to search for the FollowUpLog to update in case it exists.
     */
    where: FollowUpLogWhereUniqueInput
    /**
     * In case the FollowUpLog found by the `where` argument doesn't exist, create a new FollowUpLog with this data.
     */
    create: XOR<FollowUpLogCreateInput, FollowUpLogUncheckedCreateInput>
    /**
     * In case the FollowUpLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpLogUpdateInput, FollowUpLogUncheckedUpdateInput>
  }

  /**
   * FollowUpLog delete
   */
  export type FollowUpLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
    /**
     * Filter which FollowUpLog to delete.
     */
    where: FollowUpLogWhereUniqueInput
  }

  /**
   * FollowUpLog deleteMany
   */
  export type FollowUpLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUpLogs to delete
     */
    where?: FollowUpLogWhereInput
    /**
     * Limit how many FollowUpLogs to delete.
     */
    limit?: number
  }

  /**
   * FollowUpLog without action
   */
  export type FollowUpLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpLog
     */
    select?: FollowUpLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpLog
     */
    omit?: FollowUpLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpLogInclude<ExtArgs> | null
  }


  /**
   * Model LeadSourceCost
   */

  export type AggregateLeadSourceCost = {
    _count: LeadSourceCostCountAggregateOutputType | null
    _avg: LeadSourceCostAvgAggregateOutputType | null
    _sum: LeadSourceCostSumAggregateOutputType | null
    _min: LeadSourceCostMinAggregateOutputType | null
    _max: LeadSourceCostMaxAggregateOutputType | null
  }

  export type LeadSourceCostAvgAggregateOutputType = {
    spend: number | null
    leads: number | null
    conversions: number | null
  }

  export type LeadSourceCostSumAggregateOutputType = {
    spend: number | null
    leads: number | null
    conversions: number | null
  }

  export type LeadSourceCostMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    source: string | null
    month: Date | null
    spend: number | null
    leads: number | null
    conversions: number | null
    scalable: boolean | null
  }

  export type LeadSourceCostMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    source: string | null
    month: Date | null
    spend: number | null
    leads: number | null
    conversions: number | null
    scalable: boolean | null
  }

  export type LeadSourceCostCountAggregateOutputType = {
    id: number
    tenantId: number
    source: number
    month: number
    spend: number
    leads: number
    conversions: number
    scalable: number
    _all: number
  }


  export type LeadSourceCostAvgAggregateInputType = {
    spend?: true
    leads?: true
    conversions?: true
  }

  export type LeadSourceCostSumAggregateInputType = {
    spend?: true
    leads?: true
    conversions?: true
  }

  export type LeadSourceCostMinAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    month?: true
    spend?: true
    leads?: true
    conversions?: true
    scalable?: true
  }

  export type LeadSourceCostMaxAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    month?: true
    spend?: true
    leads?: true
    conversions?: true
    scalable?: true
  }

  export type LeadSourceCostCountAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    month?: true
    spend?: true
    leads?: true
    conversions?: true
    scalable?: true
    _all?: true
  }

  export type LeadSourceCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadSourceCost to aggregate.
     */
    where?: LeadSourceCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceCosts to fetch.
     */
    orderBy?: LeadSourceCostOrderByWithRelationInput | LeadSourceCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadSourceCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadSourceCosts
    **/
    _count?: true | LeadSourceCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadSourceCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSourceCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadSourceCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadSourceCostMaxAggregateInputType
  }

  export type GetLeadSourceCostAggregateType<T extends LeadSourceCostAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadSourceCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadSourceCost[P]>
      : GetScalarType<T[P], AggregateLeadSourceCost[P]>
  }




  export type LeadSourceCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadSourceCostWhereInput
    orderBy?: LeadSourceCostOrderByWithAggregationInput | LeadSourceCostOrderByWithAggregationInput[]
    by: LeadSourceCostScalarFieldEnum[] | LeadSourceCostScalarFieldEnum
    having?: LeadSourceCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadSourceCostCountAggregateInputType | true
    _avg?: LeadSourceCostAvgAggregateInputType
    _sum?: LeadSourceCostSumAggregateInputType
    _min?: LeadSourceCostMinAggregateInputType
    _max?: LeadSourceCostMaxAggregateInputType
  }

  export type LeadSourceCostGroupByOutputType = {
    id: string
    tenantId: string
    source: string
    month: Date
    spend: number
    leads: number
    conversions: number
    scalable: boolean
    _count: LeadSourceCostCountAggregateOutputType | null
    _avg: LeadSourceCostAvgAggregateOutputType | null
    _sum: LeadSourceCostSumAggregateOutputType | null
    _min: LeadSourceCostMinAggregateOutputType | null
    _max: LeadSourceCostMaxAggregateOutputType | null
  }

  type GetLeadSourceCostGroupByPayload<T extends LeadSourceCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadSourceCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadSourceCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadSourceCostGroupByOutputType[P]>
            : GetScalarType<T[P], LeadSourceCostGroupByOutputType[P]>
        }
      >
    >


  export type LeadSourceCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    spend?: boolean
    leads?: boolean
    conversions?: boolean
    scalable?: boolean
  }, ExtArgs["result"]["leadSourceCost"]>

  export type LeadSourceCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    spend?: boolean
    leads?: boolean
    conversions?: boolean
    scalable?: boolean
  }, ExtArgs["result"]["leadSourceCost"]>

  export type LeadSourceCostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    spend?: boolean
    leads?: boolean
    conversions?: boolean
    scalable?: boolean
  }, ExtArgs["result"]["leadSourceCost"]>

  export type LeadSourceCostSelectScalar = {
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    spend?: boolean
    leads?: boolean
    conversions?: boolean
    scalable?: boolean
  }

  export type LeadSourceCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "source" | "month" | "spend" | "leads" | "conversions" | "scalable", ExtArgs["result"]["leadSourceCost"]>

  export type $LeadSourceCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadSourceCost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      source: string
      month: Date
      spend: number
      leads: number
      conversions: number
      scalable: boolean
    }, ExtArgs["result"]["leadSourceCost"]>
    composites: {}
  }

  type LeadSourceCostGetPayload<S extends boolean | null | undefined | LeadSourceCostDefaultArgs> = $Result.GetResult<Prisma.$LeadSourceCostPayload, S>

  type LeadSourceCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadSourceCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadSourceCostCountAggregateInputType | true
    }

  export interface LeadSourceCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadSourceCost'], meta: { name: 'LeadSourceCost' } }
    /**
     * Find zero or one LeadSourceCost that matches the filter.
     * @param {LeadSourceCostFindUniqueArgs} args - Arguments to find a LeadSourceCost
     * @example
     * // Get one LeadSourceCost
     * const leadSourceCost = await prisma.leadSourceCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadSourceCostFindUniqueArgs>(args: SelectSubset<T, LeadSourceCostFindUniqueArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadSourceCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadSourceCostFindUniqueOrThrowArgs} args - Arguments to find a LeadSourceCost
     * @example
     * // Get one LeadSourceCost
     * const leadSourceCost = await prisma.leadSourceCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadSourceCostFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadSourceCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadSourceCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceCostFindFirstArgs} args - Arguments to find a LeadSourceCost
     * @example
     * // Get one LeadSourceCost
     * const leadSourceCost = await prisma.leadSourceCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadSourceCostFindFirstArgs>(args?: SelectSubset<T, LeadSourceCostFindFirstArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadSourceCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceCostFindFirstOrThrowArgs} args - Arguments to find a LeadSourceCost
     * @example
     * // Get one LeadSourceCost
     * const leadSourceCost = await prisma.leadSourceCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadSourceCostFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadSourceCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadSourceCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadSourceCosts
     * const leadSourceCosts = await prisma.leadSourceCost.findMany()
     * 
     * // Get first 10 LeadSourceCosts
     * const leadSourceCosts = await prisma.leadSourceCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadSourceCostWithIdOnly = await prisma.leadSourceCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadSourceCostFindManyArgs>(args?: SelectSubset<T, LeadSourceCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadSourceCost.
     * @param {LeadSourceCostCreateArgs} args - Arguments to create a LeadSourceCost.
     * @example
     * // Create one LeadSourceCost
     * const LeadSourceCost = await prisma.leadSourceCost.create({
     *   data: {
     *     // ... data to create a LeadSourceCost
     *   }
     * })
     * 
     */
    create<T extends LeadSourceCostCreateArgs>(args: SelectSubset<T, LeadSourceCostCreateArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadSourceCosts.
     * @param {LeadSourceCostCreateManyArgs} args - Arguments to create many LeadSourceCosts.
     * @example
     * // Create many LeadSourceCosts
     * const leadSourceCost = await prisma.leadSourceCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadSourceCostCreateManyArgs>(args?: SelectSubset<T, LeadSourceCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadSourceCosts and returns the data saved in the database.
     * @param {LeadSourceCostCreateManyAndReturnArgs} args - Arguments to create many LeadSourceCosts.
     * @example
     * // Create many LeadSourceCosts
     * const leadSourceCost = await prisma.leadSourceCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadSourceCosts and only return the `id`
     * const leadSourceCostWithIdOnly = await prisma.leadSourceCost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadSourceCostCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadSourceCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadSourceCost.
     * @param {LeadSourceCostDeleteArgs} args - Arguments to delete one LeadSourceCost.
     * @example
     * // Delete one LeadSourceCost
     * const LeadSourceCost = await prisma.leadSourceCost.delete({
     *   where: {
     *     // ... filter to delete one LeadSourceCost
     *   }
     * })
     * 
     */
    delete<T extends LeadSourceCostDeleteArgs>(args: SelectSubset<T, LeadSourceCostDeleteArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadSourceCost.
     * @param {LeadSourceCostUpdateArgs} args - Arguments to update one LeadSourceCost.
     * @example
     * // Update one LeadSourceCost
     * const leadSourceCost = await prisma.leadSourceCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadSourceCostUpdateArgs>(args: SelectSubset<T, LeadSourceCostUpdateArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadSourceCosts.
     * @param {LeadSourceCostDeleteManyArgs} args - Arguments to filter LeadSourceCosts to delete.
     * @example
     * // Delete a few LeadSourceCosts
     * const { count } = await prisma.leadSourceCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadSourceCostDeleteManyArgs>(args?: SelectSubset<T, LeadSourceCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadSourceCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadSourceCosts
     * const leadSourceCost = await prisma.leadSourceCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadSourceCostUpdateManyArgs>(args: SelectSubset<T, LeadSourceCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadSourceCosts and returns the data updated in the database.
     * @param {LeadSourceCostUpdateManyAndReturnArgs} args - Arguments to update many LeadSourceCosts.
     * @example
     * // Update many LeadSourceCosts
     * const leadSourceCost = await prisma.leadSourceCost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadSourceCosts and only return the `id`
     * const leadSourceCostWithIdOnly = await prisma.leadSourceCost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadSourceCostUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadSourceCostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadSourceCost.
     * @param {LeadSourceCostUpsertArgs} args - Arguments to update or create a LeadSourceCost.
     * @example
     * // Update or create a LeadSourceCost
     * const leadSourceCost = await prisma.leadSourceCost.upsert({
     *   create: {
     *     // ... data to create a LeadSourceCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadSourceCost we want to update
     *   }
     * })
     */
    upsert<T extends LeadSourceCostUpsertArgs>(args: SelectSubset<T, LeadSourceCostUpsertArgs<ExtArgs>>): Prisma__LeadSourceCostClient<$Result.GetResult<Prisma.$LeadSourceCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadSourceCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceCostCountArgs} args - Arguments to filter LeadSourceCosts to count.
     * @example
     * // Count the number of LeadSourceCosts
     * const count = await prisma.leadSourceCost.count({
     *   where: {
     *     // ... the filter for the LeadSourceCosts we want to count
     *   }
     * })
    **/
    count<T extends LeadSourceCostCountArgs>(
      args?: Subset<T, LeadSourceCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadSourceCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadSourceCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadSourceCostAggregateArgs>(args: Subset<T, LeadSourceCostAggregateArgs>): Prisma.PrismaPromise<GetLeadSourceCostAggregateType<T>>

    /**
     * Group by LeadSourceCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadSourceCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadSourceCostGroupByArgs['orderBy'] }
        : { orderBy?: LeadSourceCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadSourceCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadSourceCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadSourceCost model
   */
  readonly fields: LeadSourceCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadSourceCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadSourceCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadSourceCost model
   */
  interface LeadSourceCostFieldRefs {
    readonly id: FieldRef<"LeadSourceCost", 'String'>
    readonly tenantId: FieldRef<"LeadSourceCost", 'String'>
    readonly source: FieldRef<"LeadSourceCost", 'String'>
    readonly month: FieldRef<"LeadSourceCost", 'DateTime'>
    readonly spend: FieldRef<"LeadSourceCost", 'Float'>
    readonly leads: FieldRef<"LeadSourceCost", 'Int'>
    readonly conversions: FieldRef<"LeadSourceCost", 'Int'>
    readonly scalable: FieldRef<"LeadSourceCost", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LeadSourceCost findUnique
   */
  export type LeadSourceCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceCost to fetch.
     */
    where: LeadSourceCostWhereUniqueInput
  }

  /**
   * LeadSourceCost findUniqueOrThrow
   */
  export type LeadSourceCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceCost to fetch.
     */
    where: LeadSourceCostWhereUniqueInput
  }

  /**
   * LeadSourceCost findFirst
   */
  export type LeadSourceCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceCost to fetch.
     */
    where?: LeadSourceCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceCosts to fetch.
     */
    orderBy?: LeadSourceCostOrderByWithRelationInput | LeadSourceCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadSourceCosts.
     */
    cursor?: LeadSourceCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadSourceCosts.
     */
    distinct?: LeadSourceCostScalarFieldEnum | LeadSourceCostScalarFieldEnum[]
  }

  /**
   * LeadSourceCost findFirstOrThrow
   */
  export type LeadSourceCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceCost to fetch.
     */
    where?: LeadSourceCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceCosts to fetch.
     */
    orderBy?: LeadSourceCostOrderByWithRelationInput | LeadSourceCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadSourceCosts.
     */
    cursor?: LeadSourceCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadSourceCosts.
     */
    distinct?: LeadSourceCostScalarFieldEnum | LeadSourceCostScalarFieldEnum[]
  }

  /**
   * LeadSourceCost findMany
   */
  export type LeadSourceCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceCosts to fetch.
     */
    where?: LeadSourceCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceCosts to fetch.
     */
    orderBy?: LeadSourceCostOrderByWithRelationInput | LeadSourceCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadSourceCosts.
     */
    cursor?: LeadSourceCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceCosts.
     */
    skip?: number
    distinct?: LeadSourceCostScalarFieldEnum | LeadSourceCostScalarFieldEnum[]
  }

  /**
   * LeadSourceCost create
   */
  export type LeadSourceCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * The data needed to create a LeadSourceCost.
     */
    data: XOR<LeadSourceCostCreateInput, LeadSourceCostUncheckedCreateInput>
  }

  /**
   * LeadSourceCost createMany
   */
  export type LeadSourceCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadSourceCosts.
     */
    data: LeadSourceCostCreateManyInput | LeadSourceCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadSourceCost createManyAndReturn
   */
  export type LeadSourceCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * The data used to create many LeadSourceCosts.
     */
    data: LeadSourceCostCreateManyInput | LeadSourceCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadSourceCost update
   */
  export type LeadSourceCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * The data needed to update a LeadSourceCost.
     */
    data: XOR<LeadSourceCostUpdateInput, LeadSourceCostUncheckedUpdateInput>
    /**
     * Choose, which LeadSourceCost to update.
     */
    where: LeadSourceCostWhereUniqueInput
  }

  /**
   * LeadSourceCost updateMany
   */
  export type LeadSourceCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadSourceCosts.
     */
    data: XOR<LeadSourceCostUpdateManyMutationInput, LeadSourceCostUncheckedUpdateManyInput>
    /**
     * Filter which LeadSourceCosts to update
     */
    where?: LeadSourceCostWhereInput
    /**
     * Limit how many LeadSourceCosts to update.
     */
    limit?: number
  }

  /**
   * LeadSourceCost updateManyAndReturn
   */
  export type LeadSourceCostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * The data used to update LeadSourceCosts.
     */
    data: XOR<LeadSourceCostUpdateManyMutationInput, LeadSourceCostUncheckedUpdateManyInput>
    /**
     * Filter which LeadSourceCosts to update
     */
    where?: LeadSourceCostWhereInput
    /**
     * Limit how many LeadSourceCosts to update.
     */
    limit?: number
  }

  /**
   * LeadSourceCost upsert
   */
  export type LeadSourceCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * The filter to search for the LeadSourceCost to update in case it exists.
     */
    where: LeadSourceCostWhereUniqueInput
    /**
     * In case the LeadSourceCost found by the `where` argument doesn't exist, create a new LeadSourceCost with this data.
     */
    create: XOR<LeadSourceCostCreateInput, LeadSourceCostUncheckedCreateInput>
    /**
     * In case the LeadSourceCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadSourceCostUpdateInput, LeadSourceCostUncheckedUpdateInput>
  }

  /**
   * LeadSourceCost delete
   */
  export type LeadSourceCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
    /**
     * Filter which LeadSourceCost to delete.
     */
    where: LeadSourceCostWhereUniqueInput
  }

  /**
   * LeadSourceCost deleteMany
   */
  export type LeadSourceCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadSourceCosts to delete
     */
    where?: LeadSourceCostWhereInput
    /**
     * Limit how many LeadSourceCosts to delete.
     */
    limit?: number
  }

  /**
   * LeadSourceCost without action
   */
  export type LeadSourceCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceCost
     */
    select?: LeadSourceCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceCost
     */
    omit?: LeadSourceCostOmit<ExtArgs> | null
  }


  /**
   * Model LeadSourceSpend
   */

  export type AggregateLeadSourceSpend = {
    _count: LeadSourceSpendCountAggregateOutputType | null
    _avg: LeadSourceSpendAvgAggregateOutputType | null
    _sum: LeadSourceSpendSumAggregateOutputType | null
    _min: LeadSourceSpendMinAggregateOutputType | null
    _max: LeadSourceSpendMaxAggregateOutputType | null
  }

  export type LeadSourceSpendAvgAggregateOutputType = {
    amountGBP: Decimal | null
  }

  export type LeadSourceSpendSumAggregateOutputType = {
    amountGBP: Decimal | null
  }

  export type LeadSourceSpendMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    source: string | null
    month: Date | null
    amountGBP: Decimal | null
  }

  export type LeadSourceSpendMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    source: string | null
    month: Date | null
    amountGBP: Decimal | null
  }

  export type LeadSourceSpendCountAggregateOutputType = {
    id: number
    tenantId: number
    source: number
    month: number
    amountGBP: number
    _all: number
  }


  export type LeadSourceSpendAvgAggregateInputType = {
    amountGBP?: true
  }

  export type LeadSourceSpendSumAggregateInputType = {
    amountGBP?: true
  }

  export type LeadSourceSpendMinAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    month?: true
    amountGBP?: true
  }

  export type LeadSourceSpendMaxAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    month?: true
    amountGBP?: true
  }

  export type LeadSourceSpendCountAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    month?: true
    amountGBP?: true
    _all?: true
  }

  export type LeadSourceSpendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadSourceSpend to aggregate.
     */
    where?: LeadSourceSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceSpends to fetch.
     */
    orderBy?: LeadSourceSpendOrderByWithRelationInput | LeadSourceSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadSourceSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceSpends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadSourceSpends
    **/
    _count?: true | LeadSourceSpendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadSourceSpendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSourceSpendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadSourceSpendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadSourceSpendMaxAggregateInputType
  }

  export type GetLeadSourceSpendAggregateType<T extends LeadSourceSpendAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadSourceSpend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadSourceSpend[P]>
      : GetScalarType<T[P], AggregateLeadSourceSpend[P]>
  }




  export type LeadSourceSpendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadSourceSpendWhereInput
    orderBy?: LeadSourceSpendOrderByWithAggregationInput | LeadSourceSpendOrderByWithAggregationInput[]
    by: LeadSourceSpendScalarFieldEnum[] | LeadSourceSpendScalarFieldEnum
    having?: LeadSourceSpendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadSourceSpendCountAggregateInputType | true
    _avg?: LeadSourceSpendAvgAggregateInputType
    _sum?: LeadSourceSpendSumAggregateInputType
    _min?: LeadSourceSpendMinAggregateInputType
    _max?: LeadSourceSpendMaxAggregateInputType
  }

  export type LeadSourceSpendGroupByOutputType = {
    id: string
    tenantId: string
    source: string
    month: Date
    amountGBP: Decimal
    _count: LeadSourceSpendCountAggregateOutputType | null
    _avg: LeadSourceSpendAvgAggregateOutputType | null
    _sum: LeadSourceSpendSumAggregateOutputType | null
    _min: LeadSourceSpendMinAggregateOutputType | null
    _max: LeadSourceSpendMaxAggregateOutputType | null
  }

  type GetLeadSourceSpendGroupByPayload<T extends LeadSourceSpendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadSourceSpendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadSourceSpendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadSourceSpendGroupByOutputType[P]>
            : GetScalarType<T[P], LeadSourceSpendGroupByOutputType[P]>
        }
      >
    >


  export type LeadSourceSpendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    amountGBP?: boolean
  }, ExtArgs["result"]["leadSourceSpend"]>

  export type LeadSourceSpendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    amountGBP?: boolean
  }, ExtArgs["result"]["leadSourceSpend"]>

  export type LeadSourceSpendSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    amountGBP?: boolean
  }, ExtArgs["result"]["leadSourceSpend"]>

  export type LeadSourceSpendSelectScalar = {
    id?: boolean
    tenantId?: boolean
    source?: boolean
    month?: boolean
    amountGBP?: boolean
  }

  export type LeadSourceSpendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "source" | "month" | "amountGBP", ExtArgs["result"]["leadSourceSpend"]>

  export type $LeadSourceSpendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadSourceSpend"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      source: string
      month: Date
      amountGBP: Prisma.Decimal
    }, ExtArgs["result"]["leadSourceSpend"]>
    composites: {}
  }

  type LeadSourceSpendGetPayload<S extends boolean | null | undefined | LeadSourceSpendDefaultArgs> = $Result.GetResult<Prisma.$LeadSourceSpendPayload, S>

  type LeadSourceSpendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadSourceSpendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadSourceSpendCountAggregateInputType | true
    }

  export interface LeadSourceSpendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadSourceSpend'], meta: { name: 'LeadSourceSpend' } }
    /**
     * Find zero or one LeadSourceSpend that matches the filter.
     * @param {LeadSourceSpendFindUniqueArgs} args - Arguments to find a LeadSourceSpend
     * @example
     * // Get one LeadSourceSpend
     * const leadSourceSpend = await prisma.leadSourceSpend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadSourceSpendFindUniqueArgs>(args: SelectSubset<T, LeadSourceSpendFindUniqueArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadSourceSpend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadSourceSpendFindUniqueOrThrowArgs} args - Arguments to find a LeadSourceSpend
     * @example
     * // Get one LeadSourceSpend
     * const leadSourceSpend = await prisma.leadSourceSpend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadSourceSpendFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadSourceSpendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadSourceSpend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceSpendFindFirstArgs} args - Arguments to find a LeadSourceSpend
     * @example
     * // Get one LeadSourceSpend
     * const leadSourceSpend = await prisma.leadSourceSpend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadSourceSpendFindFirstArgs>(args?: SelectSubset<T, LeadSourceSpendFindFirstArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadSourceSpend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceSpendFindFirstOrThrowArgs} args - Arguments to find a LeadSourceSpend
     * @example
     * // Get one LeadSourceSpend
     * const leadSourceSpend = await prisma.leadSourceSpend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadSourceSpendFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadSourceSpendFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadSourceSpends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceSpendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadSourceSpends
     * const leadSourceSpends = await prisma.leadSourceSpend.findMany()
     * 
     * // Get first 10 LeadSourceSpends
     * const leadSourceSpends = await prisma.leadSourceSpend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadSourceSpendWithIdOnly = await prisma.leadSourceSpend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadSourceSpendFindManyArgs>(args?: SelectSubset<T, LeadSourceSpendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadSourceSpend.
     * @param {LeadSourceSpendCreateArgs} args - Arguments to create a LeadSourceSpend.
     * @example
     * // Create one LeadSourceSpend
     * const LeadSourceSpend = await prisma.leadSourceSpend.create({
     *   data: {
     *     // ... data to create a LeadSourceSpend
     *   }
     * })
     * 
     */
    create<T extends LeadSourceSpendCreateArgs>(args: SelectSubset<T, LeadSourceSpendCreateArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadSourceSpends.
     * @param {LeadSourceSpendCreateManyArgs} args - Arguments to create many LeadSourceSpends.
     * @example
     * // Create many LeadSourceSpends
     * const leadSourceSpend = await prisma.leadSourceSpend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadSourceSpendCreateManyArgs>(args?: SelectSubset<T, LeadSourceSpendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadSourceSpends and returns the data saved in the database.
     * @param {LeadSourceSpendCreateManyAndReturnArgs} args - Arguments to create many LeadSourceSpends.
     * @example
     * // Create many LeadSourceSpends
     * const leadSourceSpend = await prisma.leadSourceSpend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadSourceSpends and only return the `id`
     * const leadSourceSpendWithIdOnly = await prisma.leadSourceSpend.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadSourceSpendCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadSourceSpendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadSourceSpend.
     * @param {LeadSourceSpendDeleteArgs} args - Arguments to delete one LeadSourceSpend.
     * @example
     * // Delete one LeadSourceSpend
     * const LeadSourceSpend = await prisma.leadSourceSpend.delete({
     *   where: {
     *     // ... filter to delete one LeadSourceSpend
     *   }
     * })
     * 
     */
    delete<T extends LeadSourceSpendDeleteArgs>(args: SelectSubset<T, LeadSourceSpendDeleteArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadSourceSpend.
     * @param {LeadSourceSpendUpdateArgs} args - Arguments to update one LeadSourceSpend.
     * @example
     * // Update one LeadSourceSpend
     * const leadSourceSpend = await prisma.leadSourceSpend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadSourceSpendUpdateArgs>(args: SelectSubset<T, LeadSourceSpendUpdateArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadSourceSpends.
     * @param {LeadSourceSpendDeleteManyArgs} args - Arguments to filter LeadSourceSpends to delete.
     * @example
     * // Delete a few LeadSourceSpends
     * const { count } = await prisma.leadSourceSpend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadSourceSpendDeleteManyArgs>(args?: SelectSubset<T, LeadSourceSpendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadSourceSpends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceSpendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadSourceSpends
     * const leadSourceSpend = await prisma.leadSourceSpend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadSourceSpendUpdateManyArgs>(args: SelectSubset<T, LeadSourceSpendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadSourceSpends and returns the data updated in the database.
     * @param {LeadSourceSpendUpdateManyAndReturnArgs} args - Arguments to update many LeadSourceSpends.
     * @example
     * // Update many LeadSourceSpends
     * const leadSourceSpend = await prisma.leadSourceSpend.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadSourceSpends and only return the `id`
     * const leadSourceSpendWithIdOnly = await prisma.leadSourceSpend.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadSourceSpendUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadSourceSpendUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadSourceSpend.
     * @param {LeadSourceSpendUpsertArgs} args - Arguments to update or create a LeadSourceSpend.
     * @example
     * // Update or create a LeadSourceSpend
     * const leadSourceSpend = await prisma.leadSourceSpend.upsert({
     *   create: {
     *     // ... data to create a LeadSourceSpend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadSourceSpend we want to update
     *   }
     * })
     */
    upsert<T extends LeadSourceSpendUpsertArgs>(args: SelectSubset<T, LeadSourceSpendUpsertArgs<ExtArgs>>): Prisma__LeadSourceSpendClient<$Result.GetResult<Prisma.$LeadSourceSpendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadSourceSpends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceSpendCountArgs} args - Arguments to filter LeadSourceSpends to count.
     * @example
     * // Count the number of LeadSourceSpends
     * const count = await prisma.leadSourceSpend.count({
     *   where: {
     *     // ... the filter for the LeadSourceSpends we want to count
     *   }
     * })
    **/
    count<T extends LeadSourceSpendCountArgs>(
      args?: Subset<T, LeadSourceSpendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadSourceSpendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadSourceSpend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceSpendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadSourceSpendAggregateArgs>(args: Subset<T, LeadSourceSpendAggregateArgs>): Prisma.PrismaPromise<GetLeadSourceSpendAggregateType<T>>

    /**
     * Group by LeadSourceSpend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceSpendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadSourceSpendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadSourceSpendGroupByArgs['orderBy'] }
        : { orderBy?: LeadSourceSpendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadSourceSpendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadSourceSpendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadSourceSpend model
   */
  readonly fields: LeadSourceSpendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadSourceSpend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadSourceSpendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadSourceSpend model
   */
  interface LeadSourceSpendFieldRefs {
    readonly id: FieldRef<"LeadSourceSpend", 'String'>
    readonly tenantId: FieldRef<"LeadSourceSpend", 'String'>
    readonly source: FieldRef<"LeadSourceSpend", 'String'>
    readonly month: FieldRef<"LeadSourceSpend", 'DateTime'>
    readonly amountGBP: FieldRef<"LeadSourceSpend", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * LeadSourceSpend findUnique
   */
  export type LeadSourceSpendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceSpend to fetch.
     */
    where: LeadSourceSpendWhereUniqueInput
  }

  /**
   * LeadSourceSpend findUniqueOrThrow
   */
  export type LeadSourceSpendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceSpend to fetch.
     */
    where: LeadSourceSpendWhereUniqueInput
  }

  /**
   * LeadSourceSpend findFirst
   */
  export type LeadSourceSpendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceSpend to fetch.
     */
    where?: LeadSourceSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceSpends to fetch.
     */
    orderBy?: LeadSourceSpendOrderByWithRelationInput | LeadSourceSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadSourceSpends.
     */
    cursor?: LeadSourceSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceSpends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadSourceSpends.
     */
    distinct?: LeadSourceSpendScalarFieldEnum | LeadSourceSpendScalarFieldEnum[]
  }

  /**
   * LeadSourceSpend findFirstOrThrow
   */
  export type LeadSourceSpendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceSpend to fetch.
     */
    where?: LeadSourceSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceSpends to fetch.
     */
    orderBy?: LeadSourceSpendOrderByWithRelationInput | LeadSourceSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadSourceSpends.
     */
    cursor?: LeadSourceSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceSpends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadSourceSpends.
     */
    distinct?: LeadSourceSpendScalarFieldEnum | LeadSourceSpendScalarFieldEnum[]
  }

  /**
   * LeadSourceSpend findMany
   */
  export type LeadSourceSpendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceSpends to fetch.
     */
    where?: LeadSourceSpendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceSpends to fetch.
     */
    orderBy?: LeadSourceSpendOrderByWithRelationInput | LeadSourceSpendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadSourceSpends.
     */
    cursor?: LeadSourceSpendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceSpends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceSpends.
     */
    skip?: number
    distinct?: LeadSourceSpendScalarFieldEnum | LeadSourceSpendScalarFieldEnum[]
  }

  /**
   * LeadSourceSpend create
   */
  export type LeadSourceSpendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * The data needed to create a LeadSourceSpend.
     */
    data: XOR<LeadSourceSpendCreateInput, LeadSourceSpendUncheckedCreateInput>
  }

  /**
   * LeadSourceSpend createMany
   */
  export type LeadSourceSpendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadSourceSpends.
     */
    data: LeadSourceSpendCreateManyInput | LeadSourceSpendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadSourceSpend createManyAndReturn
   */
  export type LeadSourceSpendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * The data used to create many LeadSourceSpends.
     */
    data: LeadSourceSpendCreateManyInput | LeadSourceSpendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadSourceSpend update
   */
  export type LeadSourceSpendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * The data needed to update a LeadSourceSpend.
     */
    data: XOR<LeadSourceSpendUpdateInput, LeadSourceSpendUncheckedUpdateInput>
    /**
     * Choose, which LeadSourceSpend to update.
     */
    where: LeadSourceSpendWhereUniqueInput
  }

  /**
   * LeadSourceSpend updateMany
   */
  export type LeadSourceSpendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadSourceSpends.
     */
    data: XOR<LeadSourceSpendUpdateManyMutationInput, LeadSourceSpendUncheckedUpdateManyInput>
    /**
     * Filter which LeadSourceSpends to update
     */
    where?: LeadSourceSpendWhereInput
    /**
     * Limit how many LeadSourceSpends to update.
     */
    limit?: number
  }

  /**
   * LeadSourceSpend updateManyAndReturn
   */
  export type LeadSourceSpendUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * The data used to update LeadSourceSpends.
     */
    data: XOR<LeadSourceSpendUpdateManyMutationInput, LeadSourceSpendUncheckedUpdateManyInput>
    /**
     * Filter which LeadSourceSpends to update
     */
    where?: LeadSourceSpendWhereInput
    /**
     * Limit how many LeadSourceSpends to update.
     */
    limit?: number
  }

  /**
   * LeadSourceSpend upsert
   */
  export type LeadSourceSpendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * The filter to search for the LeadSourceSpend to update in case it exists.
     */
    where: LeadSourceSpendWhereUniqueInput
    /**
     * In case the LeadSourceSpend found by the `where` argument doesn't exist, create a new LeadSourceSpend with this data.
     */
    create: XOR<LeadSourceSpendCreateInput, LeadSourceSpendUncheckedCreateInput>
    /**
     * In case the LeadSourceSpend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadSourceSpendUpdateInput, LeadSourceSpendUncheckedUpdateInput>
  }

  /**
   * LeadSourceSpend delete
   */
  export type LeadSourceSpendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
    /**
     * Filter which LeadSourceSpend to delete.
     */
    where: LeadSourceSpendWhereUniqueInput
  }

  /**
   * LeadSourceSpend deleteMany
   */
  export type LeadSourceSpendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadSourceSpends to delete
     */
    where?: LeadSourceSpendWhereInput
    /**
     * Limit how many LeadSourceSpends to delete.
     */
    limit?: number
  }

  /**
   * LeadSourceSpend without action
   */
  export type LeadSourceSpendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceSpend
     */
    select?: LeadSourceSpendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceSpend
     */
    omit?: LeadSourceSpendOmit<ExtArgs> | null
  }


  /**
   * Model LeadSourceConfig
   */

  export type AggregateLeadSourceConfig = {
    _count: LeadSourceConfigCountAggregateOutputType | null
    _min: LeadSourceConfigMinAggregateOutputType | null
    _max: LeadSourceConfigMaxAggregateOutputType | null
  }

  export type LeadSourceConfigMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    source: string | null
    scalable: boolean | null
  }

  export type LeadSourceConfigMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    source: string | null
    scalable: boolean | null
  }

  export type LeadSourceConfigCountAggregateOutputType = {
    id: number
    tenantId: number
    source: number
    scalable: number
    _all: number
  }


  export type LeadSourceConfigMinAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    scalable?: true
  }

  export type LeadSourceConfigMaxAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    scalable?: true
  }

  export type LeadSourceConfigCountAggregateInputType = {
    id?: true
    tenantId?: true
    source?: true
    scalable?: true
    _all?: true
  }

  export type LeadSourceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadSourceConfig to aggregate.
     */
    where?: LeadSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceConfigs to fetch.
     */
    orderBy?: LeadSourceConfigOrderByWithRelationInput | LeadSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadSourceConfigs
    **/
    _count?: true | LeadSourceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadSourceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadSourceConfigMaxAggregateInputType
  }

  export type GetLeadSourceConfigAggregateType<T extends LeadSourceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadSourceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadSourceConfig[P]>
      : GetScalarType<T[P], AggregateLeadSourceConfig[P]>
  }




  export type LeadSourceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadSourceConfigWhereInput
    orderBy?: LeadSourceConfigOrderByWithAggregationInput | LeadSourceConfigOrderByWithAggregationInput[]
    by: LeadSourceConfigScalarFieldEnum[] | LeadSourceConfigScalarFieldEnum
    having?: LeadSourceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadSourceConfigCountAggregateInputType | true
    _min?: LeadSourceConfigMinAggregateInputType
    _max?: LeadSourceConfigMaxAggregateInputType
  }

  export type LeadSourceConfigGroupByOutputType = {
    id: string
    tenantId: string
    source: string
    scalable: boolean
    _count: LeadSourceConfigCountAggregateOutputType | null
    _min: LeadSourceConfigMinAggregateOutputType | null
    _max: LeadSourceConfigMaxAggregateOutputType | null
  }

  type GetLeadSourceConfigGroupByPayload<T extends LeadSourceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadSourceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadSourceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadSourceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], LeadSourceConfigGroupByOutputType[P]>
        }
      >
    >


  export type LeadSourceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    scalable?: boolean
  }, ExtArgs["result"]["leadSourceConfig"]>

  export type LeadSourceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    scalable?: boolean
  }, ExtArgs["result"]["leadSourceConfig"]>

  export type LeadSourceConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    source?: boolean
    scalable?: boolean
  }, ExtArgs["result"]["leadSourceConfig"]>

  export type LeadSourceConfigSelectScalar = {
    id?: boolean
    tenantId?: boolean
    source?: boolean
    scalable?: boolean
  }

  export type LeadSourceConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "source" | "scalable", ExtArgs["result"]["leadSourceConfig"]>

  export type $LeadSourceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadSourceConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      source: string
      scalable: boolean
    }, ExtArgs["result"]["leadSourceConfig"]>
    composites: {}
  }

  type LeadSourceConfigGetPayload<S extends boolean | null | undefined | LeadSourceConfigDefaultArgs> = $Result.GetResult<Prisma.$LeadSourceConfigPayload, S>

  type LeadSourceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadSourceConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadSourceConfigCountAggregateInputType | true
    }

  export interface LeadSourceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadSourceConfig'], meta: { name: 'LeadSourceConfig' } }
    /**
     * Find zero or one LeadSourceConfig that matches the filter.
     * @param {LeadSourceConfigFindUniqueArgs} args - Arguments to find a LeadSourceConfig
     * @example
     * // Get one LeadSourceConfig
     * const leadSourceConfig = await prisma.leadSourceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadSourceConfigFindUniqueArgs>(args: SelectSubset<T, LeadSourceConfigFindUniqueArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadSourceConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadSourceConfigFindUniqueOrThrowArgs} args - Arguments to find a LeadSourceConfig
     * @example
     * // Get one LeadSourceConfig
     * const leadSourceConfig = await prisma.leadSourceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadSourceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadSourceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadSourceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceConfigFindFirstArgs} args - Arguments to find a LeadSourceConfig
     * @example
     * // Get one LeadSourceConfig
     * const leadSourceConfig = await prisma.leadSourceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadSourceConfigFindFirstArgs>(args?: SelectSubset<T, LeadSourceConfigFindFirstArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadSourceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceConfigFindFirstOrThrowArgs} args - Arguments to find a LeadSourceConfig
     * @example
     * // Get one LeadSourceConfig
     * const leadSourceConfig = await prisma.leadSourceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadSourceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadSourceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadSourceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadSourceConfigs
     * const leadSourceConfigs = await prisma.leadSourceConfig.findMany()
     * 
     * // Get first 10 LeadSourceConfigs
     * const leadSourceConfigs = await prisma.leadSourceConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadSourceConfigWithIdOnly = await prisma.leadSourceConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadSourceConfigFindManyArgs>(args?: SelectSubset<T, LeadSourceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadSourceConfig.
     * @param {LeadSourceConfigCreateArgs} args - Arguments to create a LeadSourceConfig.
     * @example
     * // Create one LeadSourceConfig
     * const LeadSourceConfig = await prisma.leadSourceConfig.create({
     *   data: {
     *     // ... data to create a LeadSourceConfig
     *   }
     * })
     * 
     */
    create<T extends LeadSourceConfigCreateArgs>(args: SelectSubset<T, LeadSourceConfigCreateArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadSourceConfigs.
     * @param {LeadSourceConfigCreateManyArgs} args - Arguments to create many LeadSourceConfigs.
     * @example
     * // Create many LeadSourceConfigs
     * const leadSourceConfig = await prisma.leadSourceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadSourceConfigCreateManyArgs>(args?: SelectSubset<T, LeadSourceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadSourceConfigs and returns the data saved in the database.
     * @param {LeadSourceConfigCreateManyAndReturnArgs} args - Arguments to create many LeadSourceConfigs.
     * @example
     * // Create many LeadSourceConfigs
     * const leadSourceConfig = await prisma.leadSourceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadSourceConfigs and only return the `id`
     * const leadSourceConfigWithIdOnly = await prisma.leadSourceConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadSourceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadSourceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadSourceConfig.
     * @param {LeadSourceConfigDeleteArgs} args - Arguments to delete one LeadSourceConfig.
     * @example
     * // Delete one LeadSourceConfig
     * const LeadSourceConfig = await prisma.leadSourceConfig.delete({
     *   where: {
     *     // ... filter to delete one LeadSourceConfig
     *   }
     * })
     * 
     */
    delete<T extends LeadSourceConfigDeleteArgs>(args: SelectSubset<T, LeadSourceConfigDeleteArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadSourceConfig.
     * @param {LeadSourceConfigUpdateArgs} args - Arguments to update one LeadSourceConfig.
     * @example
     * // Update one LeadSourceConfig
     * const leadSourceConfig = await prisma.leadSourceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadSourceConfigUpdateArgs>(args: SelectSubset<T, LeadSourceConfigUpdateArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadSourceConfigs.
     * @param {LeadSourceConfigDeleteManyArgs} args - Arguments to filter LeadSourceConfigs to delete.
     * @example
     * // Delete a few LeadSourceConfigs
     * const { count } = await prisma.leadSourceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadSourceConfigDeleteManyArgs>(args?: SelectSubset<T, LeadSourceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadSourceConfigs
     * const leadSourceConfig = await prisma.leadSourceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadSourceConfigUpdateManyArgs>(args: SelectSubset<T, LeadSourceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadSourceConfigs and returns the data updated in the database.
     * @param {LeadSourceConfigUpdateManyAndReturnArgs} args - Arguments to update many LeadSourceConfigs.
     * @example
     * // Update many LeadSourceConfigs
     * const leadSourceConfig = await prisma.leadSourceConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadSourceConfigs and only return the `id`
     * const leadSourceConfigWithIdOnly = await prisma.leadSourceConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadSourceConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadSourceConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadSourceConfig.
     * @param {LeadSourceConfigUpsertArgs} args - Arguments to update or create a LeadSourceConfig.
     * @example
     * // Update or create a LeadSourceConfig
     * const leadSourceConfig = await prisma.leadSourceConfig.upsert({
     *   create: {
     *     // ... data to create a LeadSourceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadSourceConfig we want to update
     *   }
     * })
     */
    upsert<T extends LeadSourceConfigUpsertArgs>(args: SelectSubset<T, LeadSourceConfigUpsertArgs<ExtArgs>>): Prisma__LeadSourceConfigClient<$Result.GetResult<Prisma.$LeadSourceConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceConfigCountArgs} args - Arguments to filter LeadSourceConfigs to count.
     * @example
     * // Count the number of LeadSourceConfigs
     * const count = await prisma.leadSourceConfig.count({
     *   where: {
     *     // ... the filter for the LeadSourceConfigs we want to count
     *   }
     * })
    **/
    count<T extends LeadSourceConfigCountArgs>(
      args?: Subset<T, LeadSourceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadSourceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadSourceConfigAggregateArgs>(args: Subset<T, LeadSourceConfigAggregateArgs>): Prisma.PrismaPromise<GetLeadSourceConfigAggregateType<T>>

    /**
     * Group by LeadSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadSourceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadSourceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadSourceConfigGroupByArgs['orderBy'] }
        : { orderBy?: LeadSourceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadSourceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadSourceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadSourceConfig model
   */
  readonly fields: LeadSourceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadSourceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadSourceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadSourceConfig model
   */
  interface LeadSourceConfigFieldRefs {
    readonly id: FieldRef<"LeadSourceConfig", 'String'>
    readonly tenantId: FieldRef<"LeadSourceConfig", 'String'>
    readonly source: FieldRef<"LeadSourceConfig", 'String'>
    readonly scalable: FieldRef<"LeadSourceConfig", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LeadSourceConfig findUnique
   */
  export type LeadSourceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceConfig to fetch.
     */
    where: LeadSourceConfigWhereUniqueInput
  }

  /**
   * LeadSourceConfig findUniqueOrThrow
   */
  export type LeadSourceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceConfig to fetch.
     */
    where: LeadSourceConfigWhereUniqueInput
  }

  /**
   * LeadSourceConfig findFirst
   */
  export type LeadSourceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceConfig to fetch.
     */
    where?: LeadSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceConfigs to fetch.
     */
    orderBy?: LeadSourceConfigOrderByWithRelationInput | LeadSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadSourceConfigs.
     */
    cursor?: LeadSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadSourceConfigs.
     */
    distinct?: LeadSourceConfigScalarFieldEnum | LeadSourceConfigScalarFieldEnum[]
  }

  /**
   * LeadSourceConfig findFirstOrThrow
   */
  export type LeadSourceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceConfig to fetch.
     */
    where?: LeadSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceConfigs to fetch.
     */
    orderBy?: LeadSourceConfigOrderByWithRelationInput | LeadSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadSourceConfigs.
     */
    cursor?: LeadSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadSourceConfigs.
     */
    distinct?: LeadSourceConfigScalarFieldEnum | LeadSourceConfigScalarFieldEnum[]
  }

  /**
   * LeadSourceConfig findMany
   */
  export type LeadSourceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * Filter, which LeadSourceConfigs to fetch.
     */
    where?: LeadSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadSourceConfigs to fetch.
     */
    orderBy?: LeadSourceConfigOrderByWithRelationInput | LeadSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadSourceConfigs.
     */
    cursor?: LeadSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadSourceConfigs.
     */
    skip?: number
    distinct?: LeadSourceConfigScalarFieldEnum | LeadSourceConfigScalarFieldEnum[]
  }

  /**
   * LeadSourceConfig create
   */
  export type LeadSourceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a LeadSourceConfig.
     */
    data: XOR<LeadSourceConfigCreateInput, LeadSourceConfigUncheckedCreateInput>
  }

  /**
   * LeadSourceConfig createMany
   */
  export type LeadSourceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadSourceConfigs.
     */
    data: LeadSourceConfigCreateManyInput | LeadSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadSourceConfig createManyAndReturn
   */
  export type LeadSourceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to create many LeadSourceConfigs.
     */
    data: LeadSourceConfigCreateManyInput | LeadSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadSourceConfig update
   */
  export type LeadSourceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a LeadSourceConfig.
     */
    data: XOR<LeadSourceConfigUpdateInput, LeadSourceConfigUncheckedUpdateInput>
    /**
     * Choose, which LeadSourceConfig to update.
     */
    where: LeadSourceConfigWhereUniqueInput
  }

  /**
   * LeadSourceConfig updateMany
   */
  export type LeadSourceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadSourceConfigs.
     */
    data: XOR<LeadSourceConfigUpdateManyMutationInput, LeadSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which LeadSourceConfigs to update
     */
    where?: LeadSourceConfigWhereInput
    /**
     * Limit how many LeadSourceConfigs to update.
     */
    limit?: number
  }

  /**
   * LeadSourceConfig updateManyAndReturn
   */
  export type LeadSourceConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to update LeadSourceConfigs.
     */
    data: XOR<LeadSourceConfigUpdateManyMutationInput, LeadSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which LeadSourceConfigs to update
     */
    where?: LeadSourceConfigWhereInput
    /**
     * Limit how many LeadSourceConfigs to update.
     */
    limit?: number
  }

  /**
   * LeadSourceConfig upsert
   */
  export type LeadSourceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the LeadSourceConfig to update in case it exists.
     */
    where: LeadSourceConfigWhereUniqueInput
    /**
     * In case the LeadSourceConfig found by the `where` argument doesn't exist, create a new LeadSourceConfig with this data.
     */
    create: XOR<LeadSourceConfigCreateInput, LeadSourceConfigUncheckedCreateInput>
    /**
     * In case the LeadSourceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadSourceConfigUpdateInput, LeadSourceConfigUncheckedUpdateInput>
  }

  /**
   * LeadSourceConfig delete
   */
  export type LeadSourceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
    /**
     * Filter which LeadSourceConfig to delete.
     */
    where: LeadSourceConfigWhereUniqueInput
  }

  /**
   * LeadSourceConfig deleteMany
   */
  export type LeadSourceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadSourceConfigs to delete
     */
    where?: LeadSourceConfigWhereInput
    /**
     * Limit how many LeadSourceConfigs to delete.
     */
    limit?: number
  }

  /**
   * LeadSourceConfig without action
   */
  export type LeadSourceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadSourceConfig
     */
    select?: LeadSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadSourceConfig
     */
    omit?: LeadSourceConfigOmit<ExtArgs> | null
  }


  /**
   * Model FollowupExperiment
   */

  export type AggregateFollowupExperiment = {
    _count: FollowupExperimentCountAggregateOutputType | null
    _min: FollowupExperimentMinAggregateOutputType | null
    _max: FollowupExperimentMaxAggregateOutputType | null
  }

  export type FollowupExperimentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    opportunityId: string | null
    variant: string | null
    source: string | null
    suggestedAt: Date | null
    whenISO: string | null
    subject: string | null
    body: string | null
    sentAt: Date | null
    replied: boolean | null
    outcome: string | null
  }

  export type FollowupExperimentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    opportunityId: string | null
    variant: string | null
    source: string | null
    suggestedAt: Date | null
    whenISO: string | null
    subject: string | null
    body: string | null
    sentAt: Date | null
    replied: boolean | null
    outcome: string | null
  }

  export type FollowupExperimentCountAggregateOutputType = {
    id: number
    tenantId: number
    opportunityId: number
    variant: number
    source: number
    suggestedAt: number
    whenISO: number
    subject: number
    body: number
    sentAt: number
    replied: number
    outcome: number
    _all: number
  }


  export type FollowupExperimentMinAggregateInputType = {
    id?: true
    tenantId?: true
    opportunityId?: true
    variant?: true
    source?: true
    suggestedAt?: true
    whenISO?: true
    subject?: true
    body?: true
    sentAt?: true
    replied?: true
    outcome?: true
  }

  export type FollowupExperimentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    opportunityId?: true
    variant?: true
    source?: true
    suggestedAt?: true
    whenISO?: true
    subject?: true
    body?: true
    sentAt?: true
    replied?: true
    outcome?: true
  }

  export type FollowupExperimentCountAggregateInputType = {
    id?: true
    tenantId?: true
    opportunityId?: true
    variant?: true
    source?: true
    suggestedAt?: true
    whenISO?: true
    subject?: true
    body?: true
    sentAt?: true
    replied?: true
    outcome?: true
    _all?: true
  }

  export type FollowupExperimentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowupExperiment to aggregate.
     */
    where?: FollowupExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowupExperiments to fetch.
     */
    orderBy?: FollowupExperimentOrderByWithRelationInput | FollowupExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowupExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowupExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowupExperiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FollowupExperiments
    **/
    _count?: true | FollowupExperimentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowupExperimentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowupExperimentMaxAggregateInputType
  }

  export type GetFollowupExperimentAggregateType<T extends FollowupExperimentAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowupExperiment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowupExperiment[P]>
      : GetScalarType<T[P], AggregateFollowupExperiment[P]>
  }




  export type FollowupExperimentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowupExperimentWhereInput
    orderBy?: FollowupExperimentOrderByWithAggregationInput | FollowupExperimentOrderByWithAggregationInput[]
    by: FollowupExperimentScalarFieldEnum[] | FollowupExperimentScalarFieldEnum
    having?: FollowupExperimentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowupExperimentCountAggregateInputType | true
    _min?: FollowupExperimentMinAggregateInputType
    _max?: FollowupExperimentMaxAggregateInputType
  }

  export type FollowupExperimentGroupByOutputType = {
    id: string
    tenantId: string
    opportunityId: string
    variant: string
    source: string
    suggestedAt: Date
    whenISO: string
    subject: string
    body: string
    sentAt: Date | null
    replied: boolean | null
    outcome: string | null
    _count: FollowupExperimentCountAggregateOutputType | null
    _min: FollowupExperimentMinAggregateOutputType | null
    _max: FollowupExperimentMaxAggregateOutputType | null
  }

  type GetFollowupExperimentGroupByPayload<T extends FollowupExperimentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowupExperimentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowupExperimentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowupExperimentGroupByOutputType[P]>
            : GetScalarType<T[P], FollowupExperimentGroupByOutputType[P]>
        }
      >
    >


  export type FollowupExperimentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    opportunityId?: boolean
    variant?: boolean
    source?: boolean
    suggestedAt?: boolean
    whenISO?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    replied?: boolean
    outcome?: boolean
  }, ExtArgs["result"]["followupExperiment"]>

  export type FollowupExperimentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    opportunityId?: boolean
    variant?: boolean
    source?: boolean
    suggestedAt?: boolean
    whenISO?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    replied?: boolean
    outcome?: boolean
  }, ExtArgs["result"]["followupExperiment"]>

  export type FollowupExperimentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    opportunityId?: boolean
    variant?: boolean
    source?: boolean
    suggestedAt?: boolean
    whenISO?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    replied?: boolean
    outcome?: boolean
  }, ExtArgs["result"]["followupExperiment"]>

  export type FollowupExperimentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    opportunityId?: boolean
    variant?: boolean
    source?: boolean
    suggestedAt?: boolean
    whenISO?: boolean
    subject?: boolean
    body?: boolean
    sentAt?: boolean
    replied?: boolean
    outcome?: boolean
  }

  export type FollowupExperimentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "opportunityId" | "variant" | "source" | "suggestedAt" | "whenISO" | "subject" | "body" | "sentAt" | "replied" | "outcome", ExtArgs["result"]["followupExperiment"]>

  export type $FollowupExperimentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FollowupExperiment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      opportunityId: string
      variant: string
      source: string
      suggestedAt: Date
      whenISO: string
      subject: string
      body: string
      sentAt: Date | null
      replied: boolean | null
      outcome: string | null
    }, ExtArgs["result"]["followupExperiment"]>
    composites: {}
  }

  type FollowupExperimentGetPayload<S extends boolean | null | undefined | FollowupExperimentDefaultArgs> = $Result.GetResult<Prisma.$FollowupExperimentPayload, S>

  type FollowupExperimentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowupExperimentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowupExperimentCountAggregateInputType | true
    }

  export interface FollowupExperimentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FollowupExperiment'], meta: { name: 'FollowupExperiment' } }
    /**
     * Find zero or one FollowupExperiment that matches the filter.
     * @param {FollowupExperimentFindUniqueArgs} args - Arguments to find a FollowupExperiment
     * @example
     * // Get one FollowupExperiment
     * const followupExperiment = await prisma.followupExperiment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowupExperimentFindUniqueArgs>(args: SelectSubset<T, FollowupExperimentFindUniqueArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FollowupExperiment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowupExperimentFindUniqueOrThrowArgs} args - Arguments to find a FollowupExperiment
     * @example
     * // Get one FollowupExperiment
     * const followupExperiment = await prisma.followupExperiment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowupExperimentFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowupExperimentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowupExperiment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupExperimentFindFirstArgs} args - Arguments to find a FollowupExperiment
     * @example
     * // Get one FollowupExperiment
     * const followupExperiment = await prisma.followupExperiment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowupExperimentFindFirstArgs>(args?: SelectSubset<T, FollowupExperimentFindFirstArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowupExperiment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupExperimentFindFirstOrThrowArgs} args - Arguments to find a FollowupExperiment
     * @example
     * // Get one FollowupExperiment
     * const followupExperiment = await prisma.followupExperiment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowupExperimentFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowupExperimentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FollowupExperiments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupExperimentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowupExperiments
     * const followupExperiments = await prisma.followupExperiment.findMany()
     * 
     * // Get first 10 FollowupExperiments
     * const followupExperiments = await prisma.followupExperiment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followupExperimentWithIdOnly = await prisma.followupExperiment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowupExperimentFindManyArgs>(args?: SelectSubset<T, FollowupExperimentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FollowupExperiment.
     * @param {FollowupExperimentCreateArgs} args - Arguments to create a FollowupExperiment.
     * @example
     * // Create one FollowupExperiment
     * const FollowupExperiment = await prisma.followupExperiment.create({
     *   data: {
     *     // ... data to create a FollowupExperiment
     *   }
     * })
     * 
     */
    create<T extends FollowupExperimentCreateArgs>(args: SelectSubset<T, FollowupExperimentCreateArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FollowupExperiments.
     * @param {FollowupExperimentCreateManyArgs} args - Arguments to create many FollowupExperiments.
     * @example
     * // Create many FollowupExperiments
     * const followupExperiment = await prisma.followupExperiment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowupExperimentCreateManyArgs>(args?: SelectSubset<T, FollowupExperimentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FollowupExperiments and returns the data saved in the database.
     * @param {FollowupExperimentCreateManyAndReturnArgs} args - Arguments to create many FollowupExperiments.
     * @example
     * // Create many FollowupExperiments
     * const followupExperiment = await prisma.followupExperiment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FollowupExperiments and only return the `id`
     * const followupExperimentWithIdOnly = await prisma.followupExperiment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowupExperimentCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowupExperimentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FollowupExperiment.
     * @param {FollowupExperimentDeleteArgs} args - Arguments to delete one FollowupExperiment.
     * @example
     * // Delete one FollowupExperiment
     * const FollowupExperiment = await prisma.followupExperiment.delete({
     *   where: {
     *     // ... filter to delete one FollowupExperiment
     *   }
     * })
     * 
     */
    delete<T extends FollowupExperimentDeleteArgs>(args: SelectSubset<T, FollowupExperimentDeleteArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FollowupExperiment.
     * @param {FollowupExperimentUpdateArgs} args - Arguments to update one FollowupExperiment.
     * @example
     * // Update one FollowupExperiment
     * const followupExperiment = await prisma.followupExperiment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowupExperimentUpdateArgs>(args: SelectSubset<T, FollowupExperimentUpdateArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FollowupExperiments.
     * @param {FollowupExperimentDeleteManyArgs} args - Arguments to filter FollowupExperiments to delete.
     * @example
     * // Delete a few FollowupExperiments
     * const { count } = await prisma.followupExperiment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowupExperimentDeleteManyArgs>(args?: SelectSubset<T, FollowupExperimentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowupExperiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupExperimentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowupExperiments
     * const followupExperiment = await prisma.followupExperiment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowupExperimentUpdateManyArgs>(args: SelectSubset<T, FollowupExperimentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowupExperiments and returns the data updated in the database.
     * @param {FollowupExperimentUpdateManyAndReturnArgs} args - Arguments to update many FollowupExperiments.
     * @example
     * // Update many FollowupExperiments
     * const followupExperiment = await prisma.followupExperiment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FollowupExperiments and only return the `id`
     * const followupExperimentWithIdOnly = await prisma.followupExperiment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowupExperimentUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowupExperimentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FollowupExperiment.
     * @param {FollowupExperimentUpsertArgs} args - Arguments to update or create a FollowupExperiment.
     * @example
     * // Update or create a FollowupExperiment
     * const followupExperiment = await prisma.followupExperiment.upsert({
     *   create: {
     *     // ... data to create a FollowupExperiment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowupExperiment we want to update
     *   }
     * })
     */
    upsert<T extends FollowupExperimentUpsertArgs>(args: SelectSubset<T, FollowupExperimentUpsertArgs<ExtArgs>>): Prisma__FollowupExperimentClient<$Result.GetResult<Prisma.$FollowupExperimentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FollowupExperiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupExperimentCountArgs} args - Arguments to filter FollowupExperiments to count.
     * @example
     * // Count the number of FollowupExperiments
     * const count = await prisma.followupExperiment.count({
     *   where: {
     *     // ... the filter for the FollowupExperiments we want to count
     *   }
     * })
    **/
    count<T extends FollowupExperimentCountArgs>(
      args?: Subset<T, FollowupExperimentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowupExperimentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowupExperiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupExperimentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowupExperimentAggregateArgs>(args: Subset<T, FollowupExperimentAggregateArgs>): Prisma.PrismaPromise<GetFollowupExperimentAggregateType<T>>

    /**
     * Group by FollowupExperiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupExperimentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowupExperimentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowupExperimentGroupByArgs['orderBy'] }
        : { orderBy?: FollowupExperimentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowupExperimentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowupExperimentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FollowupExperiment model
   */
  readonly fields: FollowupExperimentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowupExperiment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowupExperimentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FollowupExperiment model
   */
  interface FollowupExperimentFieldRefs {
    readonly id: FieldRef<"FollowupExperiment", 'String'>
    readonly tenantId: FieldRef<"FollowupExperiment", 'String'>
    readonly opportunityId: FieldRef<"FollowupExperiment", 'String'>
    readonly variant: FieldRef<"FollowupExperiment", 'String'>
    readonly source: FieldRef<"FollowupExperiment", 'String'>
    readonly suggestedAt: FieldRef<"FollowupExperiment", 'DateTime'>
    readonly whenISO: FieldRef<"FollowupExperiment", 'String'>
    readonly subject: FieldRef<"FollowupExperiment", 'String'>
    readonly body: FieldRef<"FollowupExperiment", 'String'>
    readonly sentAt: FieldRef<"FollowupExperiment", 'DateTime'>
    readonly replied: FieldRef<"FollowupExperiment", 'Boolean'>
    readonly outcome: FieldRef<"FollowupExperiment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FollowupExperiment findUnique
   */
  export type FollowupExperimentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * Filter, which FollowupExperiment to fetch.
     */
    where: FollowupExperimentWhereUniqueInput
  }

  /**
   * FollowupExperiment findUniqueOrThrow
   */
  export type FollowupExperimentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * Filter, which FollowupExperiment to fetch.
     */
    where: FollowupExperimentWhereUniqueInput
  }

  /**
   * FollowupExperiment findFirst
   */
  export type FollowupExperimentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * Filter, which FollowupExperiment to fetch.
     */
    where?: FollowupExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowupExperiments to fetch.
     */
    orderBy?: FollowupExperimentOrderByWithRelationInput | FollowupExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowupExperiments.
     */
    cursor?: FollowupExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowupExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowupExperiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowupExperiments.
     */
    distinct?: FollowupExperimentScalarFieldEnum | FollowupExperimentScalarFieldEnum[]
  }

  /**
   * FollowupExperiment findFirstOrThrow
   */
  export type FollowupExperimentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * Filter, which FollowupExperiment to fetch.
     */
    where?: FollowupExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowupExperiments to fetch.
     */
    orderBy?: FollowupExperimentOrderByWithRelationInput | FollowupExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowupExperiments.
     */
    cursor?: FollowupExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowupExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowupExperiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowupExperiments.
     */
    distinct?: FollowupExperimentScalarFieldEnum | FollowupExperimentScalarFieldEnum[]
  }

  /**
   * FollowupExperiment findMany
   */
  export type FollowupExperimentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * Filter, which FollowupExperiments to fetch.
     */
    where?: FollowupExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowupExperiments to fetch.
     */
    orderBy?: FollowupExperimentOrderByWithRelationInput | FollowupExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FollowupExperiments.
     */
    cursor?: FollowupExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowupExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowupExperiments.
     */
    skip?: number
    distinct?: FollowupExperimentScalarFieldEnum | FollowupExperimentScalarFieldEnum[]
  }

  /**
   * FollowupExperiment create
   */
  export type FollowupExperimentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * The data needed to create a FollowupExperiment.
     */
    data: XOR<FollowupExperimentCreateInput, FollowupExperimentUncheckedCreateInput>
  }

  /**
   * FollowupExperiment createMany
   */
  export type FollowupExperimentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FollowupExperiments.
     */
    data: FollowupExperimentCreateManyInput | FollowupExperimentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowupExperiment createManyAndReturn
   */
  export type FollowupExperimentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * The data used to create many FollowupExperiments.
     */
    data: FollowupExperimentCreateManyInput | FollowupExperimentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowupExperiment update
   */
  export type FollowupExperimentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * The data needed to update a FollowupExperiment.
     */
    data: XOR<FollowupExperimentUpdateInput, FollowupExperimentUncheckedUpdateInput>
    /**
     * Choose, which FollowupExperiment to update.
     */
    where: FollowupExperimentWhereUniqueInput
  }

  /**
   * FollowupExperiment updateMany
   */
  export type FollowupExperimentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FollowupExperiments.
     */
    data: XOR<FollowupExperimentUpdateManyMutationInput, FollowupExperimentUncheckedUpdateManyInput>
    /**
     * Filter which FollowupExperiments to update
     */
    where?: FollowupExperimentWhereInput
    /**
     * Limit how many FollowupExperiments to update.
     */
    limit?: number
  }

  /**
   * FollowupExperiment updateManyAndReturn
   */
  export type FollowupExperimentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * The data used to update FollowupExperiments.
     */
    data: XOR<FollowupExperimentUpdateManyMutationInput, FollowupExperimentUncheckedUpdateManyInput>
    /**
     * Filter which FollowupExperiments to update
     */
    where?: FollowupExperimentWhereInput
    /**
     * Limit how many FollowupExperiments to update.
     */
    limit?: number
  }

  /**
   * FollowupExperiment upsert
   */
  export type FollowupExperimentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * The filter to search for the FollowupExperiment to update in case it exists.
     */
    where: FollowupExperimentWhereUniqueInput
    /**
     * In case the FollowupExperiment found by the `where` argument doesn't exist, create a new FollowupExperiment with this data.
     */
    create: XOR<FollowupExperimentCreateInput, FollowupExperimentUncheckedCreateInput>
    /**
     * In case the FollowupExperiment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowupExperimentUpdateInput, FollowupExperimentUncheckedUpdateInput>
  }

  /**
   * FollowupExperiment delete
   */
  export type FollowupExperimentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
    /**
     * Filter which FollowupExperiment to delete.
     */
    where: FollowupExperimentWhereUniqueInput
  }

  /**
   * FollowupExperiment deleteMany
   */
  export type FollowupExperimentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowupExperiments to delete
     */
    where?: FollowupExperimentWhereInput
    /**
     * Limit how many FollowupExperiments to delete.
     */
    limit?: number
  }

  /**
   * FollowupExperiment without action
   */
  export type FollowupExperimentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowupExperiment
     */
    select?: FollowupExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowupExperiment
     */
    omit?: FollowupExperimentOmit<ExtArgs> | null
  }


  /**
   * Model EmailThread
   */

  export type AggregateEmailThread = {
    _count: EmailThreadCountAggregateOutputType | null
    _min: EmailThreadMinAggregateOutputType | null
    _max: EmailThreadMaxAggregateOutputType | null
  }

  export type EmailThreadMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    threadId: string | null
    subject: string | null
    leadId: string | null
    opportunityId: string | null
    lastInboundAt: Date | null
    lastOutboundAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailThreadMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    threadId: string | null
    subject: string | null
    leadId: string | null
    opportunityId: string | null
    lastInboundAt: Date | null
    lastOutboundAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailThreadCountAggregateOutputType = {
    id: number
    tenantId: number
    provider: number
    threadId: number
    subject: number
    leadId: number
    opportunityId: number
    lastInboundAt: number
    lastOutboundAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailThreadMinAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    threadId?: true
    subject?: true
    leadId?: true
    opportunityId?: true
    lastInboundAt?: true
    lastOutboundAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailThreadMaxAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    threadId?: true
    subject?: true
    leadId?: true
    opportunityId?: true
    lastInboundAt?: true
    lastOutboundAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailThreadCountAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    threadId?: true
    subject?: true
    leadId?: true
    opportunityId?: true
    lastInboundAt?: true
    lastOutboundAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailThread to aggregate.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailThreads
    **/
    _count?: true | EmailThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailThreadMaxAggregateInputType
  }

  export type GetEmailThreadAggregateType<T extends EmailThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailThread[P]>
      : GetScalarType<T[P], AggregateEmailThread[P]>
  }




  export type EmailThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithAggregationInput | EmailThreadOrderByWithAggregationInput[]
    by: EmailThreadScalarFieldEnum[] | EmailThreadScalarFieldEnum
    having?: EmailThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailThreadCountAggregateInputType | true
    _min?: EmailThreadMinAggregateInputType
    _max?: EmailThreadMaxAggregateInputType
  }

  export type EmailThreadGroupByOutputType = {
    id: string
    tenantId: string
    provider: string
    threadId: string
    subject: string | null
    leadId: string | null
    opportunityId: string | null
    lastInboundAt: Date | null
    lastOutboundAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmailThreadCountAggregateOutputType | null
    _min: EmailThreadMinAggregateOutputType | null
    _max: EmailThreadMaxAggregateOutputType | null
  }

  type GetEmailThreadGroupByPayload<T extends EmailThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailThreadGroupByOutputType[P]>
            : GetScalarType<T[P], EmailThreadGroupByOutputType[P]>
        }
      >
    >


  export type EmailThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    threadId?: boolean
    subject?: boolean
    leadId?: boolean
    opportunityId?: boolean
    lastInboundAt?: boolean
    lastOutboundAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailThread$leadArgs<ExtArgs>
    opportunity?: boolean | EmailThread$opportunityArgs<ExtArgs>
    messages?: boolean | EmailThread$messagesArgs<ExtArgs>
    _count?: boolean | EmailThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailThread"]>

  export type EmailThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    threadId?: boolean
    subject?: boolean
    leadId?: boolean
    opportunityId?: boolean
    lastInboundAt?: boolean
    lastOutboundAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailThread$leadArgs<ExtArgs>
    opportunity?: boolean | EmailThread$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["emailThread"]>

  export type EmailThreadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    threadId?: boolean
    subject?: boolean
    leadId?: boolean
    opportunityId?: boolean
    lastInboundAt?: boolean
    lastOutboundAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailThread$leadArgs<ExtArgs>
    opportunity?: boolean | EmailThread$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["emailThread"]>

  export type EmailThreadSelectScalar = {
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    threadId?: boolean
    subject?: boolean
    leadId?: boolean
    opportunityId?: boolean
    lastInboundAt?: boolean
    lastOutboundAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailThreadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "provider" | "threadId" | "subject" | "leadId" | "opportunityId" | "lastInboundAt" | "lastOutboundAt" | "createdAt" | "updatedAt", ExtArgs["result"]["emailThread"]>
  export type EmailThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailThread$leadArgs<ExtArgs>
    opportunity?: boolean | EmailThread$opportunityArgs<ExtArgs>
    messages?: boolean | EmailThread$messagesArgs<ExtArgs>
    _count?: boolean | EmailThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailThread$leadArgs<ExtArgs>
    opportunity?: boolean | EmailThread$opportunityArgs<ExtArgs>
  }
  export type EmailThreadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | EmailThread$leadArgs<ExtArgs>
    opportunity?: boolean | EmailThread$opportunityArgs<ExtArgs>
  }

  export type $EmailThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailThread"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      messages: Prisma.$EmailMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      provider: string
      threadId: string
      subject: string | null
      leadId: string | null
      opportunityId: string | null
      lastInboundAt: Date | null
      lastOutboundAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailThread"]>
    composites: {}
  }

  type EmailThreadGetPayload<S extends boolean | null | undefined | EmailThreadDefaultArgs> = $Result.GetResult<Prisma.$EmailThreadPayload, S>

  type EmailThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailThreadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailThreadCountAggregateInputType | true
    }

  export interface EmailThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailThread'], meta: { name: 'EmailThread' } }
    /**
     * Find zero or one EmailThread that matches the filter.
     * @param {EmailThreadFindUniqueArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailThreadFindUniqueArgs>(args: SelectSubset<T, EmailThreadFindUniqueArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailThread that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailThreadFindUniqueOrThrowArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindFirstArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailThreadFindFirstArgs>(args?: SelectSubset<T, EmailThreadFindFirstArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindFirstOrThrowArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailThreads
     * const emailThreads = await prisma.emailThread.findMany()
     * 
     * // Get first 10 EmailThreads
     * const emailThreads = await prisma.emailThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailThreadWithIdOnly = await prisma.emailThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailThreadFindManyArgs>(args?: SelectSubset<T, EmailThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailThread.
     * @param {EmailThreadCreateArgs} args - Arguments to create a EmailThread.
     * @example
     * // Create one EmailThread
     * const EmailThread = await prisma.emailThread.create({
     *   data: {
     *     // ... data to create a EmailThread
     *   }
     * })
     * 
     */
    create<T extends EmailThreadCreateArgs>(args: SelectSubset<T, EmailThreadCreateArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailThreads.
     * @param {EmailThreadCreateManyArgs} args - Arguments to create many EmailThreads.
     * @example
     * // Create many EmailThreads
     * const emailThread = await prisma.emailThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailThreadCreateManyArgs>(args?: SelectSubset<T, EmailThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailThreads and returns the data saved in the database.
     * @param {EmailThreadCreateManyAndReturnArgs} args - Arguments to create many EmailThreads.
     * @example
     * // Create many EmailThreads
     * const emailThread = await prisma.emailThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailThreads and only return the `id`
     * const emailThreadWithIdOnly = await prisma.emailThread.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailThread.
     * @param {EmailThreadDeleteArgs} args - Arguments to delete one EmailThread.
     * @example
     * // Delete one EmailThread
     * const EmailThread = await prisma.emailThread.delete({
     *   where: {
     *     // ... filter to delete one EmailThread
     *   }
     * })
     * 
     */
    delete<T extends EmailThreadDeleteArgs>(args: SelectSubset<T, EmailThreadDeleteArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailThread.
     * @param {EmailThreadUpdateArgs} args - Arguments to update one EmailThread.
     * @example
     * // Update one EmailThread
     * const emailThread = await prisma.emailThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailThreadUpdateArgs>(args: SelectSubset<T, EmailThreadUpdateArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailThreads.
     * @param {EmailThreadDeleteManyArgs} args - Arguments to filter EmailThreads to delete.
     * @example
     * // Delete a few EmailThreads
     * const { count } = await prisma.emailThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailThreadDeleteManyArgs>(args?: SelectSubset<T, EmailThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailThreads
     * const emailThread = await prisma.emailThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailThreadUpdateManyArgs>(args: SelectSubset<T, EmailThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailThreads and returns the data updated in the database.
     * @param {EmailThreadUpdateManyAndReturnArgs} args - Arguments to update many EmailThreads.
     * @example
     * // Update many EmailThreads
     * const emailThread = await prisma.emailThread.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailThreads and only return the `id`
     * const emailThreadWithIdOnly = await prisma.emailThread.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailThreadUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailThreadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailThread.
     * @param {EmailThreadUpsertArgs} args - Arguments to update or create a EmailThread.
     * @example
     * // Update or create a EmailThread
     * const emailThread = await prisma.emailThread.upsert({
     *   create: {
     *     // ... data to create a EmailThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailThread we want to update
     *   }
     * })
     */
    upsert<T extends EmailThreadUpsertArgs>(args: SelectSubset<T, EmailThreadUpsertArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadCountArgs} args - Arguments to filter EmailThreads to count.
     * @example
     * // Count the number of EmailThreads
     * const count = await prisma.emailThread.count({
     *   where: {
     *     // ... the filter for the EmailThreads we want to count
     *   }
     * })
    **/
    count<T extends EmailThreadCountArgs>(
      args?: Subset<T, EmailThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailThreadAggregateArgs>(args: Subset<T, EmailThreadAggregateArgs>): Prisma.PrismaPromise<GetEmailThreadAggregateType<T>>

    /**
     * Group by EmailThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailThreadGroupByArgs['orderBy'] }
        : { orderBy?: EmailThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailThread model
   */
  readonly fields: EmailThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends EmailThread$leadArgs<ExtArgs> = {}>(args?: Subset<T, EmailThread$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    opportunity<T extends EmailThread$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, EmailThread$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends EmailThread$messagesArgs<ExtArgs> = {}>(args?: Subset<T, EmailThread$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailThread model
   */
  interface EmailThreadFieldRefs {
    readonly id: FieldRef<"EmailThread", 'String'>
    readonly tenantId: FieldRef<"EmailThread", 'String'>
    readonly provider: FieldRef<"EmailThread", 'String'>
    readonly threadId: FieldRef<"EmailThread", 'String'>
    readonly subject: FieldRef<"EmailThread", 'String'>
    readonly leadId: FieldRef<"EmailThread", 'String'>
    readonly opportunityId: FieldRef<"EmailThread", 'String'>
    readonly lastInboundAt: FieldRef<"EmailThread", 'DateTime'>
    readonly lastOutboundAt: FieldRef<"EmailThread", 'DateTime'>
    readonly createdAt: FieldRef<"EmailThread", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailThread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailThread findUnique
   */
  export type EmailThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread findUniqueOrThrow
   */
  export type EmailThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread findFirst
   */
  export type EmailThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailThreads.
     */
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * EmailThread findFirstOrThrow
   */
  export type EmailThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailThreads.
     */
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * EmailThread findMany
   */
  export type EmailThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThreads to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * EmailThread create
   */
  export type EmailThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailThread.
     */
    data: XOR<EmailThreadCreateInput, EmailThreadUncheckedCreateInput>
  }

  /**
   * EmailThread createMany
   */
  export type EmailThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailThreads.
     */
    data: EmailThreadCreateManyInput | EmailThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailThread createManyAndReturn
   */
  export type EmailThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * The data used to create many EmailThreads.
     */
    data: EmailThreadCreateManyInput | EmailThreadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailThread update
   */
  export type EmailThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailThread.
     */
    data: XOR<EmailThreadUpdateInput, EmailThreadUncheckedUpdateInput>
    /**
     * Choose, which EmailThread to update.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread updateMany
   */
  export type EmailThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailThreads.
     */
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyInput>
    /**
     * Filter which EmailThreads to update
     */
    where?: EmailThreadWhereInput
    /**
     * Limit how many EmailThreads to update.
     */
    limit?: number
  }

  /**
   * EmailThread updateManyAndReturn
   */
  export type EmailThreadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * The data used to update EmailThreads.
     */
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyInput>
    /**
     * Filter which EmailThreads to update
     */
    where?: EmailThreadWhereInput
    /**
     * Limit how many EmailThreads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailThread upsert
   */
  export type EmailThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailThread to update in case it exists.
     */
    where: EmailThreadWhereUniqueInput
    /**
     * In case the EmailThread found by the `where` argument doesn't exist, create a new EmailThread with this data.
     */
    create: XOR<EmailThreadCreateInput, EmailThreadUncheckedCreateInput>
    /**
     * In case the EmailThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailThreadUpdateInput, EmailThreadUncheckedUpdateInput>
  }

  /**
   * EmailThread delete
   */
  export type EmailThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter which EmailThread to delete.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread deleteMany
   */
  export type EmailThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailThreads to delete
     */
    where?: EmailThreadWhereInput
    /**
     * Limit how many EmailThreads to delete.
     */
    limit?: number
  }

  /**
   * EmailThread.lead
   */
  export type EmailThread$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * EmailThread.opportunity
   */
  export type EmailThread$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * EmailThread.messages
   */
  export type EmailThread$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailThread without action
   */
  export type EmailThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
  }


  /**
   * Model EmailMessage
   */

  export type AggregateEmailMessage = {
    _count: EmailMessageCountAggregateOutputType | null
    _min: EmailMessageMinAggregateOutputType | null
    _max: EmailMessageMaxAggregateOutputType | null
  }

  export type EmailMessageMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    threadId: string | null
    provider: string | null
    messageId: string | null
    fromEmail: string | null
    toEmail: string | null
    cc: string | null
    bcc: string | null
    subject: string | null
    snippet: string | null
    bodyText: string | null
    bodyHtml: string | null
    direction: string | null
    sentAt: Date | null
    createdAt: Date | null
    leadId: string | null
    opportunityId: string | null
  }

  export type EmailMessageMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    threadId: string | null
    provider: string | null
    messageId: string | null
    fromEmail: string | null
    toEmail: string | null
    cc: string | null
    bcc: string | null
    subject: string | null
    snippet: string | null
    bodyText: string | null
    bodyHtml: string | null
    direction: string | null
    sentAt: Date | null
    createdAt: Date | null
    leadId: string | null
    opportunityId: string | null
  }

  export type EmailMessageCountAggregateOutputType = {
    id: number
    tenantId: number
    threadId: number
    provider: number
    messageId: number
    fromEmail: number
    toEmail: number
    cc: number
    bcc: number
    subject: number
    snippet: number
    bodyText: number
    bodyHtml: number
    direction: number
    sentAt: number
    createdAt: number
    leadId: number
    opportunityId: number
    _all: number
  }


  export type EmailMessageMinAggregateInputType = {
    id?: true
    tenantId?: true
    threadId?: true
    provider?: true
    messageId?: true
    fromEmail?: true
    toEmail?: true
    cc?: true
    bcc?: true
    subject?: true
    snippet?: true
    bodyText?: true
    bodyHtml?: true
    direction?: true
    sentAt?: true
    createdAt?: true
    leadId?: true
    opportunityId?: true
  }

  export type EmailMessageMaxAggregateInputType = {
    id?: true
    tenantId?: true
    threadId?: true
    provider?: true
    messageId?: true
    fromEmail?: true
    toEmail?: true
    cc?: true
    bcc?: true
    subject?: true
    snippet?: true
    bodyText?: true
    bodyHtml?: true
    direction?: true
    sentAt?: true
    createdAt?: true
    leadId?: true
    opportunityId?: true
  }

  export type EmailMessageCountAggregateInputType = {
    id?: true
    tenantId?: true
    threadId?: true
    provider?: true
    messageId?: true
    fromEmail?: true
    toEmail?: true
    cc?: true
    bcc?: true
    subject?: true
    snippet?: true
    bodyText?: true
    bodyHtml?: true
    direction?: true
    sentAt?: true
    createdAt?: true
    leadId?: true
    opportunityId?: true
    _all?: true
  }

  export type EmailMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailMessage to aggregate.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailMessages
    **/
    _count?: true | EmailMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMessageMaxAggregateInputType
  }

  export type GetEmailMessageAggregateType<T extends EmailMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailMessage[P]>
      : GetScalarType<T[P], AggregateEmailMessage[P]>
  }




  export type EmailMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithAggregationInput | EmailMessageOrderByWithAggregationInput[]
    by: EmailMessageScalarFieldEnum[] | EmailMessageScalarFieldEnum
    having?: EmailMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailMessageCountAggregateInputType | true
    _min?: EmailMessageMinAggregateInputType
    _max?: EmailMessageMaxAggregateInputType
  }

  export type EmailMessageGroupByOutputType = {
    id: string
    tenantId: string
    threadId: string
    provider: string
    messageId: string
    fromEmail: string | null
    toEmail: string | null
    cc: string | null
    bcc: string | null
    subject: string | null
    snippet: string | null
    bodyText: string | null
    bodyHtml: string | null
    direction: string
    sentAt: Date
    createdAt: Date
    leadId: string | null
    opportunityId: string | null
    _count: EmailMessageCountAggregateOutputType | null
    _min: EmailMessageMinAggregateOutputType | null
    _max: EmailMessageMaxAggregateOutputType | null
  }

  type GetEmailMessageGroupByPayload<T extends EmailMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailMessageGroupByOutputType[P]>
            : GetScalarType<T[P], EmailMessageGroupByOutputType[P]>
        }
      >
    >


  export type EmailMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    threadId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    cc?: boolean
    bcc?: boolean
    subject?: boolean
    snippet?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    direction?: boolean
    sentAt?: boolean
    createdAt?: boolean
    leadId?: boolean
    opportunityId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    thread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    lead?: boolean | EmailMessage$leadArgs<ExtArgs>
    opportunity?: boolean | EmailMessage$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["emailMessage"]>

  export type EmailMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    threadId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    cc?: boolean
    bcc?: boolean
    subject?: boolean
    snippet?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    direction?: boolean
    sentAt?: boolean
    createdAt?: boolean
    leadId?: boolean
    opportunityId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    thread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    lead?: boolean | EmailMessage$leadArgs<ExtArgs>
    opportunity?: boolean | EmailMessage$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["emailMessage"]>

  export type EmailMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    threadId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    cc?: boolean
    bcc?: boolean
    subject?: boolean
    snippet?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    direction?: boolean
    sentAt?: boolean
    createdAt?: boolean
    leadId?: boolean
    opportunityId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    thread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    lead?: boolean | EmailMessage$leadArgs<ExtArgs>
    opportunity?: boolean | EmailMessage$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["emailMessage"]>

  export type EmailMessageSelectScalar = {
    id?: boolean
    tenantId?: boolean
    threadId?: boolean
    provider?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    cc?: boolean
    bcc?: boolean
    subject?: boolean
    snippet?: boolean
    bodyText?: boolean
    bodyHtml?: boolean
    direction?: boolean
    sentAt?: boolean
    createdAt?: boolean
    leadId?: boolean
    opportunityId?: boolean
  }

  export type EmailMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "threadId" | "provider" | "messageId" | "fromEmail" | "toEmail" | "cc" | "bcc" | "subject" | "snippet" | "bodyText" | "bodyHtml" | "direction" | "sentAt" | "createdAt" | "leadId" | "opportunityId", ExtArgs["result"]["emailMessage"]>
  export type EmailMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    thread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    lead?: boolean | EmailMessage$leadArgs<ExtArgs>
    opportunity?: boolean | EmailMessage$opportunityArgs<ExtArgs>
  }
  export type EmailMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    thread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    lead?: boolean | EmailMessage$leadArgs<ExtArgs>
    opportunity?: boolean | EmailMessage$opportunityArgs<ExtArgs>
  }
  export type EmailMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    thread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    lead?: boolean | EmailMessage$leadArgs<ExtArgs>
    opportunity?: boolean | EmailMessage$opportunityArgs<ExtArgs>
  }

  export type $EmailMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailMessage"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      thread: Prisma.$EmailThreadPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      threadId: string
      provider: string
      messageId: string
      fromEmail: string | null
      toEmail: string | null
      cc: string | null
      bcc: string | null
      subject: string | null
      snippet: string | null
      bodyText: string | null
      bodyHtml: string | null
      direction: string
      sentAt: Date
      createdAt: Date
      leadId: string | null
      opportunityId: string | null
    }, ExtArgs["result"]["emailMessage"]>
    composites: {}
  }

  type EmailMessageGetPayload<S extends boolean | null | undefined | EmailMessageDefaultArgs> = $Result.GetResult<Prisma.$EmailMessagePayload, S>

  type EmailMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailMessageCountAggregateInputType | true
    }

  export interface EmailMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailMessage'], meta: { name: 'EmailMessage' } }
    /**
     * Find zero or one EmailMessage that matches the filter.
     * @param {EmailMessageFindUniqueArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailMessageFindUniqueArgs>(args: SelectSubset<T, EmailMessageFindUniqueArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailMessageFindUniqueOrThrowArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindFirstArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailMessageFindFirstArgs>(args?: SelectSubset<T, EmailMessageFindFirstArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindFirstOrThrowArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailMessages
     * const emailMessages = await prisma.emailMessage.findMany()
     * 
     * // Get first 10 EmailMessages
     * const emailMessages = await prisma.emailMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailMessageWithIdOnly = await prisma.emailMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailMessageFindManyArgs>(args?: SelectSubset<T, EmailMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailMessage.
     * @param {EmailMessageCreateArgs} args - Arguments to create a EmailMessage.
     * @example
     * // Create one EmailMessage
     * const EmailMessage = await prisma.emailMessage.create({
     *   data: {
     *     // ... data to create a EmailMessage
     *   }
     * })
     * 
     */
    create<T extends EmailMessageCreateArgs>(args: SelectSubset<T, EmailMessageCreateArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailMessages.
     * @param {EmailMessageCreateManyArgs} args - Arguments to create many EmailMessages.
     * @example
     * // Create many EmailMessages
     * const emailMessage = await prisma.emailMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailMessageCreateManyArgs>(args?: SelectSubset<T, EmailMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailMessages and returns the data saved in the database.
     * @param {EmailMessageCreateManyAndReturnArgs} args - Arguments to create many EmailMessages.
     * @example
     * // Create many EmailMessages
     * const emailMessage = await prisma.emailMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailMessages and only return the `id`
     * const emailMessageWithIdOnly = await prisma.emailMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailMessage.
     * @param {EmailMessageDeleteArgs} args - Arguments to delete one EmailMessage.
     * @example
     * // Delete one EmailMessage
     * const EmailMessage = await prisma.emailMessage.delete({
     *   where: {
     *     // ... filter to delete one EmailMessage
     *   }
     * })
     * 
     */
    delete<T extends EmailMessageDeleteArgs>(args: SelectSubset<T, EmailMessageDeleteArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailMessage.
     * @param {EmailMessageUpdateArgs} args - Arguments to update one EmailMessage.
     * @example
     * // Update one EmailMessage
     * const emailMessage = await prisma.emailMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailMessageUpdateArgs>(args: SelectSubset<T, EmailMessageUpdateArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailMessages.
     * @param {EmailMessageDeleteManyArgs} args - Arguments to filter EmailMessages to delete.
     * @example
     * // Delete a few EmailMessages
     * const { count } = await prisma.emailMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailMessageDeleteManyArgs>(args?: SelectSubset<T, EmailMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailMessages
     * const emailMessage = await prisma.emailMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailMessageUpdateManyArgs>(args: SelectSubset<T, EmailMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailMessages and returns the data updated in the database.
     * @param {EmailMessageUpdateManyAndReturnArgs} args - Arguments to update many EmailMessages.
     * @example
     * // Update many EmailMessages
     * const emailMessage = await prisma.emailMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailMessages and only return the `id`
     * const emailMessageWithIdOnly = await prisma.emailMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailMessage.
     * @param {EmailMessageUpsertArgs} args - Arguments to update or create a EmailMessage.
     * @example
     * // Update or create a EmailMessage
     * const emailMessage = await prisma.emailMessage.upsert({
     *   create: {
     *     // ... data to create a EmailMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailMessage we want to update
     *   }
     * })
     */
    upsert<T extends EmailMessageUpsertArgs>(args: SelectSubset<T, EmailMessageUpsertArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageCountArgs} args - Arguments to filter EmailMessages to count.
     * @example
     * // Count the number of EmailMessages
     * const count = await prisma.emailMessage.count({
     *   where: {
     *     // ... the filter for the EmailMessages we want to count
     *   }
     * })
    **/
    count<T extends EmailMessageCountArgs>(
      args?: Subset<T, EmailMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailMessageAggregateArgs>(args: Subset<T, EmailMessageAggregateArgs>): Prisma.PrismaPromise<GetEmailMessageAggregateType<T>>

    /**
     * Group by EmailMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailMessageGroupByArgs['orderBy'] }
        : { orderBy?: EmailMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailMessage model
   */
  readonly fields: EmailMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    thread<T extends EmailThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailThreadDefaultArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends EmailMessage$leadArgs<ExtArgs> = {}>(args?: Subset<T, EmailMessage$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    opportunity<T extends EmailMessage$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, EmailMessage$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailMessage model
   */
  interface EmailMessageFieldRefs {
    readonly id: FieldRef<"EmailMessage", 'String'>
    readonly tenantId: FieldRef<"EmailMessage", 'String'>
    readonly threadId: FieldRef<"EmailMessage", 'String'>
    readonly provider: FieldRef<"EmailMessage", 'String'>
    readonly messageId: FieldRef<"EmailMessage", 'String'>
    readonly fromEmail: FieldRef<"EmailMessage", 'String'>
    readonly toEmail: FieldRef<"EmailMessage", 'String'>
    readonly cc: FieldRef<"EmailMessage", 'String'>
    readonly bcc: FieldRef<"EmailMessage", 'String'>
    readonly subject: FieldRef<"EmailMessage", 'String'>
    readonly snippet: FieldRef<"EmailMessage", 'String'>
    readonly bodyText: FieldRef<"EmailMessage", 'String'>
    readonly bodyHtml: FieldRef<"EmailMessage", 'String'>
    readonly direction: FieldRef<"EmailMessage", 'String'>
    readonly sentAt: FieldRef<"EmailMessage", 'DateTime'>
    readonly createdAt: FieldRef<"EmailMessage", 'DateTime'>
    readonly leadId: FieldRef<"EmailMessage", 'String'>
    readonly opportunityId: FieldRef<"EmailMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailMessage findUnique
   */
  export type EmailMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage findUniqueOrThrow
   */
  export type EmailMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage findFirst
   */
  export type EmailMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailMessages.
     */
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailMessage findFirstOrThrow
   */
  export type EmailMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailMessages.
     */
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailMessage findMany
   */
  export type EmailMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessages to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }

  /**
   * EmailMessage create
   */
  export type EmailMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailMessage.
     */
    data: XOR<EmailMessageCreateInput, EmailMessageUncheckedCreateInput>
  }

  /**
   * EmailMessage createMany
   */
  export type EmailMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailMessages.
     */
    data: EmailMessageCreateManyInput | EmailMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailMessage createManyAndReturn
   */
  export type EmailMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * The data used to create many EmailMessages.
     */
    data: EmailMessageCreateManyInput | EmailMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailMessage update
   */
  export type EmailMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailMessage.
     */
    data: XOR<EmailMessageUpdateInput, EmailMessageUncheckedUpdateInput>
    /**
     * Choose, which EmailMessage to update.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage updateMany
   */
  export type EmailMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailMessages.
     */
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyInput>
    /**
     * Filter which EmailMessages to update
     */
    where?: EmailMessageWhereInput
    /**
     * Limit how many EmailMessages to update.
     */
    limit?: number
  }

  /**
   * EmailMessage updateManyAndReturn
   */
  export type EmailMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * The data used to update EmailMessages.
     */
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyInput>
    /**
     * Filter which EmailMessages to update
     */
    where?: EmailMessageWhereInput
    /**
     * Limit how many EmailMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailMessage upsert
   */
  export type EmailMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailMessage to update in case it exists.
     */
    where: EmailMessageWhereUniqueInput
    /**
     * In case the EmailMessage found by the `where` argument doesn't exist, create a new EmailMessage with this data.
     */
    create: XOR<EmailMessageCreateInput, EmailMessageUncheckedCreateInput>
    /**
     * In case the EmailMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailMessageUpdateInput, EmailMessageUncheckedUpdateInput>
  }

  /**
   * EmailMessage delete
   */
  export type EmailMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter which EmailMessage to delete.
     */
    where: EmailMessageWhereUniqueInput
  }

  /**
   * EmailMessage deleteMany
   */
  export type EmailMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailMessages to delete
     */
    where?: EmailMessageWhereInput
    /**
     * Limit how many EmailMessages to delete.
     */
    limit?: number
  }

  /**
   * EmailMessage.lead
   */
  export type EmailMessage$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * EmailMessage.opportunity
   */
  export type EmailMessage$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * EmailMessage without action
   */
  export type EmailMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailMessage
     */
    omit?: EmailMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailMessageInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    exchangeRate: Decimal | null
    deliveryCost: Decimal | null
    markupDefault: Decimal | null
    subtotalMaterialGBP: Decimal | null
    subtotalLabourGBP: Decimal | null
    subtotalOtherGBP: Decimal | null
    totalGBP: Decimal | null
  }

  export type QuoteSumAggregateOutputType = {
    exchangeRate: Decimal | null
    deliveryCost: Decimal | null
    markupDefault: Decimal | null
    subtotalMaterialGBP: Decimal | null
    subtotalLabourGBP: Decimal | null
    subtotalOtherGBP: Decimal | null
    totalGBP: Decimal | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    title: string | null
    status: $Enums.QuoteStatus | null
    currency: string | null
    exchangeRate: Decimal | null
    deliveryCost: Decimal | null
    markupDefault: Decimal | null
    subtotalMaterialGBP: Decimal | null
    subtotalLabourGBP: Decimal | null
    subtotalOtherGBP: Decimal | null
    totalGBP: Decimal | null
    proposalPdfUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    title: string | null
    status: $Enums.QuoteStatus | null
    currency: string | null
    exchangeRate: Decimal | null
    deliveryCost: Decimal | null
    markupDefault: Decimal | null
    subtotalMaterialGBP: Decimal | null
    subtotalLabourGBP: Decimal | null
    subtotalOtherGBP: Decimal | null
    totalGBP: Decimal | null
    proposalPdfUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    tenantId: number
    leadId: number
    title: number
    status: number
    currency: number
    exchangeRate: number
    deliveryCost: number
    markupDefault: number
    subtotalMaterialGBP: number
    subtotalLabourGBP: number
    subtotalOtherGBP: number
    totalGBP: number
    proposalPdfUrl: number
    notes: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    exchangeRate?: true
    deliveryCost?: true
    markupDefault?: true
    subtotalMaterialGBP?: true
    subtotalLabourGBP?: true
    subtotalOtherGBP?: true
    totalGBP?: true
  }

  export type QuoteSumAggregateInputType = {
    exchangeRate?: true
    deliveryCost?: true
    markupDefault?: true
    subtotalMaterialGBP?: true
    subtotalLabourGBP?: true
    subtotalOtherGBP?: true
    totalGBP?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    title?: true
    status?: true
    currency?: true
    exchangeRate?: true
    deliveryCost?: true
    markupDefault?: true
    subtotalMaterialGBP?: true
    subtotalLabourGBP?: true
    subtotalOtherGBP?: true
    totalGBP?: true
    proposalPdfUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    title?: true
    status?: true
    currency?: true
    exchangeRate?: true
    deliveryCost?: true
    markupDefault?: true
    subtotalMaterialGBP?: true
    subtotalLabourGBP?: true
    subtotalOtherGBP?: true
    totalGBP?: true
    proposalPdfUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    title?: true
    status?: true
    currency?: true
    exchangeRate?: true
    deliveryCost?: true
    markupDefault?: true
    subtotalMaterialGBP?: true
    subtotalLabourGBP?: true
    subtotalOtherGBP?: true
    totalGBP?: true
    proposalPdfUrl?: true
    notes?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    tenantId: string
    leadId: string | null
    title: string
    status: $Enums.QuoteStatus
    currency: string
    exchangeRate: Decimal | null
    deliveryCost: Decimal | null
    markupDefault: Decimal | null
    subtotalMaterialGBP: Decimal | null
    subtotalLabourGBP: Decimal | null
    subtotalOtherGBP: Decimal | null
    totalGBP: Decimal | null
    proposalPdfUrl: string | null
    notes: string | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    status?: boolean
    currency?: boolean
    exchangeRate?: boolean
    deliveryCost?: boolean
    markupDefault?: boolean
    subtotalMaterialGBP?: boolean
    subtotalLabourGBP?: boolean
    subtotalOtherGBP?: boolean
    totalGBP?: boolean
    proposalPdfUrl?: boolean
    notes?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | Quote$leadArgs<ExtArgs>
    supplierFiles?: boolean | Quote$supplierFilesArgs<ExtArgs>
    lines?: boolean | Quote$linesArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    status?: boolean
    currency?: boolean
    exchangeRate?: boolean
    deliveryCost?: boolean
    markupDefault?: boolean
    subtotalMaterialGBP?: boolean
    subtotalLabourGBP?: boolean
    subtotalOtherGBP?: boolean
    totalGBP?: boolean
    proposalPdfUrl?: boolean
    notes?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | Quote$leadArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    status?: boolean
    currency?: boolean
    exchangeRate?: boolean
    deliveryCost?: boolean
    markupDefault?: boolean
    subtotalMaterialGBP?: boolean
    subtotalLabourGBP?: boolean
    subtotalOtherGBP?: boolean
    totalGBP?: boolean
    proposalPdfUrl?: boolean
    notes?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | Quote$leadArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    title?: boolean
    status?: boolean
    currency?: boolean
    exchangeRate?: boolean
    deliveryCost?: boolean
    markupDefault?: boolean
    subtotalMaterialGBP?: boolean
    subtotalLabourGBP?: boolean
    subtotalOtherGBP?: boolean
    totalGBP?: boolean
    proposalPdfUrl?: boolean
    notes?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "leadId" | "title" | "status" | "currency" | "exchangeRate" | "deliveryCost" | "markupDefault" | "subtotalMaterialGBP" | "subtotalLabourGBP" | "subtotalOtherGBP" | "totalGBP" | "proposalPdfUrl" | "notes" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["quote"]>
  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | Quote$leadArgs<ExtArgs>
    supplierFiles?: boolean | Quote$supplierFilesArgs<ExtArgs>
    lines?: boolean | Quote$linesArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | Quote$leadArgs<ExtArgs>
  }
  export type QuoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    lead?: boolean | Quote$leadArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      supplierFiles: Prisma.$UploadedFilePayload<ExtArgs>[]
      lines: Prisma.$QuoteLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      leadId: string | null
      title: string
      status: $Enums.QuoteStatus
      currency: string
      exchangeRate: Prisma.Decimal | null
      deliveryCost: Prisma.Decimal | null
      markupDefault: Prisma.Decimal | null
      subtotalMaterialGBP: Prisma.Decimal | null
      subtotalLabourGBP: Prisma.Decimal | null
      subtotalOtherGBP: Prisma.Decimal | null
      totalGBP: Prisma.Decimal | null
      proposalPdfUrl: string | null
      notes: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {QuoteUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends Quote$leadArgs<ExtArgs> = {}>(args?: Subset<T, Quote$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supplierFiles<T extends Quote$supplierFilesArgs<ExtArgs> = {}>(args?: Subset<T, Quote$supplierFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lines<T extends Quote$linesArgs<ExtArgs> = {}>(args?: Subset<T, Quote$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly tenantId: FieldRef<"Quote", 'String'>
    readonly leadId: FieldRef<"Quote", 'String'>
    readonly title: FieldRef<"Quote", 'String'>
    readonly status: FieldRef<"Quote", 'QuoteStatus'>
    readonly currency: FieldRef<"Quote", 'String'>
    readonly exchangeRate: FieldRef<"Quote", 'Decimal'>
    readonly deliveryCost: FieldRef<"Quote", 'Decimal'>
    readonly markupDefault: FieldRef<"Quote", 'Decimal'>
    readonly subtotalMaterialGBP: FieldRef<"Quote", 'Decimal'>
    readonly subtotalLabourGBP: FieldRef<"Quote", 'Decimal'>
    readonly subtotalOtherGBP: FieldRef<"Quote", 'Decimal'>
    readonly totalGBP: FieldRef<"Quote", 'Decimal'>
    readonly proposalPdfUrl: FieldRef<"Quote", 'String'>
    readonly notes: FieldRef<"Quote", 'String'>
    readonly meta: FieldRef<"Quote", 'Json'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quote updateManyAndReturn
   */
  export type QuoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quote.lead
   */
  export type Quote$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Quote.supplierFiles
   */
  export type Quote$supplierFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    where?: UploadedFileWhereInput
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    cursor?: UploadedFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * Quote.lines
   */
  export type Quote$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    where?: QuoteLineWhereInput
    orderBy?: QuoteLineOrderByWithRelationInput | QuoteLineOrderByWithRelationInput[]
    cursor?: QuoteLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteLineScalarFieldEnum | QuoteLineScalarFieldEnum[]
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model QuoteLine
   */

  export type AggregateQuoteLine = {
    _count: QuoteLineCountAggregateOutputType | null
    _avg: QuoteLineAvgAggregateOutputType | null
    _sum: QuoteLineSumAggregateOutputType | null
    _min: QuoteLineMinAggregateOutputType | null
    _max: QuoteLineMaxAggregateOutputType | null
  }

  export type QuoteLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    deliveryShareGBP: Decimal | null
    lineTotalGBP: Decimal | null
  }

  export type QuoteLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    deliveryShareGBP: Decimal | null
    lineTotalGBP: Decimal | null
  }

  export type QuoteLineMinAggregateOutputType = {
    id: string | null
    quoteId: string | null
    supplier: string | null
    sku: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    currency: string | null
    deliveryShareGBP: Decimal | null
    lineTotalGBP: Decimal | null
  }

  export type QuoteLineMaxAggregateOutputType = {
    id: string | null
    quoteId: string | null
    supplier: string | null
    sku: string | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    currency: string | null
    deliveryShareGBP: Decimal | null
    lineTotalGBP: Decimal | null
  }

  export type QuoteLineCountAggregateOutputType = {
    id: number
    quoteId: number
    supplier: number
    sku: number
    description: number
    qty: number
    unitPrice: number
    currency: number
    deliveryShareGBP: number
    lineTotalGBP: number
    meta: number
    _all: number
  }


  export type QuoteLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    deliveryShareGBP?: true
    lineTotalGBP?: true
  }

  export type QuoteLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    deliveryShareGBP?: true
    lineTotalGBP?: true
  }

  export type QuoteLineMinAggregateInputType = {
    id?: true
    quoteId?: true
    supplier?: true
    sku?: true
    description?: true
    qty?: true
    unitPrice?: true
    currency?: true
    deliveryShareGBP?: true
    lineTotalGBP?: true
  }

  export type QuoteLineMaxAggregateInputType = {
    id?: true
    quoteId?: true
    supplier?: true
    sku?: true
    description?: true
    qty?: true
    unitPrice?: true
    currency?: true
    deliveryShareGBP?: true
    lineTotalGBP?: true
  }

  export type QuoteLineCountAggregateInputType = {
    id?: true
    quoteId?: true
    supplier?: true
    sku?: true
    description?: true
    qty?: true
    unitPrice?: true
    currency?: true
    deliveryShareGBP?: true
    lineTotalGBP?: true
    meta?: true
    _all?: true
  }

  export type QuoteLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteLine to aggregate.
     */
    where?: QuoteLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteLines to fetch.
     */
    orderBy?: QuoteLineOrderByWithRelationInput | QuoteLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteLines
    **/
    _count?: true | QuoteLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteLineMaxAggregateInputType
  }

  export type GetQuoteLineAggregateType<T extends QuoteLineAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteLine[P]>
      : GetScalarType<T[P], AggregateQuoteLine[P]>
  }




  export type QuoteLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteLineWhereInput
    orderBy?: QuoteLineOrderByWithAggregationInput | QuoteLineOrderByWithAggregationInput[]
    by: QuoteLineScalarFieldEnum[] | QuoteLineScalarFieldEnum
    having?: QuoteLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteLineCountAggregateInputType | true
    _avg?: QuoteLineAvgAggregateInputType
    _sum?: QuoteLineSumAggregateInputType
    _min?: QuoteLineMinAggregateInputType
    _max?: QuoteLineMaxAggregateInputType
  }

  export type QuoteLineGroupByOutputType = {
    id: string
    quoteId: string
    supplier: string | null
    sku: string | null
    description: string
    qty: Decimal
    unitPrice: Decimal
    currency: string
    deliveryShareGBP: Decimal
    lineTotalGBP: Decimal
    meta: JsonValue | null
    _count: QuoteLineCountAggregateOutputType | null
    _avg: QuoteLineAvgAggregateOutputType | null
    _sum: QuoteLineSumAggregateOutputType | null
    _min: QuoteLineMinAggregateOutputType | null
    _max: QuoteLineMaxAggregateOutputType | null
  }

  type GetQuoteLineGroupByPayload<T extends QuoteLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteLineGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteLineGroupByOutputType[P]>
        }
      >
    >


  export type QuoteLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    supplier?: boolean
    sku?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    currency?: boolean
    deliveryShareGBP?: boolean
    lineTotalGBP?: boolean
    meta?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteLine"]>

  export type QuoteLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    supplier?: boolean
    sku?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    currency?: boolean
    deliveryShareGBP?: boolean
    lineTotalGBP?: boolean
    meta?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteLine"]>

  export type QuoteLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteId?: boolean
    supplier?: boolean
    sku?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    currency?: boolean
    deliveryShareGBP?: boolean
    lineTotalGBP?: boolean
    meta?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteLine"]>

  export type QuoteLineSelectScalar = {
    id?: boolean
    quoteId?: boolean
    supplier?: boolean
    sku?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    currency?: boolean
    deliveryShareGBP?: boolean
    lineTotalGBP?: boolean
    meta?: boolean
  }

  export type QuoteLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quoteId" | "supplier" | "sku" | "description" | "qty" | "unitPrice" | "currency" | "deliveryShareGBP" | "lineTotalGBP" | "meta", ExtArgs["result"]["quoteLine"]>
  export type QuoteLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuoteLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuoteLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $QuoteLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteLine"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quoteId: string
      supplier: string | null
      sku: string | null
      description: string
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      currency: string
      deliveryShareGBP: Prisma.Decimal
      lineTotalGBP: Prisma.Decimal
      meta: Prisma.JsonValue | null
    }, ExtArgs["result"]["quoteLine"]>
    composites: {}
  }

  type QuoteLineGetPayload<S extends boolean | null | undefined | QuoteLineDefaultArgs> = $Result.GetResult<Prisma.$QuoteLinePayload, S>

  type QuoteLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteLineCountAggregateInputType | true
    }

  export interface QuoteLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteLine'], meta: { name: 'QuoteLine' } }
    /**
     * Find zero or one QuoteLine that matches the filter.
     * @param {QuoteLineFindUniqueArgs} args - Arguments to find a QuoteLine
     * @example
     * // Get one QuoteLine
     * const quoteLine = await prisma.quoteLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteLineFindUniqueArgs>(args: SelectSubset<T, QuoteLineFindUniqueArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuoteLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteLineFindUniqueOrThrowArgs} args - Arguments to find a QuoteLine
     * @example
     * // Get one QuoteLine
     * const quoteLine = await prisma.quoteLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteLineFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteLineFindFirstArgs} args - Arguments to find a QuoteLine
     * @example
     * // Get one QuoteLine
     * const quoteLine = await prisma.quoteLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteLineFindFirstArgs>(args?: SelectSubset<T, QuoteLineFindFirstArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteLineFindFirstOrThrowArgs} args - Arguments to find a QuoteLine
     * @example
     * // Get one QuoteLine
     * const quoteLine = await prisma.quoteLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteLineFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuoteLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteLines
     * const quoteLines = await prisma.quoteLine.findMany()
     * 
     * // Get first 10 QuoteLines
     * const quoteLines = await prisma.quoteLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteLineWithIdOnly = await prisma.quoteLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteLineFindManyArgs>(args?: SelectSubset<T, QuoteLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuoteLine.
     * @param {QuoteLineCreateArgs} args - Arguments to create a QuoteLine.
     * @example
     * // Create one QuoteLine
     * const QuoteLine = await prisma.quoteLine.create({
     *   data: {
     *     // ... data to create a QuoteLine
     *   }
     * })
     * 
     */
    create<T extends QuoteLineCreateArgs>(args: SelectSubset<T, QuoteLineCreateArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuoteLines.
     * @param {QuoteLineCreateManyArgs} args - Arguments to create many QuoteLines.
     * @example
     * // Create many QuoteLines
     * const quoteLine = await prisma.quoteLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteLineCreateManyArgs>(args?: SelectSubset<T, QuoteLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteLines and returns the data saved in the database.
     * @param {QuoteLineCreateManyAndReturnArgs} args - Arguments to create many QuoteLines.
     * @example
     * // Create many QuoteLines
     * const quoteLine = await prisma.quoteLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteLines and only return the `id`
     * const quoteLineWithIdOnly = await prisma.quoteLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteLineCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuoteLine.
     * @param {QuoteLineDeleteArgs} args - Arguments to delete one QuoteLine.
     * @example
     * // Delete one QuoteLine
     * const QuoteLine = await prisma.quoteLine.delete({
     *   where: {
     *     // ... filter to delete one QuoteLine
     *   }
     * })
     * 
     */
    delete<T extends QuoteLineDeleteArgs>(args: SelectSubset<T, QuoteLineDeleteArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuoteLine.
     * @param {QuoteLineUpdateArgs} args - Arguments to update one QuoteLine.
     * @example
     * // Update one QuoteLine
     * const quoteLine = await prisma.quoteLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteLineUpdateArgs>(args: SelectSubset<T, QuoteLineUpdateArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuoteLines.
     * @param {QuoteLineDeleteManyArgs} args - Arguments to filter QuoteLines to delete.
     * @example
     * // Delete a few QuoteLines
     * const { count } = await prisma.quoteLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteLineDeleteManyArgs>(args?: SelectSubset<T, QuoteLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteLines
     * const quoteLine = await prisma.quoteLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteLineUpdateManyArgs>(args: SelectSubset<T, QuoteLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteLines and returns the data updated in the database.
     * @param {QuoteLineUpdateManyAndReturnArgs} args - Arguments to update many QuoteLines.
     * @example
     * // Update many QuoteLines
     * const quoteLine = await prisma.quoteLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuoteLines and only return the `id`
     * const quoteLineWithIdOnly = await prisma.quoteLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteLineUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuoteLine.
     * @param {QuoteLineUpsertArgs} args - Arguments to update or create a QuoteLine.
     * @example
     * // Update or create a QuoteLine
     * const quoteLine = await prisma.quoteLine.upsert({
     *   create: {
     *     // ... data to create a QuoteLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteLine we want to update
     *   }
     * })
     */
    upsert<T extends QuoteLineUpsertArgs>(args: SelectSubset<T, QuoteLineUpsertArgs<ExtArgs>>): Prisma__QuoteLineClient<$Result.GetResult<Prisma.$QuoteLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuoteLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteLineCountArgs} args - Arguments to filter QuoteLines to count.
     * @example
     * // Count the number of QuoteLines
     * const count = await prisma.quoteLine.count({
     *   where: {
     *     // ... the filter for the QuoteLines we want to count
     *   }
     * })
    **/
    count<T extends QuoteLineCountArgs>(
      args?: Subset<T, QuoteLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteLineAggregateArgs>(args: Subset<T, QuoteLineAggregateArgs>): Prisma.PrismaPromise<GetQuoteLineAggregateType<T>>

    /**
     * Group by QuoteLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteLineGroupByArgs['orderBy'] }
        : { orderBy?: QuoteLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteLine model
   */
  readonly fields: QuoteLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteLine model
   */
  interface QuoteLineFieldRefs {
    readonly id: FieldRef<"QuoteLine", 'String'>
    readonly quoteId: FieldRef<"QuoteLine", 'String'>
    readonly supplier: FieldRef<"QuoteLine", 'String'>
    readonly sku: FieldRef<"QuoteLine", 'String'>
    readonly description: FieldRef<"QuoteLine", 'String'>
    readonly qty: FieldRef<"QuoteLine", 'Decimal'>
    readonly unitPrice: FieldRef<"QuoteLine", 'Decimal'>
    readonly currency: FieldRef<"QuoteLine", 'String'>
    readonly deliveryShareGBP: FieldRef<"QuoteLine", 'Decimal'>
    readonly lineTotalGBP: FieldRef<"QuoteLine", 'Decimal'>
    readonly meta: FieldRef<"QuoteLine", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * QuoteLine findUnique
   */
  export type QuoteLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * Filter, which QuoteLine to fetch.
     */
    where: QuoteLineWhereUniqueInput
  }

  /**
   * QuoteLine findUniqueOrThrow
   */
  export type QuoteLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * Filter, which QuoteLine to fetch.
     */
    where: QuoteLineWhereUniqueInput
  }

  /**
   * QuoteLine findFirst
   */
  export type QuoteLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * Filter, which QuoteLine to fetch.
     */
    where?: QuoteLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteLines to fetch.
     */
    orderBy?: QuoteLineOrderByWithRelationInput | QuoteLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteLines.
     */
    cursor?: QuoteLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteLines.
     */
    distinct?: QuoteLineScalarFieldEnum | QuoteLineScalarFieldEnum[]
  }

  /**
   * QuoteLine findFirstOrThrow
   */
  export type QuoteLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * Filter, which QuoteLine to fetch.
     */
    where?: QuoteLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteLines to fetch.
     */
    orderBy?: QuoteLineOrderByWithRelationInput | QuoteLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteLines.
     */
    cursor?: QuoteLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteLines.
     */
    distinct?: QuoteLineScalarFieldEnum | QuoteLineScalarFieldEnum[]
  }

  /**
   * QuoteLine findMany
   */
  export type QuoteLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * Filter, which QuoteLines to fetch.
     */
    where?: QuoteLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteLines to fetch.
     */
    orderBy?: QuoteLineOrderByWithRelationInput | QuoteLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteLines.
     */
    cursor?: QuoteLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteLines.
     */
    skip?: number
    distinct?: QuoteLineScalarFieldEnum | QuoteLineScalarFieldEnum[]
  }

  /**
   * QuoteLine create
   */
  export type QuoteLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteLine.
     */
    data: XOR<QuoteLineCreateInput, QuoteLineUncheckedCreateInput>
  }

  /**
   * QuoteLine createMany
   */
  export type QuoteLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteLines.
     */
    data: QuoteLineCreateManyInput | QuoteLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteLine createManyAndReturn
   */
  export type QuoteLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * The data used to create many QuoteLines.
     */
    data: QuoteLineCreateManyInput | QuoteLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteLine update
   */
  export type QuoteLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteLine.
     */
    data: XOR<QuoteLineUpdateInput, QuoteLineUncheckedUpdateInput>
    /**
     * Choose, which QuoteLine to update.
     */
    where: QuoteLineWhereUniqueInput
  }

  /**
   * QuoteLine updateMany
   */
  export type QuoteLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteLines.
     */
    data: XOR<QuoteLineUpdateManyMutationInput, QuoteLineUncheckedUpdateManyInput>
    /**
     * Filter which QuoteLines to update
     */
    where?: QuoteLineWhereInput
    /**
     * Limit how many QuoteLines to update.
     */
    limit?: number
  }

  /**
   * QuoteLine updateManyAndReturn
   */
  export type QuoteLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * The data used to update QuoteLines.
     */
    data: XOR<QuoteLineUpdateManyMutationInput, QuoteLineUncheckedUpdateManyInput>
    /**
     * Filter which QuoteLines to update
     */
    where?: QuoteLineWhereInput
    /**
     * Limit how many QuoteLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteLine upsert
   */
  export type QuoteLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteLine to update in case it exists.
     */
    where: QuoteLineWhereUniqueInput
    /**
     * In case the QuoteLine found by the `where` argument doesn't exist, create a new QuoteLine with this data.
     */
    create: XOR<QuoteLineCreateInput, QuoteLineUncheckedCreateInput>
    /**
     * In case the QuoteLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteLineUpdateInput, QuoteLineUncheckedUpdateInput>
  }

  /**
   * QuoteLine delete
   */
  export type QuoteLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
    /**
     * Filter which QuoteLine to delete.
     */
    where: QuoteLineWhereUniqueInput
  }

  /**
   * QuoteLine deleteMany
   */
  export type QuoteLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteLines to delete
     */
    where?: QuoteLineWhereInput
    /**
     * Limit how many QuoteLines to delete.
     */
    limit?: number
  }

  /**
   * QuoteLine without action
   */
  export type QuoteLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteLine
     */
    select?: QuoteLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteLine
     */
    omit?: QuoteLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteLineInclude<ExtArgs> | null
  }


  /**
   * Model UploadedFile
   */

  export type AggregateUploadedFile = {
    _count: UploadedFileCountAggregateOutputType | null
    _avg: UploadedFileAvgAggregateOutputType | null
    _sum: UploadedFileSumAggregateOutputType | null
    _min: UploadedFileMinAggregateOutputType | null
    _max: UploadedFileMaxAggregateOutputType | null
  }

  export type UploadedFileAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type UploadedFileSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type UploadedFileMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    quoteId: string | null
    kind: $Enums.FileKind | null
    name: string | null
    path: string | null
    mimeType: string | null
    sizeBytes: number | null
    uploadedAt: Date | null
  }

  export type UploadedFileMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    quoteId: string | null
    kind: $Enums.FileKind | null
    name: string | null
    path: string | null
    mimeType: string | null
    sizeBytes: number | null
    uploadedAt: Date | null
  }

  export type UploadedFileCountAggregateOutputType = {
    id: number
    tenantId: number
    quoteId: number
    kind: number
    name: number
    path: number
    mimeType: number
    sizeBytes: number
    uploadedAt: number
    _all: number
  }


  export type UploadedFileAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type UploadedFileSumAggregateInputType = {
    sizeBytes?: true
  }

  export type UploadedFileMinAggregateInputType = {
    id?: true
    tenantId?: true
    quoteId?: true
    kind?: true
    name?: true
    path?: true
    mimeType?: true
    sizeBytes?: true
    uploadedAt?: true
  }

  export type UploadedFileMaxAggregateInputType = {
    id?: true
    tenantId?: true
    quoteId?: true
    kind?: true
    name?: true
    path?: true
    mimeType?: true
    sizeBytes?: true
    uploadedAt?: true
  }

  export type UploadedFileCountAggregateInputType = {
    id?: true
    tenantId?: true
    quoteId?: true
    kind?: true
    name?: true
    path?: true
    mimeType?: true
    sizeBytes?: true
    uploadedAt?: true
    _all?: true
  }

  export type UploadedFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedFile to aggregate.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UploadedFiles
    **/
    _count?: true | UploadedFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadedFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadedFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadedFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadedFileMaxAggregateInputType
  }

  export type GetUploadedFileAggregateType<T extends UploadedFileAggregateArgs> = {
        [P in keyof T & keyof AggregateUploadedFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUploadedFile[P]>
      : GetScalarType<T[P], AggregateUploadedFile[P]>
  }




  export type UploadedFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedFileWhereInput
    orderBy?: UploadedFileOrderByWithAggregationInput | UploadedFileOrderByWithAggregationInput[]
    by: UploadedFileScalarFieldEnum[] | UploadedFileScalarFieldEnum
    having?: UploadedFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadedFileCountAggregateInputType | true
    _avg?: UploadedFileAvgAggregateInputType
    _sum?: UploadedFileSumAggregateInputType
    _min?: UploadedFileMinAggregateInputType
    _max?: UploadedFileMaxAggregateInputType
  }

  export type UploadedFileGroupByOutputType = {
    id: string
    tenantId: string
    quoteId: string | null
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType: string | null
    sizeBytes: number | null
    uploadedAt: Date
    _count: UploadedFileCountAggregateOutputType | null
    _avg: UploadedFileAvgAggregateOutputType | null
    _sum: UploadedFileSumAggregateOutputType | null
    _min: UploadedFileMinAggregateOutputType | null
    _max: UploadedFileMaxAggregateOutputType | null
  }

  type GetUploadedFileGroupByPayload<T extends UploadedFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadedFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadedFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadedFileGroupByOutputType[P]>
            : GetScalarType<T[P], UploadedFileGroupByOutputType[P]>
        }
      >
    >


  export type UploadedFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    quoteId?: boolean
    kind?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    uploadedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    quote?: boolean | UploadedFile$quoteArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    quoteId?: boolean
    kind?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    uploadedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    quote?: boolean | UploadedFile$quoteArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    quoteId?: boolean
    kind?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    uploadedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    quote?: boolean | UploadedFile$quoteArgs<ExtArgs>
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectScalar = {
    id?: boolean
    tenantId?: boolean
    quoteId?: boolean
    kind?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    uploadedAt?: boolean
  }

  export type UploadedFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "quoteId" | "kind" | "name" | "path" | "mimeType" | "sizeBytes" | "uploadedAt", ExtArgs["result"]["uploadedFile"]>
  export type UploadedFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    quote?: boolean | UploadedFile$quoteArgs<ExtArgs>
  }
  export type UploadedFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    quote?: boolean | UploadedFile$quoteArgs<ExtArgs>
  }
  export type UploadedFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    quote?: boolean | UploadedFile$quoteArgs<ExtArgs>
  }

  export type $UploadedFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UploadedFile"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      quote: Prisma.$QuotePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      quoteId: string | null
      kind: $Enums.FileKind
      name: string
      path: string
      mimeType: string | null
      sizeBytes: number | null
      uploadedAt: Date
    }, ExtArgs["result"]["uploadedFile"]>
    composites: {}
  }

  type UploadedFileGetPayload<S extends boolean | null | undefined | UploadedFileDefaultArgs> = $Result.GetResult<Prisma.$UploadedFilePayload, S>

  type UploadedFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UploadedFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UploadedFileCountAggregateInputType | true
    }

  export interface UploadedFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UploadedFile'], meta: { name: 'UploadedFile' } }
    /**
     * Find zero or one UploadedFile that matches the filter.
     * @param {UploadedFileFindUniqueArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadedFileFindUniqueArgs>(args: SelectSubset<T, UploadedFileFindUniqueArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UploadedFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UploadedFileFindUniqueOrThrowArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadedFileFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadedFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UploadedFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindFirstArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadedFileFindFirstArgs>(args?: SelectSubset<T, UploadedFileFindFirstArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UploadedFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindFirstOrThrowArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadedFileFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadedFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UploadedFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UploadedFiles
     * const uploadedFiles = await prisma.uploadedFile.findMany()
     * 
     * // Get first 10 UploadedFiles
     * const uploadedFiles = await prisma.uploadedFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadedFileFindManyArgs>(args?: SelectSubset<T, UploadedFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UploadedFile.
     * @param {UploadedFileCreateArgs} args - Arguments to create a UploadedFile.
     * @example
     * // Create one UploadedFile
     * const UploadedFile = await prisma.uploadedFile.create({
     *   data: {
     *     // ... data to create a UploadedFile
     *   }
     * })
     * 
     */
    create<T extends UploadedFileCreateArgs>(args: SelectSubset<T, UploadedFileCreateArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UploadedFiles.
     * @param {UploadedFileCreateManyArgs} args - Arguments to create many UploadedFiles.
     * @example
     * // Create many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadedFileCreateManyArgs>(args?: SelectSubset<T, UploadedFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UploadedFiles and returns the data saved in the database.
     * @param {UploadedFileCreateManyAndReturnArgs} args - Arguments to create many UploadedFiles.
     * @example
     * // Create many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UploadedFiles and only return the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UploadedFileCreateManyAndReturnArgs>(args?: SelectSubset<T, UploadedFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UploadedFile.
     * @param {UploadedFileDeleteArgs} args - Arguments to delete one UploadedFile.
     * @example
     * // Delete one UploadedFile
     * const UploadedFile = await prisma.uploadedFile.delete({
     *   where: {
     *     // ... filter to delete one UploadedFile
     *   }
     * })
     * 
     */
    delete<T extends UploadedFileDeleteArgs>(args: SelectSubset<T, UploadedFileDeleteArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UploadedFile.
     * @param {UploadedFileUpdateArgs} args - Arguments to update one UploadedFile.
     * @example
     * // Update one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadedFileUpdateArgs>(args: SelectSubset<T, UploadedFileUpdateArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UploadedFiles.
     * @param {UploadedFileDeleteManyArgs} args - Arguments to filter UploadedFiles to delete.
     * @example
     * // Delete a few UploadedFiles
     * const { count } = await prisma.uploadedFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadedFileDeleteManyArgs>(args?: SelectSubset<T, UploadedFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadedFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadedFileUpdateManyArgs>(args: SelectSubset<T, UploadedFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadedFiles and returns the data updated in the database.
     * @param {UploadedFileUpdateManyAndReturnArgs} args - Arguments to update many UploadedFiles.
     * @example
     * // Update many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UploadedFiles and only return the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UploadedFileUpdateManyAndReturnArgs>(args: SelectSubset<T, UploadedFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UploadedFile.
     * @param {UploadedFileUpsertArgs} args - Arguments to update or create a UploadedFile.
     * @example
     * // Update or create a UploadedFile
     * const uploadedFile = await prisma.uploadedFile.upsert({
     *   create: {
     *     // ... data to create a UploadedFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UploadedFile we want to update
     *   }
     * })
     */
    upsert<T extends UploadedFileUpsertArgs>(args: SelectSubset<T, UploadedFileUpsertArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UploadedFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileCountArgs} args - Arguments to filter UploadedFiles to count.
     * @example
     * // Count the number of UploadedFiles
     * const count = await prisma.uploadedFile.count({
     *   where: {
     *     // ... the filter for the UploadedFiles we want to count
     *   }
     * })
    **/
    count<T extends UploadedFileCountArgs>(
      args?: Subset<T, UploadedFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadedFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UploadedFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadedFileAggregateArgs>(args: Subset<T, UploadedFileAggregateArgs>): Prisma.PrismaPromise<GetUploadedFileAggregateType<T>>

    /**
     * Group by UploadedFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadedFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadedFileGroupByArgs['orderBy'] }
        : { orderBy?: UploadedFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadedFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadedFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UploadedFile model
   */
  readonly fields: UploadedFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UploadedFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadedFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quote<T extends UploadedFile$quoteArgs<ExtArgs> = {}>(args?: Subset<T, UploadedFile$quoteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UploadedFile model
   */
  interface UploadedFileFieldRefs {
    readonly id: FieldRef<"UploadedFile", 'String'>
    readonly tenantId: FieldRef<"UploadedFile", 'String'>
    readonly quoteId: FieldRef<"UploadedFile", 'String'>
    readonly kind: FieldRef<"UploadedFile", 'FileKind'>
    readonly name: FieldRef<"UploadedFile", 'String'>
    readonly path: FieldRef<"UploadedFile", 'String'>
    readonly mimeType: FieldRef<"UploadedFile", 'String'>
    readonly sizeBytes: FieldRef<"UploadedFile", 'Int'>
    readonly uploadedAt: FieldRef<"UploadedFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UploadedFile findUnique
   */
  export type UploadedFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile findUniqueOrThrow
   */
  export type UploadedFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile findFirst
   */
  export type UploadedFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedFiles.
     */
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile findFirstOrThrow
   */
  export type UploadedFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedFiles.
     */
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile findMany
   */
  export type UploadedFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter, which UploadedFiles to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile create
   */
  export type UploadedFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * The data needed to create a UploadedFile.
     */
    data: XOR<UploadedFileCreateInput, UploadedFileUncheckedCreateInput>
  }

  /**
   * UploadedFile createMany
   */
  export type UploadedFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UploadedFiles.
     */
    data: UploadedFileCreateManyInput | UploadedFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UploadedFile createManyAndReturn
   */
  export type UploadedFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * The data used to create many UploadedFiles.
     */
    data: UploadedFileCreateManyInput | UploadedFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UploadedFile update
   */
  export type UploadedFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * The data needed to update a UploadedFile.
     */
    data: XOR<UploadedFileUpdateInput, UploadedFileUncheckedUpdateInput>
    /**
     * Choose, which UploadedFile to update.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile updateMany
   */
  export type UploadedFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UploadedFiles.
     */
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyInput>
    /**
     * Filter which UploadedFiles to update
     */
    where?: UploadedFileWhereInput
    /**
     * Limit how many UploadedFiles to update.
     */
    limit?: number
  }

  /**
   * UploadedFile updateManyAndReturn
   */
  export type UploadedFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * The data used to update UploadedFiles.
     */
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyInput>
    /**
     * Filter which UploadedFiles to update
     */
    where?: UploadedFileWhereInput
    /**
     * Limit how many UploadedFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UploadedFile upsert
   */
  export type UploadedFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * The filter to search for the UploadedFile to update in case it exists.
     */
    where: UploadedFileWhereUniqueInput
    /**
     * In case the UploadedFile found by the `where` argument doesn't exist, create a new UploadedFile with this data.
     */
    create: XOR<UploadedFileCreateInput, UploadedFileUncheckedCreateInput>
    /**
     * In case the UploadedFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadedFileUpdateInput, UploadedFileUncheckedUpdateInput>
  }

  /**
   * UploadedFile delete
   */
  export type UploadedFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
    /**
     * Filter which UploadedFile to delete.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile deleteMany
   */
  export type UploadedFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedFiles to delete
     */
    where?: UploadedFileWhereInput
    /**
     * Limit how many UploadedFiles to delete.
     */
    limit?: number
  }

  /**
   * UploadedFile.quote
   */
  export type UploadedFile$quoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
  }

  /**
   * UploadedFile without action
   */
  export type UploadedFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UploadedFile
     */
    omit?: UploadedFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadedFileInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    userId: string | null
    token: string | null
    expiresAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    userId: string | null
    token: string | null
    expiresAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    userId: number
    token: number
    expiresAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    userId?: true
    token?: true
    expiresAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    userId: string
    token: string
    expiresAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "token" | "expiresAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      token: string
      expiresAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const passwordResetTokenWithUserIdOnly = await prisma.passwordResetToken.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `userId`
     * const passwordResetTokenWithUserIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `userId`
     * const passwordResetTokenWithUserIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    subscriptionStatus: 'subscriptionStatus',
    plan: 'plan',
    trialEndsAt: 'trialEndsAt',
    discountCodeUsed: 'discountCodeUsed',
    seatsOffice: 'seatsOffice',
    seatsWorkshop: 'seatsWorkshop',
    seatsDisplay: 'seatsDisplay'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    name: 'name',
    role: 'role',
    passwordHash: 'passwordHash'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    createdById: 'createdById',
    contactName: 'contactName',
    email: 'email',
    status: 'status',
    capturedAt: 'capturedAt',
    nextActionAt: 'nextActionAt',
    nextAction: 'nextAction',
    briefJson: 'briefJson',
    custom: 'custom',
    description: 'description'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    leadId: 'leadId',
    title: 'title',
    valueGBP: 'valueGBP',
    stage: 'stage',
    wonAt: 'wonAt',
    lostAt: 'lostAt',
    createdAt: 'createdAt'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const EmailIngestScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    provider: 'provider',
    messageId: 'messageId',
    fromEmail: 'fromEmail',
    subject: 'subject',
    snippet: 'snippet',
    processedAt: 'processedAt',
    leadId: 'leadId',
    aiPredictedIsLead: 'aiPredictedIsLead',
    userLabelIsLead: 'userLabelIsLead',
    userLabeledAt: 'userLabeledAt',
    createdAt: 'createdAt'
  };

  export type EmailIngestScalarFieldEnum = (typeof EmailIngestScalarFieldEnum)[keyof typeof EmailIngestScalarFieldEnum]


  export const LeadFieldDefScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    key: 'key',
    label: 'label',
    type: 'type',
    required: 'required',
    config: 'config',
    sortOrder: 'sortOrder'
  };

  export type LeadFieldDefScalarFieldEnum = (typeof LeadFieldDefScalarFieldEnum)[keyof typeof LeadFieldDefScalarFieldEnum]


  export const GmailTenantConnectionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    connectedById: 'connectedById',
    gmailAddress: 'gmailAddress',
    refreshToken: 'refreshToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GmailTenantConnectionScalarFieldEnum = (typeof GmailTenantConnectionScalarFieldEnum)[keyof typeof GmailTenantConnectionScalarFieldEnum]


  export const Ms365TenantConnectionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    connectedById: 'connectedById',
    ms365Address: 'ms365Address',
    refreshToken: 'refreshToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Ms365TenantConnectionScalarFieldEnum = (typeof Ms365TenantConnectionScalarFieldEnum)[keyof typeof Ms365TenantConnectionScalarFieldEnum]


  export const LeadExampleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    provider: 'provider',
    messageId: 'messageId',
    subject: 'subject',
    body: 'body',
    extracted: 'extracted',
    label: 'label',
    createdAt: 'createdAt'
  };

  export type LeadExampleScalarFieldEnum = (typeof LeadExampleScalarFieldEnum)[keyof typeof LeadExampleScalarFieldEnum]


  export const LeadTrainingExampleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    provider: 'provider',
    messageId: 'messageId',
    label: 'label',
    extracted: 'extracted',
    createdAt: 'createdAt'
  };

  export type LeadTrainingExampleScalarFieldEnum = (typeof LeadTrainingExampleScalarFieldEnum)[keyof typeof LeadTrainingExampleScalarFieldEnum]


  export const TenantSettingsScalarFieldEnum: {
    tenantId: 'tenantId',
    slug: 'slug',
    brandName: 'brandName',
    introHtml: 'introHtml',
    website: 'website',
    phone: 'phone',
    logoUrl: 'logoUrl',
    links: 'links',
    questionnaire: 'questionnaire',
    inbox: 'inbox',
    inboxWatchEnabled: 'inboxWatchEnabled',
    inboxLastRun: 'inboxLastRun',
    quoteDefaults: 'quoteDefaults',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantSettingsScalarFieldEnum = (typeof TenantSettingsScalarFieldEnum)[keyof typeof TenantSettingsScalarFieldEnum]


  export const FollowUpLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    leadId: 'leadId',
    variant: 'variant',
    subject: 'subject',
    body: 'body',
    sentAt: 'sentAt',
    opened: 'opened',
    replied: 'replied',
    converted: 'converted',
    delayDays: 'delayDays',
    provider: 'provider',
    messageId: 'messageId',
    threadId: 'threadId'
  };

  export type FollowUpLogScalarFieldEnum = (typeof FollowUpLogScalarFieldEnum)[keyof typeof FollowUpLogScalarFieldEnum]


  export const LeadSourceCostScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    source: 'source',
    month: 'month',
    spend: 'spend',
    leads: 'leads',
    conversions: 'conversions',
    scalable: 'scalable'
  };

  export type LeadSourceCostScalarFieldEnum = (typeof LeadSourceCostScalarFieldEnum)[keyof typeof LeadSourceCostScalarFieldEnum]


  export const LeadSourceSpendScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    source: 'source',
    month: 'month',
    amountGBP: 'amountGBP'
  };

  export type LeadSourceSpendScalarFieldEnum = (typeof LeadSourceSpendScalarFieldEnum)[keyof typeof LeadSourceSpendScalarFieldEnum]


  export const LeadSourceConfigScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    source: 'source',
    scalable: 'scalable'
  };

  export type LeadSourceConfigScalarFieldEnum = (typeof LeadSourceConfigScalarFieldEnum)[keyof typeof LeadSourceConfigScalarFieldEnum]


  export const FollowupExperimentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    opportunityId: 'opportunityId',
    variant: 'variant',
    source: 'source',
    suggestedAt: 'suggestedAt',
    whenISO: 'whenISO',
    subject: 'subject',
    body: 'body',
    sentAt: 'sentAt',
    replied: 'replied',
    outcome: 'outcome'
  };

  export type FollowupExperimentScalarFieldEnum = (typeof FollowupExperimentScalarFieldEnum)[keyof typeof FollowupExperimentScalarFieldEnum]


  export const EmailThreadScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    provider: 'provider',
    threadId: 'threadId',
    subject: 'subject',
    leadId: 'leadId',
    opportunityId: 'opportunityId',
    lastInboundAt: 'lastInboundAt',
    lastOutboundAt: 'lastOutboundAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailThreadScalarFieldEnum = (typeof EmailThreadScalarFieldEnum)[keyof typeof EmailThreadScalarFieldEnum]


  export const EmailMessageScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    threadId: 'threadId',
    provider: 'provider',
    messageId: 'messageId',
    fromEmail: 'fromEmail',
    toEmail: 'toEmail',
    cc: 'cc',
    bcc: 'bcc',
    subject: 'subject',
    snippet: 'snippet',
    bodyText: 'bodyText',
    bodyHtml: 'bodyHtml',
    direction: 'direction',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    leadId: 'leadId',
    opportunityId: 'opportunityId'
  };

  export type EmailMessageScalarFieldEnum = (typeof EmailMessageScalarFieldEnum)[keyof typeof EmailMessageScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    leadId: 'leadId',
    title: 'title',
    status: 'status',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    deliveryCost: 'deliveryCost',
    markupDefault: 'markupDefault',
    subtotalMaterialGBP: 'subtotalMaterialGBP',
    subtotalLabourGBP: 'subtotalLabourGBP',
    subtotalOtherGBP: 'subtotalOtherGBP',
    totalGBP: 'totalGBP',
    proposalPdfUrl: 'proposalPdfUrl',
    notes: 'notes',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const QuoteLineScalarFieldEnum: {
    id: 'id',
    quoteId: 'quoteId',
    supplier: 'supplier',
    sku: 'sku',
    description: 'description',
    qty: 'qty',
    unitPrice: 'unitPrice',
    currency: 'currency',
    deliveryShareGBP: 'deliveryShareGBP',
    lineTotalGBP: 'lineTotalGBP',
    meta: 'meta'
  };

  export type QuoteLineScalarFieldEnum = (typeof QuoteLineScalarFieldEnum)[keyof typeof QuoteLineScalarFieldEnum]


  export const UploadedFileScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    quoteId: 'quoteId',
    kind: 'kind',
    name: 'name',
    path: 'path',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    uploadedAt: 'uploadedAt'
  };

  export type UploadedFileScalarFieldEnum = (typeof UploadedFileScalarFieldEnum)[keyof typeof UploadedFileScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Plan[]'
   */
  export type ListEnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'OppStage'
   */
  export type EnumOppStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OppStage'>
    


  /**
   * Reference to a field of type 'OppStage[]'
   */
  export type ListEnumOppStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OppStage[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'LeadLabel'
   */
  export type EnumLeadLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadLabel'>
    


  /**
   * Reference to a field of type 'LeadLabel[]'
   */
  export type ListEnumLeadLabelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadLabel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'QuoteStatus'
   */
  export type EnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus'>
    


  /**
   * Reference to a field of type 'QuoteStatus[]'
   */
  export type ListEnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus[]'>
    


  /**
   * Reference to a field of type 'FileKind'
   */
  export type EnumFileKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileKind'>
    


  /**
   * Reference to a field of type 'FileKind[]'
   */
  export type ListEnumFileKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileKind[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    stripeCustomerId?: StringNullableFilter<"Tenant"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Tenant"> | string | null
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"Tenant"> | $Enums.SubscriptionStatus | null
    plan?: EnumPlanNullableFilter<"Tenant"> | $Enums.Plan | null
    trialEndsAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    discountCodeUsed?: StringNullableFilter<"Tenant"> | string | null
    seatsOffice?: IntFilter<"Tenant"> | number
    seatsWorkshop?: IntFilter<"Tenant"> | number
    seatsDisplay?: IntFilter<"Tenant"> | number
    users?: UserListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    leadFieldDefs?: LeadFieldDefListRelationFilter
    GmailTenantConnection?: XOR<GmailTenantConnectionNullableScalarRelationFilter, GmailTenantConnectionWhereInput> | null
    Ms365TenantConnection?: XOR<Ms365TenantConnectionNullableScalarRelationFilter, Ms365TenantConnectionWhereInput> | null
    emailIngests?: EmailIngestListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    emailMessages?: EmailMessageListRelationFilter
    quotes?: QuoteListRelationFilter
    UploadedFile?: UploadedFileListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    discountCodeUsed?: SortOrderInput | SortOrder
    seatsOffice?: SortOrder
    seatsWorkshop?: SortOrder
    seatsDisplay?: SortOrder
    users?: UserOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
    leadFieldDefs?: LeadFieldDefOrderByRelationAggregateInput
    GmailTenantConnection?: GmailTenantConnectionOrderByWithRelationInput
    Ms365TenantConnection?: Ms365TenantConnectionOrderByWithRelationInput
    emailIngests?: EmailIngestOrderByRelationAggregateInput
    emailThreads?: EmailThreadOrderByRelationAggregateInput
    emailMessages?: EmailMessageOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    UploadedFile?: UploadedFileOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"Tenant"> | $Enums.SubscriptionStatus | null
    plan?: EnumPlanNullableFilter<"Tenant"> | $Enums.Plan | null
    trialEndsAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    discountCodeUsed?: StringNullableFilter<"Tenant"> | string | null
    seatsOffice?: IntFilter<"Tenant"> | number
    seatsWorkshop?: IntFilter<"Tenant"> | number
    seatsDisplay?: IntFilter<"Tenant"> | number
    users?: UserListRelationFilter
    leads?: LeadListRelationFilter
    opportunities?: OpportunityListRelationFilter
    leadFieldDefs?: LeadFieldDefListRelationFilter
    GmailTenantConnection?: XOR<GmailTenantConnectionNullableScalarRelationFilter, GmailTenantConnectionWhereInput> | null
    Ms365TenantConnection?: XOR<Ms365TenantConnectionNullableScalarRelationFilter, Ms365TenantConnectionWhereInput> | null
    emailIngests?: EmailIngestListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    emailMessages?: EmailMessageListRelationFilter
    quotes?: QuoteListRelationFilter
    UploadedFile?: UploadedFileListRelationFilter
  }, "id" | "stripeCustomerId" | "stripeSubscriptionId">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    discountCodeUsed?: SortOrderInput | SortOrder
    seatsOffice?: SortOrder
    seatsWorkshop?: SortOrder
    seatsDisplay?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    subscriptionStatus?: EnumSubscriptionStatusNullableWithAggregatesFilter<"Tenant"> | $Enums.SubscriptionStatus | null
    plan?: EnumPlanNullableWithAggregatesFilter<"Tenant"> | $Enums.Plan | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    discountCodeUsed?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    seatsOffice?: IntWithAggregatesFilter<"Tenant"> | number
    seatsWorkshop?: IntWithAggregatesFilter<"Tenant"> | number
    seatsDisplay?: IntWithAggregatesFilter<"Tenant"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    GmailTenantConnection?: GmailTenantConnectionListRelationFilter
    Ms365TenantConnection?: Ms365TenantConnectionListRelationFilter
    passwordResetToken?: XOR<PasswordResetTokenNullableScalarRelationFilter, PasswordResetTokenWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    GmailTenantConnection?: GmailTenantConnectionOrderByRelationAggregateInput
    Ms365TenantConnection?: Ms365TenantConnectionOrderByRelationAggregateInput
    passwordResetToken?: PasswordResetTokenOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    GmailTenantConnection?: GmailTenantConnectionListRelationFilter
    Ms365TenantConnection?: Ms365TenantConnectionListRelationFilter
    passwordResetToken?: XOR<PasswordResetTokenNullableScalarRelationFilter, PasswordResetTokenWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    createdById?: StringFilter<"Lead"> | string
    contactName?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    capturedAt?: DateTimeFilter<"Lead"> | Date | string
    nextActionAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextAction?: StringNullableFilter<"Lead"> | string | null
    briefJson?: JsonNullableFilter<"Lead">
    custom?: JsonNullableFilter<"Lead">
    description?: StringNullableFilter<"Lead"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    emailIngests?: EmailIngestListRelationFilter
    followUpLogs?: FollowUpLogListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    emailMessages?: EmailMessageListRelationFilter
    Quote?: QuoteListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    contactName?: SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    capturedAt?: SortOrder
    nextActionAt?: SortOrderInput | SortOrder
    nextAction?: SortOrderInput | SortOrder
    briefJson?: SortOrderInput | SortOrder
    custom?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    emailIngests?: EmailIngestOrderByRelationAggregateInput
    followUpLogs?: FollowUpLogOrderByRelationAggregateInput
    emailThreads?: EmailThreadOrderByRelationAggregateInput
    emailMessages?: EmailMessageOrderByRelationAggregateInput
    Quote?: QuoteOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    tenantId?: StringFilter<"Lead"> | string
    createdById?: StringFilter<"Lead"> | string
    contactName?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    capturedAt?: DateTimeFilter<"Lead"> | Date | string
    nextActionAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextAction?: StringNullableFilter<"Lead"> | string | null
    briefJson?: JsonNullableFilter<"Lead">
    custom?: JsonNullableFilter<"Lead">
    description?: StringNullableFilter<"Lead"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    emailIngests?: EmailIngestListRelationFilter
    followUpLogs?: FollowUpLogListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    emailMessages?: EmailMessageListRelationFilter
    Quote?: QuoteListRelationFilter
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    contactName?: SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    capturedAt?: SortOrder
    nextActionAt?: SortOrderInput | SortOrder
    nextAction?: SortOrderInput | SortOrder
    briefJson?: SortOrderInput | SortOrder
    custom?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    tenantId?: StringWithAggregatesFilter<"Lead"> | string
    createdById?: StringWithAggregatesFilter<"Lead"> | string
    contactName?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    capturedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    nextActionAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    nextAction?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    briefJson?: JsonNullableWithAggregatesFilter<"Lead">
    custom?: JsonNullableWithAggregatesFilter<"Lead">
    description?: StringNullableWithAggregatesFilter<"Lead"> | string | null
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    tenantId?: StringFilter<"Opportunity"> | string
    leadId?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    valueGBP?: DecimalNullableFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFilter<"Opportunity"> | $Enums.OppStage
    wonAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    emailThreads?: EmailThreadListRelationFilter
    emailMessages?: EmailMessageListRelationFilter
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    valueGBP?: SortOrderInput | SortOrder
    stage?: SortOrder
    wonAt?: SortOrderInput | SortOrder
    lostAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    emailThreads?: EmailThreadOrderByRelationAggregateInput
    emailMessages?: EmailMessageOrderByRelationAggregateInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leadId?: string
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    tenantId?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    valueGBP?: DecimalNullableFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFilter<"Opportunity"> | $Enums.OppStage
    wonAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    emailThreads?: EmailThreadListRelationFilter
    emailMessages?: EmailMessageListRelationFilter
  }, "id" | "leadId">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    valueGBP?: SortOrderInput | SortOrder
    stage?: SortOrder
    wonAt?: SortOrderInput | SortOrder
    lostAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _avg?: OpportunityAvgOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
    _sum?: OpportunitySumOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Opportunity"> | string
    tenantId?: StringWithAggregatesFilter<"Opportunity"> | string
    leadId?: StringWithAggregatesFilter<"Opportunity"> | string
    title?: StringWithAggregatesFilter<"Opportunity"> | string
    valueGBP?: DecimalNullableWithAggregatesFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageWithAggregatesFilter<"Opportunity"> | $Enums.OppStage
    wonAt?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    lostAt?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
  }

  export type EmailIngestWhereInput = {
    AND?: EmailIngestWhereInput | EmailIngestWhereInput[]
    OR?: EmailIngestWhereInput[]
    NOT?: EmailIngestWhereInput | EmailIngestWhereInput[]
    id?: StringFilter<"EmailIngest"> | string
    tenantId?: StringFilter<"EmailIngest"> | string
    provider?: StringFilter<"EmailIngest"> | string
    messageId?: StringFilter<"EmailIngest"> | string
    fromEmail?: StringNullableFilter<"EmailIngest"> | string | null
    subject?: StringNullableFilter<"EmailIngest"> | string | null
    snippet?: StringNullableFilter<"EmailIngest"> | string | null
    processedAt?: DateTimeNullableFilter<"EmailIngest"> | Date | string | null
    leadId?: StringNullableFilter<"EmailIngest"> | string | null
    aiPredictedIsLead?: BoolNullableFilter<"EmailIngest"> | boolean | null
    userLabelIsLead?: BoolNullableFilter<"EmailIngest"> | boolean | null
    userLabeledAt?: DateTimeNullableFilter<"EmailIngest"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailIngest"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }

  export type EmailIngestOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    aiPredictedIsLead?: SortOrderInput | SortOrder
    userLabelIsLead?: SortOrderInput | SortOrder
    userLabeledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
  }

  export type EmailIngestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_provider_messageId?: EmailIngestTenantId_provider_messageIdCompoundUniqueInput
    AND?: EmailIngestWhereInput | EmailIngestWhereInput[]
    OR?: EmailIngestWhereInput[]
    NOT?: EmailIngestWhereInput | EmailIngestWhereInput[]
    tenantId?: StringFilter<"EmailIngest"> | string
    provider?: StringFilter<"EmailIngest"> | string
    messageId?: StringFilter<"EmailIngest"> | string
    fromEmail?: StringNullableFilter<"EmailIngest"> | string | null
    subject?: StringNullableFilter<"EmailIngest"> | string | null
    snippet?: StringNullableFilter<"EmailIngest"> | string | null
    processedAt?: DateTimeNullableFilter<"EmailIngest"> | Date | string | null
    leadId?: StringNullableFilter<"EmailIngest"> | string | null
    aiPredictedIsLead?: BoolNullableFilter<"EmailIngest"> | boolean | null
    userLabelIsLead?: BoolNullableFilter<"EmailIngest"> | boolean | null
    userLabeledAt?: DateTimeNullableFilter<"EmailIngest"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailIngest"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }, "id" | "tenantId_provider_messageId">

  export type EmailIngestOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    aiPredictedIsLead?: SortOrderInput | SortOrder
    userLabelIsLead?: SortOrderInput | SortOrder
    userLabeledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailIngestCountOrderByAggregateInput
    _max?: EmailIngestMaxOrderByAggregateInput
    _min?: EmailIngestMinOrderByAggregateInput
  }

  export type EmailIngestScalarWhereWithAggregatesInput = {
    AND?: EmailIngestScalarWhereWithAggregatesInput | EmailIngestScalarWhereWithAggregatesInput[]
    OR?: EmailIngestScalarWhereWithAggregatesInput[]
    NOT?: EmailIngestScalarWhereWithAggregatesInput | EmailIngestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailIngest"> | string
    tenantId?: StringWithAggregatesFilter<"EmailIngest"> | string
    provider?: StringWithAggregatesFilter<"EmailIngest"> | string
    messageId?: StringWithAggregatesFilter<"EmailIngest"> | string
    fromEmail?: StringNullableWithAggregatesFilter<"EmailIngest"> | string | null
    subject?: StringNullableWithAggregatesFilter<"EmailIngest"> | string | null
    snippet?: StringNullableWithAggregatesFilter<"EmailIngest"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"EmailIngest"> | Date | string | null
    leadId?: StringNullableWithAggregatesFilter<"EmailIngest"> | string | null
    aiPredictedIsLead?: BoolNullableWithAggregatesFilter<"EmailIngest"> | boolean | null
    userLabelIsLead?: BoolNullableWithAggregatesFilter<"EmailIngest"> | boolean | null
    userLabeledAt?: DateTimeNullableWithAggregatesFilter<"EmailIngest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailIngest"> | Date | string
  }

  export type LeadFieldDefWhereInput = {
    AND?: LeadFieldDefWhereInput | LeadFieldDefWhereInput[]
    OR?: LeadFieldDefWhereInput[]
    NOT?: LeadFieldDefWhereInput | LeadFieldDefWhereInput[]
    id?: StringFilter<"LeadFieldDef"> | string
    tenantId?: StringFilter<"LeadFieldDef"> | string
    key?: StringFilter<"LeadFieldDef"> | string
    label?: StringFilter<"LeadFieldDef"> | string
    type?: StringFilter<"LeadFieldDef"> | string
    required?: BoolFilter<"LeadFieldDef"> | boolean
    config?: JsonNullableFilter<"LeadFieldDef">
    sortOrder?: IntFilter<"LeadFieldDef"> | number
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type LeadFieldDefOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type LeadFieldDefWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_key?: LeadFieldDefTenantIdKeyCompoundUniqueInput
    AND?: LeadFieldDefWhereInput | LeadFieldDefWhereInput[]
    OR?: LeadFieldDefWhereInput[]
    NOT?: LeadFieldDefWhereInput | LeadFieldDefWhereInput[]
    tenantId?: StringFilter<"LeadFieldDef"> | string
    key?: StringFilter<"LeadFieldDef"> | string
    label?: StringFilter<"LeadFieldDef"> | string
    type?: StringFilter<"LeadFieldDef"> | string
    required?: BoolFilter<"LeadFieldDef"> | boolean
    config?: JsonNullableFilter<"LeadFieldDef">
    sortOrder?: IntFilter<"LeadFieldDef"> | number
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_key">

  export type LeadFieldDefOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    _count?: LeadFieldDefCountOrderByAggregateInput
    _avg?: LeadFieldDefAvgOrderByAggregateInput
    _max?: LeadFieldDefMaxOrderByAggregateInput
    _min?: LeadFieldDefMinOrderByAggregateInput
    _sum?: LeadFieldDefSumOrderByAggregateInput
  }

  export type LeadFieldDefScalarWhereWithAggregatesInput = {
    AND?: LeadFieldDefScalarWhereWithAggregatesInput | LeadFieldDefScalarWhereWithAggregatesInput[]
    OR?: LeadFieldDefScalarWhereWithAggregatesInput[]
    NOT?: LeadFieldDefScalarWhereWithAggregatesInput | LeadFieldDefScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadFieldDef"> | string
    tenantId?: StringWithAggregatesFilter<"LeadFieldDef"> | string
    key?: StringWithAggregatesFilter<"LeadFieldDef"> | string
    label?: StringWithAggregatesFilter<"LeadFieldDef"> | string
    type?: StringWithAggregatesFilter<"LeadFieldDef"> | string
    required?: BoolWithAggregatesFilter<"LeadFieldDef"> | boolean
    config?: JsonNullableWithAggregatesFilter<"LeadFieldDef">
    sortOrder?: IntWithAggregatesFilter<"LeadFieldDef"> | number
  }

  export type GmailTenantConnectionWhereInput = {
    AND?: GmailTenantConnectionWhereInput | GmailTenantConnectionWhereInput[]
    OR?: GmailTenantConnectionWhereInput[]
    NOT?: GmailTenantConnectionWhereInput | GmailTenantConnectionWhereInput[]
    id?: StringFilter<"GmailTenantConnection"> | string
    tenantId?: StringFilter<"GmailTenantConnection"> | string
    connectedById?: StringNullableFilter<"GmailTenantConnection"> | string | null
    gmailAddress?: StringNullableFilter<"GmailTenantConnection"> | string | null
    refreshToken?: StringFilter<"GmailTenantConnection"> | string
    createdAt?: DateTimeFilter<"GmailTenantConnection"> | Date | string
    updatedAt?: DateTimeFilter<"GmailTenantConnection"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    connectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GmailTenantConnectionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrderInput | SortOrder
    gmailAddress?: SortOrderInput | SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    connectedBy?: UserOrderByWithRelationInput
  }

  export type GmailTenantConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: GmailTenantConnectionWhereInput | GmailTenantConnectionWhereInput[]
    OR?: GmailTenantConnectionWhereInput[]
    NOT?: GmailTenantConnectionWhereInput | GmailTenantConnectionWhereInput[]
    connectedById?: StringNullableFilter<"GmailTenantConnection"> | string | null
    gmailAddress?: StringNullableFilter<"GmailTenantConnection"> | string | null
    refreshToken?: StringFilter<"GmailTenantConnection"> | string
    createdAt?: DateTimeFilter<"GmailTenantConnection"> | Date | string
    updatedAt?: DateTimeFilter<"GmailTenantConnection"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    connectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "tenantId">

  export type GmailTenantConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrderInput | SortOrder
    gmailAddress?: SortOrderInput | SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GmailTenantConnectionCountOrderByAggregateInput
    _max?: GmailTenantConnectionMaxOrderByAggregateInput
    _min?: GmailTenantConnectionMinOrderByAggregateInput
  }

  export type GmailTenantConnectionScalarWhereWithAggregatesInput = {
    AND?: GmailTenantConnectionScalarWhereWithAggregatesInput | GmailTenantConnectionScalarWhereWithAggregatesInput[]
    OR?: GmailTenantConnectionScalarWhereWithAggregatesInput[]
    NOT?: GmailTenantConnectionScalarWhereWithAggregatesInput | GmailTenantConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GmailTenantConnection"> | string
    tenantId?: StringWithAggregatesFilter<"GmailTenantConnection"> | string
    connectedById?: StringNullableWithAggregatesFilter<"GmailTenantConnection"> | string | null
    gmailAddress?: StringNullableWithAggregatesFilter<"GmailTenantConnection"> | string | null
    refreshToken?: StringWithAggregatesFilter<"GmailTenantConnection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GmailTenantConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GmailTenantConnection"> | Date | string
  }

  export type Ms365TenantConnectionWhereInput = {
    AND?: Ms365TenantConnectionWhereInput | Ms365TenantConnectionWhereInput[]
    OR?: Ms365TenantConnectionWhereInput[]
    NOT?: Ms365TenantConnectionWhereInput | Ms365TenantConnectionWhereInput[]
    id?: StringFilter<"Ms365TenantConnection"> | string
    tenantId?: StringFilter<"Ms365TenantConnection"> | string
    connectedById?: StringNullableFilter<"Ms365TenantConnection"> | string | null
    ms365Address?: StringNullableFilter<"Ms365TenantConnection"> | string | null
    refreshToken?: StringFilter<"Ms365TenantConnection"> | string
    createdAt?: DateTimeFilter<"Ms365TenantConnection"> | Date | string
    updatedAt?: DateTimeFilter<"Ms365TenantConnection"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    connectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type Ms365TenantConnectionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrderInput | SortOrder
    ms365Address?: SortOrderInput | SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    connectedBy?: UserOrderByWithRelationInput
  }

  export type Ms365TenantConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: Ms365TenantConnectionWhereInput | Ms365TenantConnectionWhereInput[]
    OR?: Ms365TenantConnectionWhereInput[]
    NOT?: Ms365TenantConnectionWhereInput | Ms365TenantConnectionWhereInput[]
    connectedById?: StringNullableFilter<"Ms365TenantConnection"> | string | null
    ms365Address?: StringNullableFilter<"Ms365TenantConnection"> | string | null
    refreshToken?: StringFilter<"Ms365TenantConnection"> | string
    createdAt?: DateTimeFilter<"Ms365TenantConnection"> | Date | string
    updatedAt?: DateTimeFilter<"Ms365TenantConnection"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    connectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "tenantId">

  export type Ms365TenantConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrderInput | SortOrder
    ms365Address?: SortOrderInput | SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Ms365TenantConnectionCountOrderByAggregateInput
    _max?: Ms365TenantConnectionMaxOrderByAggregateInput
    _min?: Ms365TenantConnectionMinOrderByAggregateInput
  }

  export type Ms365TenantConnectionScalarWhereWithAggregatesInput = {
    AND?: Ms365TenantConnectionScalarWhereWithAggregatesInput | Ms365TenantConnectionScalarWhereWithAggregatesInput[]
    OR?: Ms365TenantConnectionScalarWhereWithAggregatesInput[]
    NOT?: Ms365TenantConnectionScalarWhereWithAggregatesInput | Ms365TenantConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ms365TenantConnection"> | string
    tenantId?: StringWithAggregatesFilter<"Ms365TenantConnection"> | string
    connectedById?: StringNullableWithAggregatesFilter<"Ms365TenantConnection"> | string | null
    ms365Address?: StringNullableWithAggregatesFilter<"Ms365TenantConnection"> | string | null
    refreshToken?: StringWithAggregatesFilter<"Ms365TenantConnection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ms365TenantConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ms365TenantConnection"> | Date | string
  }

  export type LeadExampleWhereInput = {
    AND?: LeadExampleWhereInput | LeadExampleWhereInput[]
    OR?: LeadExampleWhereInput[]
    NOT?: LeadExampleWhereInput | LeadExampleWhereInput[]
    id?: StringFilter<"LeadExample"> | string
    tenantId?: StringFilter<"LeadExample"> | string
    provider?: StringFilter<"LeadExample"> | string
    messageId?: StringFilter<"LeadExample"> | string
    subject?: StringNullableFilter<"LeadExample"> | string | null
    body?: StringNullableFilter<"LeadExample"> | string | null
    extracted?: JsonNullableFilter<"LeadExample">
    label?: EnumLeadLabelFilter<"LeadExample"> | $Enums.LeadLabel
    createdAt?: DateTimeFilter<"LeadExample"> | Date | string
  }

  export type LeadExampleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    extracted?: SortOrderInput | SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadExampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadExampleWhereInput | LeadExampleWhereInput[]
    OR?: LeadExampleWhereInput[]
    NOT?: LeadExampleWhereInput | LeadExampleWhereInput[]
    tenantId?: StringFilter<"LeadExample"> | string
    provider?: StringFilter<"LeadExample"> | string
    messageId?: StringFilter<"LeadExample"> | string
    subject?: StringNullableFilter<"LeadExample"> | string | null
    body?: StringNullableFilter<"LeadExample"> | string | null
    extracted?: JsonNullableFilter<"LeadExample">
    label?: EnumLeadLabelFilter<"LeadExample"> | $Enums.LeadLabel
    createdAt?: DateTimeFilter<"LeadExample"> | Date | string
  }, "id">

  export type LeadExampleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    extracted?: SortOrderInput | SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    _count?: LeadExampleCountOrderByAggregateInput
    _max?: LeadExampleMaxOrderByAggregateInput
    _min?: LeadExampleMinOrderByAggregateInput
  }

  export type LeadExampleScalarWhereWithAggregatesInput = {
    AND?: LeadExampleScalarWhereWithAggregatesInput | LeadExampleScalarWhereWithAggregatesInput[]
    OR?: LeadExampleScalarWhereWithAggregatesInput[]
    NOT?: LeadExampleScalarWhereWithAggregatesInput | LeadExampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadExample"> | string
    tenantId?: StringWithAggregatesFilter<"LeadExample"> | string
    provider?: StringWithAggregatesFilter<"LeadExample"> | string
    messageId?: StringWithAggregatesFilter<"LeadExample"> | string
    subject?: StringNullableWithAggregatesFilter<"LeadExample"> | string | null
    body?: StringNullableWithAggregatesFilter<"LeadExample"> | string | null
    extracted?: JsonNullableWithAggregatesFilter<"LeadExample">
    label?: EnumLeadLabelWithAggregatesFilter<"LeadExample"> | $Enums.LeadLabel
    createdAt?: DateTimeWithAggregatesFilter<"LeadExample"> | Date | string
  }

  export type LeadTrainingExampleWhereInput = {
    AND?: LeadTrainingExampleWhereInput | LeadTrainingExampleWhereInput[]
    OR?: LeadTrainingExampleWhereInput[]
    NOT?: LeadTrainingExampleWhereInput | LeadTrainingExampleWhereInput[]
    id?: StringFilter<"LeadTrainingExample"> | string
    tenantId?: StringFilter<"LeadTrainingExample"> | string
    provider?: StringFilter<"LeadTrainingExample"> | string
    messageId?: StringFilter<"LeadTrainingExample"> | string
    label?: StringFilter<"LeadTrainingExample"> | string
    extracted?: JsonNullableFilter<"LeadTrainingExample">
    createdAt?: DateTimeFilter<"LeadTrainingExample"> | Date | string
  }

  export type LeadTrainingExampleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    label?: SortOrder
    extracted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type LeadTrainingExampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadTrainingExampleWhereInput | LeadTrainingExampleWhereInput[]
    OR?: LeadTrainingExampleWhereInput[]
    NOT?: LeadTrainingExampleWhereInput | LeadTrainingExampleWhereInput[]
    tenantId?: StringFilter<"LeadTrainingExample"> | string
    provider?: StringFilter<"LeadTrainingExample"> | string
    messageId?: StringFilter<"LeadTrainingExample"> | string
    label?: StringFilter<"LeadTrainingExample"> | string
    extracted?: JsonNullableFilter<"LeadTrainingExample">
    createdAt?: DateTimeFilter<"LeadTrainingExample"> | Date | string
  }, "id">

  export type LeadTrainingExampleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    label?: SortOrder
    extracted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LeadTrainingExampleCountOrderByAggregateInput
    _max?: LeadTrainingExampleMaxOrderByAggregateInput
    _min?: LeadTrainingExampleMinOrderByAggregateInput
  }

  export type LeadTrainingExampleScalarWhereWithAggregatesInput = {
    AND?: LeadTrainingExampleScalarWhereWithAggregatesInput | LeadTrainingExampleScalarWhereWithAggregatesInput[]
    OR?: LeadTrainingExampleScalarWhereWithAggregatesInput[]
    NOT?: LeadTrainingExampleScalarWhereWithAggregatesInput | LeadTrainingExampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadTrainingExample"> | string
    tenantId?: StringWithAggregatesFilter<"LeadTrainingExample"> | string
    provider?: StringWithAggregatesFilter<"LeadTrainingExample"> | string
    messageId?: StringWithAggregatesFilter<"LeadTrainingExample"> | string
    label?: StringWithAggregatesFilter<"LeadTrainingExample"> | string
    extracted?: JsonNullableWithAggregatesFilter<"LeadTrainingExample">
    createdAt?: DateTimeWithAggregatesFilter<"LeadTrainingExample"> | Date | string
  }

  export type TenantSettingsWhereInput = {
    AND?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    OR?: TenantSettingsWhereInput[]
    NOT?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    tenantId?: StringFilter<"TenantSettings"> | string
    slug?: StringFilter<"TenantSettings"> | string
    brandName?: StringFilter<"TenantSettings"> | string
    introHtml?: StringNullableFilter<"TenantSettings"> | string | null
    website?: StringNullableFilter<"TenantSettings"> | string | null
    phone?: StringNullableFilter<"TenantSettings"> | string | null
    logoUrl?: StringNullableFilter<"TenantSettings"> | string | null
    links?: JsonNullableFilter<"TenantSettings">
    questionnaire?: JsonNullableFilter<"TenantSettings">
    inbox?: JsonNullableFilter<"TenantSettings">
    inboxWatchEnabled?: BoolFilter<"TenantSettings"> | boolean
    inboxLastRun?: DateTimeNullableFilter<"TenantSettings"> | Date | string | null
    quoteDefaults?: JsonNullableFilter<"TenantSettings">
    createdAt?: DateTimeFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSettings"> | Date | string
  }

  export type TenantSettingsOrderByWithRelationInput = {
    tenantId?: SortOrder
    slug?: SortOrder
    brandName?: SortOrder
    introHtml?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    links?: SortOrderInput | SortOrder
    questionnaire?: SortOrderInput | SortOrder
    inbox?: SortOrderInput | SortOrder
    inboxWatchEnabled?: SortOrder
    inboxLastRun?: SortOrderInput | SortOrder
    quoteDefaults?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsWhereUniqueInput = Prisma.AtLeast<{
    tenantId?: string
    slug?: string
    AND?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    OR?: TenantSettingsWhereInput[]
    NOT?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    brandName?: StringFilter<"TenantSettings"> | string
    introHtml?: StringNullableFilter<"TenantSettings"> | string | null
    website?: StringNullableFilter<"TenantSettings"> | string | null
    phone?: StringNullableFilter<"TenantSettings"> | string | null
    logoUrl?: StringNullableFilter<"TenantSettings"> | string | null
    links?: JsonNullableFilter<"TenantSettings">
    questionnaire?: JsonNullableFilter<"TenantSettings">
    inbox?: JsonNullableFilter<"TenantSettings">
    inboxWatchEnabled?: BoolFilter<"TenantSettings"> | boolean
    inboxLastRun?: DateTimeNullableFilter<"TenantSettings"> | Date | string | null
    quoteDefaults?: JsonNullableFilter<"TenantSettings">
    createdAt?: DateTimeFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSettings"> | Date | string
  }, "tenantId" | "slug">

  export type TenantSettingsOrderByWithAggregationInput = {
    tenantId?: SortOrder
    slug?: SortOrder
    brandName?: SortOrder
    introHtml?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    links?: SortOrderInput | SortOrder
    questionnaire?: SortOrderInput | SortOrder
    inbox?: SortOrderInput | SortOrder
    inboxWatchEnabled?: SortOrder
    inboxLastRun?: SortOrderInput | SortOrder
    quoteDefaults?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantSettingsCountOrderByAggregateInput
    _max?: TenantSettingsMaxOrderByAggregateInput
    _min?: TenantSettingsMinOrderByAggregateInput
  }

  export type TenantSettingsScalarWhereWithAggregatesInput = {
    AND?: TenantSettingsScalarWhereWithAggregatesInput | TenantSettingsScalarWhereWithAggregatesInput[]
    OR?: TenantSettingsScalarWhereWithAggregatesInput[]
    NOT?: TenantSettingsScalarWhereWithAggregatesInput | TenantSettingsScalarWhereWithAggregatesInput[]
    tenantId?: StringWithAggregatesFilter<"TenantSettings"> | string
    slug?: StringWithAggregatesFilter<"TenantSettings"> | string
    brandName?: StringWithAggregatesFilter<"TenantSettings"> | string
    introHtml?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    website?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    phone?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    links?: JsonNullableWithAggregatesFilter<"TenantSettings">
    questionnaire?: JsonNullableWithAggregatesFilter<"TenantSettings">
    inbox?: JsonNullableWithAggregatesFilter<"TenantSettings">
    inboxWatchEnabled?: BoolWithAggregatesFilter<"TenantSettings"> | boolean
    inboxLastRun?: DateTimeNullableWithAggregatesFilter<"TenantSettings"> | Date | string | null
    quoteDefaults?: JsonNullableWithAggregatesFilter<"TenantSettings">
    createdAt?: DateTimeWithAggregatesFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantSettings"> | Date | string
  }

  export type FollowUpLogWhereInput = {
    AND?: FollowUpLogWhereInput | FollowUpLogWhereInput[]
    OR?: FollowUpLogWhereInput[]
    NOT?: FollowUpLogWhereInput | FollowUpLogWhereInput[]
    id?: StringFilter<"FollowUpLog"> | string
    tenantId?: StringFilter<"FollowUpLog"> | string
    leadId?: StringFilter<"FollowUpLog"> | string
    variant?: StringFilter<"FollowUpLog"> | string
    subject?: StringFilter<"FollowUpLog"> | string
    body?: StringFilter<"FollowUpLog"> | string
    sentAt?: DateTimeFilter<"FollowUpLog"> | Date | string
    opened?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    replied?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    converted?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    delayDays?: IntNullableFilter<"FollowUpLog"> | number | null
    provider?: StringNullableFilter<"FollowUpLog"> | string | null
    messageId?: StringNullableFilter<"FollowUpLog"> | string | null
    threadId?: StringNullableFilter<"FollowUpLog"> | string | null
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }

  export type FollowUpLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    variant?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrderInput | SortOrder
    replied?: SortOrderInput | SortOrder
    converted?: SortOrderInput | SortOrder
    delayDays?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    lead?: LeadOrderByWithRelationInput
  }

  export type FollowUpLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FollowUpLogWhereInput | FollowUpLogWhereInput[]
    OR?: FollowUpLogWhereInput[]
    NOT?: FollowUpLogWhereInput | FollowUpLogWhereInput[]
    tenantId?: StringFilter<"FollowUpLog"> | string
    leadId?: StringFilter<"FollowUpLog"> | string
    variant?: StringFilter<"FollowUpLog"> | string
    subject?: StringFilter<"FollowUpLog"> | string
    body?: StringFilter<"FollowUpLog"> | string
    sentAt?: DateTimeFilter<"FollowUpLog"> | Date | string
    opened?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    replied?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    converted?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    delayDays?: IntNullableFilter<"FollowUpLog"> | number | null
    provider?: StringNullableFilter<"FollowUpLog"> | string | null
    messageId?: StringNullableFilter<"FollowUpLog"> | string | null
    threadId?: StringNullableFilter<"FollowUpLog"> | string | null
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }, "id">

  export type FollowUpLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    variant?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrderInput | SortOrder
    replied?: SortOrderInput | SortOrder
    converted?: SortOrderInput | SortOrder
    delayDays?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    _count?: FollowUpLogCountOrderByAggregateInput
    _avg?: FollowUpLogAvgOrderByAggregateInput
    _max?: FollowUpLogMaxOrderByAggregateInput
    _min?: FollowUpLogMinOrderByAggregateInput
    _sum?: FollowUpLogSumOrderByAggregateInput
  }

  export type FollowUpLogScalarWhereWithAggregatesInput = {
    AND?: FollowUpLogScalarWhereWithAggregatesInput | FollowUpLogScalarWhereWithAggregatesInput[]
    OR?: FollowUpLogScalarWhereWithAggregatesInput[]
    NOT?: FollowUpLogScalarWhereWithAggregatesInput | FollowUpLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FollowUpLog"> | string
    tenantId?: StringWithAggregatesFilter<"FollowUpLog"> | string
    leadId?: StringWithAggregatesFilter<"FollowUpLog"> | string
    variant?: StringWithAggregatesFilter<"FollowUpLog"> | string
    subject?: StringWithAggregatesFilter<"FollowUpLog"> | string
    body?: StringWithAggregatesFilter<"FollowUpLog"> | string
    sentAt?: DateTimeWithAggregatesFilter<"FollowUpLog"> | Date | string
    opened?: BoolNullableWithAggregatesFilter<"FollowUpLog"> | boolean | null
    replied?: BoolNullableWithAggregatesFilter<"FollowUpLog"> | boolean | null
    converted?: BoolNullableWithAggregatesFilter<"FollowUpLog"> | boolean | null
    delayDays?: IntNullableWithAggregatesFilter<"FollowUpLog"> | number | null
    provider?: StringNullableWithAggregatesFilter<"FollowUpLog"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"FollowUpLog"> | string | null
    threadId?: StringNullableWithAggregatesFilter<"FollowUpLog"> | string | null
  }

  export type LeadSourceCostWhereInput = {
    AND?: LeadSourceCostWhereInput | LeadSourceCostWhereInput[]
    OR?: LeadSourceCostWhereInput[]
    NOT?: LeadSourceCostWhereInput | LeadSourceCostWhereInput[]
    id?: StringFilter<"LeadSourceCost"> | string
    tenantId?: StringFilter<"LeadSourceCost"> | string
    source?: StringFilter<"LeadSourceCost"> | string
    month?: DateTimeFilter<"LeadSourceCost"> | Date | string
    spend?: FloatFilter<"LeadSourceCost"> | number
    leads?: IntFilter<"LeadSourceCost"> | number
    conversions?: IntFilter<"LeadSourceCost"> | number
    scalable?: BoolFilter<"LeadSourceCost"> | boolean
  }

  export type LeadSourceCostOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    conversions?: SortOrder
    scalable?: SortOrder
  }

  export type LeadSourceCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_source_month?: LeadSourceCostTenantIdSourceMonthCompoundUniqueInput
    AND?: LeadSourceCostWhereInput | LeadSourceCostWhereInput[]
    OR?: LeadSourceCostWhereInput[]
    NOT?: LeadSourceCostWhereInput | LeadSourceCostWhereInput[]
    tenantId?: StringFilter<"LeadSourceCost"> | string
    source?: StringFilter<"LeadSourceCost"> | string
    month?: DateTimeFilter<"LeadSourceCost"> | Date | string
    spend?: FloatFilter<"LeadSourceCost"> | number
    leads?: IntFilter<"LeadSourceCost"> | number
    conversions?: IntFilter<"LeadSourceCost"> | number
    scalable?: BoolFilter<"LeadSourceCost"> | boolean
  }, "id" | "tenantId_source_month">

  export type LeadSourceCostOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    conversions?: SortOrder
    scalable?: SortOrder
    _count?: LeadSourceCostCountOrderByAggregateInput
    _avg?: LeadSourceCostAvgOrderByAggregateInput
    _max?: LeadSourceCostMaxOrderByAggregateInput
    _min?: LeadSourceCostMinOrderByAggregateInput
    _sum?: LeadSourceCostSumOrderByAggregateInput
  }

  export type LeadSourceCostScalarWhereWithAggregatesInput = {
    AND?: LeadSourceCostScalarWhereWithAggregatesInput | LeadSourceCostScalarWhereWithAggregatesInput[]
    OR?: LeadSourceCostScalarWhereWithAggregatesInput[]
    NOT?: LeadSourceCostScalarWhereWithAggregatesInput | LeadSourceCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadSourceCost"> | string
    tenantId?: StringWithAggregatesFilter<"LeadSourceCost"> | string
    source?: StringWithAggregatesFilter<"LeadSourceCost"> | string
    month?: DateTimeWithAggregatesFilter<"LeadSourceCost"> | Date | string
    spend?: FloatWithAggregatesFilter<"LeadSourceCost"> | number
    leads?: IntWithAggregatesFilter<"LeadSourceCost"> | number
    conversions?: IntWithAggregatesFilter<"LeadSourceCost"> | number
    scalable?: BoolWithAggregatesFilter<"LeadSourceCost"> | boolean
  }

  export type LeadSourceSpendWhereInput = {
    AND?: LeadSourceSpendWhereInput | LeadSourceSpendWhereInput[]
    OR?: LeadSourceSpendWhereInput[]
    NOT?: LeadSourceSpendWhereInput | LeadSourceSpendWhereInput[]
    id?: StringFilter<"LeadSourceSpend"> | string
    tenantId?: StringFilter<"LeadSourceSpend"> | string
    source?: StringFilter<"LeadSourceSpend"> | string
    month?: DateTimeFilter<"LeadSourceSpend"> | Date | string
    amountGBP?: DecimalFilter<"LeadSourceSpend"> | Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    amountGBP?: SortOrder
  }

  export type LeadSourceSpendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadSourceSpendWhereInput | LeadSourceSpendWhereInput[]
    OR?: LeadSourceSpendWhereInput[]
    NOT?: LeadSourceSpendWhereInput | LeadSourceSpendWhereInput[]
    tenantId?: StringFilter<"LeadSourceSpend"> | string
    source?: StringFilter<"LeadSourceSpend"> | string
    month?: DateTimeFilter<"LeadSourceSpend"> | Date | string
    amountGBP?: DecimalFilter<"LeadSourceSpend"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type LeadSourceSpendOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    amountGBP?: SortOrder
    _count?: LeadSourceSpendCountOrderByAggregateInput
    _avg?: LeadSourceSpendAvgOrderByAggregateInput
    _max?: LeadSourceSpendMaxOrderByAggregateInput
    _min?: LeadSourceSpendMinOrderByAggregateInput
    _sum?: LeadSourceSpendSumOrderByAggregateInput
  }

  export type LeadSourceSpendScalarWhereWithAggregatesInput = {
    AND?: LeadSourceSpendScalarWhereWithAggregatesInput | LeadSourceSpendScalarWhereWithAggregatesInput[]
    OR?: LeadSourceSpendScalarWhereWithAggregatesInput[]
    NOT?: LeadSourceSpendScalarWhereWithAggregatesInput | LeadSourceSpendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadSourceSpend"> | string
    tenantId?: StringWithAggregatesFilter<"LeadSourceSpend"> | string
    source?: StringWithAggregatesFilter<"LeadSourceSpend"> | string
    month?: DateTimeWithAggregatesFilter<"LeadSourceSpend"> | Date | string
    amountGBP?: DecimalWithAggregatesFilter<"LeadSourceSpend"> | Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceConfigWhereInput = {
    AND?: LeadSourceConfigWhereInput | LeadSourceConfigWhereInput[]
    OR?: LeadSourceConfigWhereInput[]
    NOT?: LeadSourceConfigWhereInput | LeadSourceConfigWhereInput[]
    id?: StringFilter<"LeadSourceConfig"> | string
    tenantId?: StringFilter<"LeadSourceConfig"> | string
    source?: StringFilter<"LeadSourceConfig"> | string
    scalable?: BoolFilter<"LeadSourceConfig"> | boolean
  }

  export type LeadSourceConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    scalable?: SortOrder
  }

  export type LeadSourceConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_source?: LeadSourceConfigTenantIdSourceCompoundUniqueInput
    AND?: LeadSourceConfigWhereInput | LeadSourceConfigWhereInput[]
    OR?: LeadSourceConfigWhereInput[]
    NOT?: LeadSourceConfigWhereInput | LeadSourceConfigWhereInput[]
    tenantId?: StringFilter<"LeadSourceConfig"> | string
    source?: StringFilter<"LeadSourceConfig"> | string
    scalable?: BoolFilter<"LeadSourceConfig"> | boolean
  }, "id" | "tenantId_source">

  export type LeadSourceConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    scalable?: SortOrder
    _count?: LeadSourceConfigCountOrderByAggregateInput
    _max?: LeadSourceConfigMaxOrderByAggregateInput
    _min?: LeadSourceConfigMinOrderByAggregateInput
  }

  export type LeadSourceConfigScalarWhereWithAggregatesInput = {
    AND?: LeadSourceConfigScalarWhereWithAggregatesInput | LeadSourceConfigScalarWhereWithAggregatesInput[]
    OR?: LeadSourceConfigScalarWhereWithAggregatesInput[]
    NOT?: LeadSourceConfigScalarWhereWithAggregatesInput | LeadSourceConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadSourceConfig"> | string
    tenantId?: StringWithAggregatesFilter<"LeadSourceConfig"> | string
    source?: StringWithAggregatesFilter<"LeadSourceConfig"> | string
    scalable?: BoolWithAggregatesFilter<"LeadSourceConfig"> | boolean
  }

  export type FollowupExperimentWhereInput = {
    AND?: FollowupExperimentWhereInput | FollowupExperimentWhereInput[]
    OR?: FollowupExperimentWhereInput[]
    NOT?: FollowupExperimentWhereInput | FollowupExperimentWhereInput[]
    id?: StringFilter<"FollowupExperiment"> | string
    tenantId?: StringFilter<"FollowupExperiment"> | string
    opportunityId?: StringFilter<"FollowupExperiment"> | string
    variant?: StringFilter<"FollowupExperiment"> | string
    source?: StringFilter<"FollowupExperiment"> | string
    suggestedAt?: DateTimeFilter<"FollowupExperiment"> | Date | string
    whenISO?: StringFilter<"FollowupExperiment"> | string
    subject?: StringFilter<"FollowupExperiment"> | string
    body?: StringFilter<"FollowupExperiment"> | string
    sentAt?: DateTimeNullableFilter<"FollowupExperiment"> | Date | string | null
    replied?: BoolNullableFilter<"FollowupExperiment"> | boolean | null
    outcome?: StringNullableFilter<"FollowupExperiment"> | string | null
  }

  export type FollowupExperimentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    opportunityId?: SortOrder
    variant?: SortOrder
    source?: SortOrder
    suggestedAt?: SortOrder
    whenISO?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    replied?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
  }

  export type FollowupExperimentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FollowupExperimentWhereInput | FollowupExperimentWhereInput[]
    OR?: FollowupExperimentWhereInput[]
    NOT?: FollowupExperimentWhereInput | FollowupExperimentWhereInput[]
    tenantId?: StringFilter<"FollowupExperiment"> | string
    opportunityId?: StringFilter<"FollowupExperiment"> | string
    variant?: StringFilter<"FollowupExperiment"> | string
    source?: StringFilter<"FollowupExperiment"> | string
    suggestedAt?: DateTimeFilter<"FollowupExperiment"> | Date | string
    whenISO?: StringFilter<"FollowupExperiment"> | string
    subject?: StringFilter<"FollowupExperiment"> | string
    body?: StringFilter<"FollowupExperiment"> | string
    sentAt?: DateTimeNullableFilter<"FollowupExperiment"> | Date | string | null
    replied?: BoolNullableFilter<"FollowupExperiment"> | boolean | null
    outcome?: StringNullableFilter<"FollowupExperiment"> | string | null
  }, "id">

  export type FollowupExperimentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    opportunityId?: SortOrder
    variant?: SortOrder
    source?: SortOrder
    suggestedAt?: SortOrder
    whenISO?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    replied?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    _count?: FollowupExperimentCountOrderByAggregateInput
    _max?: FollowupExperimentMaxOrderByAggregateInput
    _min?: FollowupExperimentMinOrderByAggregateInput
  }

  export type FollowupExperimentScalarWhereWithAggregatesInput = {
    AND?: FollowupExperimentScalarWhereWithAggregatesInput | FollowupExperimentScalarWhereWithAggregatesInput[]
    OR?: FollowupExperimentScalarWhereWithAggregatesInput[]
    NOT?: FollowupExperimentScalarWhereWithAggregatesInput | FollowupExperimentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    tenantId?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    opportunityId?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    variant?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    source?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    suggestedAt?: DateTimeWithAggregatesFilter<"FollowupExperiment"> | Date | string
    whenISO?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    subject?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    body?: StringWithAggregatesFilter<"FollowupExperiment"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"FollowupExperiment"> | Date | string | null
    replied?: BoolNullableWithAggregatesFilter<"FollowupExperiment"> | boolean | null
    outcome?: StringNullableWithAggregatesFilter<"FollowupExperiment"> | string | null
  }

  export type EmailThreadWhereInput = {
    AND?: EmailThreadWhereInput | EmailThreadWhereInput[]
    OR?: EmailThreadWhereInput[]
    NOT?: EmailThreadWhereInput | EmailThreadWhereInput[]
    id?: StringFilter<"EmailThread"> | string
    tenantId?: StringFilter<"EmailThread"> | string
    provider?: StringFilter<"EmailThread"> | string
    threadId?: StringFilter<"EmailThread"> | string
    subject?: StringNullableFilter<"EmailThread"> | string | null
    leadId?: StringNullableFilter<"EmailThread"> | string | null
    opportunityId?: StringNullableFilter<"EmailThread"> | string | null
    lastInboundAt?: DateTimeNullableFilter<"EmailThread"> | Date | string | null
    lastOutboundAt?: DateTimeNullableFilter<"EmailThread"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeFilter<"EmailThread"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    messages?: EmailMessageListRelationFilter
  }

  export type EmailThreadOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    threadId?: SortOrder
    subject?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    lastInboundAt?: SortOrderInput | SortOrder
    lastOutboundAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    messages?: EmailMessageOrderByRelationAggregateInput
  }

  export type EmailThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_provider_threadId?: EmailThreadTenantIdProviderThreadIdCompoundUniqueInput
    AND?: EmailThreadWhereInput | EmailThreadWhereInput[]
    OR?: EmailThreadWhereInput[]
    NOT?: EmailThreadWhereInput | EmailThreadWhereInput[]
    tenantId?: StringFilter<"EmailThread"> | string
    provider?: StringFilter<"EmailThread"> | string
    threadId?: StringFilter<"EmailThread"> | string
    subject?: StringNullableFilter<"EmailThread"> | string | null
    leadId?: StringNullableFilter<"EmailThread"> | string | null
    opportunityId?: StringNullableFilter<"EmailThread"> | string | null
    lastInboundAt?: DateTimeNullableFilter<"EmailThread"> | Date | string | null
    lastOutboundAt?: DateTimeNullableFilter<"EmailThread"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeFilter<"EmailThread"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    messages?: EmailMessageListRelationFilter
  }, "id" | "tenantId_provider_threadId">

  export type EmailThreadOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    threadId?: SortOrder
    subject?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    lastInboundAt?: SortOrderInput | SortOrder
    lastOutboundAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailThreadCountOrderByAggregateInput
    _max?: EmailThreadMaxOrderByAggregateInput
    _min?: EmailThreadMinOrderByAggregateInput
  }

  export type EmailThreadScalarWhereWithAggregatesInput = {
    AND?: EmailThreadScalarWhereWithAggregatesInput | EmailThreadScalarWhereWithAggregatesInput[]
    OR?: EmailThreadScalarWhereWithAggregatesInput[]
    NOT?: EmailThreadScalarWhereWithAggregatesInput | EmailThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailThread"> | string
    tenantId?: StringWithAggregatesFilter<"EmailThread"> | string
    provider?: StringWithAggregatesFilter<"EmailThread"> | string
    threadId?: StringWithAggregatesFilter<"EmailThread"> | string
    subject?: StringNullableWithAggregatesFilter<"EmailThread"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"EmailThread"> | string | null
    opportunityId?: StringNullableWithAggregatesFilter<"EmailThread"> | string | null
    lastInboundAt?: DateTimeNullableWithAggregatesFilter<"EmailThread"> | Date | string | null
    lastOutboundAt?: DateTimeNullableWithAggregatesFilter<"EmailThread"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailThread"> | Date | string
  }

  export type EmailMessageWhereInput = {
    AND?: EmailMessageWhereInput | EmailMessageWhereInput[]
    OR?: EmailMessageWhereInput[]
    NOT?: EmailMessageWhereInput | EmailMessageWhereInput[]
    id?: StringFilter<"EmailMessage"> | string
    tenantId?: StringFilter<"EmailMessage"> | string
    threadId?: StringFilter<"EmailMessage"> | string
    provider?: StringFilter<"EmailMessage"> | string
    messageId?: StringFilter<"EmailMessage"> | string
    fromEmail?: StringNullableFilter<"EmailMessage"> | string | null
    toEmail?: StringNullableFilter<"EmailMessage"> | string | null
    cc?: StringNullableFilter<"EmailMessage"> | string | null
    bcc?: StringNullableFilter<"EmailMessage"> | string | null
    subject?: StringNullableFilter<"EmailMessage"> | string | null
    snippet?: StringNullableFilter<"EmailMessage"> | string | null
    bodyText?: StringNullableFilter<"EmailMessage"> | string | null
    bodyHtml?: StringNullableFilter<"EmailMessage"> | string | null
    direction?: StringFilter<"EmailMessage"> | string
    sentAt?: DateTimeFilter<"EmailMessage"> | Date | string
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    leadId?: StringNullableFilter<"EmailMessage"> | string | null
    opportunityId?: StringNullableFilter<"EmailMessage"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    thread?: XOR<EmailThreadScalarRelationFilter, EmailThreadWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
  }

  export type EmailMessageOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    threadId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrderInput | SortOrder
    toEmail?: SortOrderInput | SortOrder
    cc?: SortOrderInput | SortOrder
    bcc?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    bodyText?: SortOrderInput | SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    direction?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    thread?: EmailThreadOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
  }

  export type EmailMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_provider_messageId?: EmailMessageTenantIdProviderMessageIdCompoundUniqueInput
    AND?: EmailMessageWhereInput | EmailMessageWhereInput[]
    OR?: EmailMessageWhereInput[]
    NOT?: EmailMessageWhereInput | EmailMessageWhereInput[]
    tenantId?: StringFilter<"EmailMessage"> | string
    threadId?: StringFilter<"EmailMessage"> | string
    provider?: StringFilter<"EmailMessage"> | string
    messageId?: StringFilter<"EmailMessage"> | string
    fromEmail?: StringNullableFilter<"EmailMessage"> | string | null
    toEmail?: StringNullableFilter<"EmailMessage"> | string | null
    cc?: StringNullableFilter<"EmailMessage"> | string | null
    bcc?: StringNullableFilter<"EmailMessage"> | string | null
    subject?: StringNullableFilter<"EmailMessage"> | string | null
    snippet?: StringNullableFilter<"EmailMessage"> | string | null
    bodyText?: StringNullableFilter<"EmailMessage"> | string | null
    bodyHtml?: StringNullableFilter<"EmailMessage"> | string | null
    direction?: StringFilter<"EmailMessage"> | string
    sentAt?: DateTimeFilter<"EmailMessage"> | Date | string
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    leadId?: StringNullableFilter<"EmailMessage"> | string | null
    opportunityId?: StringNullableFilter<"EmailMessage"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    thread?: XOR<EmailThreadScalarRelationFilter, EmailThreadWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
  }, "id" | "tenantId_provider_messageId">

  export type EmailMessageOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    threadId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrderInput | SortOrder
    toEmail?: SortOrderInput | SortOrder
    cc?: SortOrderInput | SortOrder
    bcc?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    bodyText?: SortOrderInput | SortOrder
    bodyHtml?: SortOrderInput | SortOrder
    direction?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    _count?: EmailMessageCountOrderByAggregateInput
    _max?: EmailMessageMaxOrderByAggregateInput
    _min?: EmailMessageMinOrderByAggregateInput
  }

  export type EmailMessageScalarWhereWithAggregatesInput = {
    AND?: EmailMessageScalarWhereWithAggregatesInput | EmailMessageScalarWhereWithAggregatesInput[]
    OR?: EmailMessageScalarWhereWithAggregatesInput[]
    NOT?: EmailMessageScalarWhereWithAggregatesInput | EmailMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailMessage"> | string
    tenantId?: StringWithAggregatesFilter<"EmailMessage"> | string
    threadId?: StringWithAggregatesFilter<"EmailMessage"> | string
    provider?: StringWithAggregatesFilter<"EmailMessage"> | string
    messageId?: StringWithAggregatesFilter<"EmailMessage"> | string
    fromEmail?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    toEmail?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    cc?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    bcc?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    subject?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    snippet?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    bodyText?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    bodyHtml?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    direction?: StringWithAggregatesFilter<"EmailMessage"> | string
    sentAt?: DateTimeWithAggregatesFilter<"EmailMessage"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailMessage"> | Date | string
    leadId?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    opportunityId?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: StringFilter<"Quote"> | string
    tenantId?: StringFilter<"Quote"> | string
    leadId?: StringNullableFilter<"Quote"> | string | null
    title?: StringFilter<"Quote"> | string
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    currency?: StringFilter<"Quote"> | string
    exchangeRate?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    markupDefault?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    meta?: JsonNullableFilter<"Quote">
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    supplierFiles?: UploadedFileListRelationFilter
    lines?: QuoteLineListRelationFilter
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    title?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    deliveryCost?: SortOrderInput | SortOrder
    markupDefault?: SortOrderInput | SortOrder
    subtotalMaterialGBP?: SortOrderInput | SortOrder
    subtotalLabourGBP?: SortOrderInput | SortOrder
    subtotalOtherGBP?: SortOrderInput | SortOrder
    totalGBP?: SortOrderInput | SortOrder
    proposalPdfUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    supplierFiles?: UploadedFileOrderByRelationAggregateInput
    lines?: QuoteLineOrderByRelationAggregateInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    tenantId?: StringFilter<"Quote"> | string
    leadId?: StringNullableFilter<"Quote"> | string | null
    title?: StringFilter<"Quote"> | string
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    currency?: StringFilter<"Quote"> | string
    exchangeRate?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    markupDefault?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    meta?: JsonNullableFilter<"Quote">
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    supplierFiles?: UploadedFileListRelationFilter
    lines?: QuoteLineListRelationFilter
  }, "id">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    title?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    deliveryCost?: SortOrderInput | SortOrder
    markupDefault?: SortOrderInput | SortOrder
    subtotalMaterialGBP?: SortOrderInput | SortOrder
    subtotalLabourGBP?: SortOrderInput | SortOrder
    subtotalOtherGBP?: SortOrderInput | SortOrder
    totalGBP?: SortOrderInput | SortOrder
    proposalPdfUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quote"> | string
    tenantId?: StringWithAggregatesFilter<"Quote"> | string
    leadId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    title?: StringWithAggregatesFilter<"Quote"> | string
    status?: EnumQuoteStatusWithAggregatesFilter<"Quote"> | $Enums.QuoteStatus
    currency?: StringWithAggregatesFilter<"Quote"> | string
    exchangeRate?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    markupDefault?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalGBP?: DecimalNullableWithAggregatesFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"Quote">
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
  }

  export type QuoteLineWhereInput = {
    AND?: QuoteLineWhereInput | QuoteLineWhereInput[]
    OR?: QuoteLineWhereInput[]
    NOT?: QuoteLineWhereInput | QuoteLineWhereInput[]
    id?: StringFilter<"QuoteLine"> | string
    quoteId?: StringFilter<"QuoteLine"> | string
    supplier?: StringNullableFilter<"QuoteLine"> | string | null
    sku?: StringNullableFilter<"QuoteLine"> | string | null
    description?: StringFilter<"QuoteLine"> | string
    qty?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"QuoteLine"> | string
    deliveryShareGBP?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableFilter<"QuoteLine">
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }

  export type QuoteLineOrderByWithRelationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    supplier?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    deliveryShareGBP?: SortOrder
    lineTotalGBP?: SortOrder
    meta?: SortOrderInput | SortOrder
    quote?: QuoteOrderByWithRelationInput
  }

  export type QuoteLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuoteLineWhereInput | QuoteLineWhereInput[]
    OR?: QuoteLineWhereInput[]
    NOT?: QuoteLineWhereInput | QuoteLineWhereInput[]
    quoteId?: StringFilter<"QuoteLine"> | string
    supplier?: StringNullableFilter<"QuoteLine"> | string | null
    sku?: StringNullableFilter<"QuoteLine"> | string | null
    description?: StringFilter<"QuoteLine"> | string
    qty?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"QuoteLine"> | string
    deliveryShareGBP?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableFilter<"QuoteLine">
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }, "id">

  export type QuoteLineOrderByWithAggregationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    supplier?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    deliveryShareGBP?: SortOrder
    lineTotalGBP?: SortOrder
    meta?: SortOrderInput | SortOrder
    _count?: QuoteLineCountOrderByAggregateInput
    _avg?: QuoteLineAvgOrderByAggregateInput
    _max?: QuoteLineMaxOrderByAggregateInput
    _min?: QuoteLineMinOrderByAggregateInput
    _sum?: QuoteLineSumOrderByAggregateInput
  }

  export type QuoteLineScalarWhereWithAggregatesInput = {
    AND?: QuoteLineScalarWhereWithAggregatesInput | QuoteLineScalarWhereWithAggregatesInput[]
    OR?: QuoteLineScalarWhereWithAggregatesInput[]
    NOT?: QuoteLineScalarWhereWithAggregatesInput | QuoteLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuoteLine"> | string
    quoteId?: StringWithAggregatesFilter<"QuoteLine"> | string
    supplier?: StringNullableWithAggregatesFilter<"QuoteLine"> | string | null
    sku?: StringNullableWithAggregatesFilter<"QuoteLine"> | string | null
    description?: StringWithAggregatesFilter<"QuoteLine"> | string
    qty?: DecimalWithAggregatesFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"QuoteLine"> | string
    deliveryShareGBP?: DecimalWithAggregatesFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalWithAggregatesFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableWithAggregatesFilter<"QuoteLine">
  }

  export type UploadedFileWhereInput = {
    AND?: UploadedFileWhereInput | UploadedFileWhereInput[]
    OR?: UploadedFileWhereInput[]
    NOT?: UploadedFileWhereInput | UploadedFileWhereInput[]
    id?: StringFilter<"UploadedFile"> | string
    tenantId?: StringFilter<"UploadedFile"> | string
    quoteId?: StringNullableFilter<"UploadedFile"> | string | null
    kind?: EnumFileKindFilter<"UploadedFile"> | $Enums.FileKind
    name?: StringFilter<"UploadedFile"> | string
    path?: StringFilter<"UploadedFile"> | string
    mimeType?: StringNullableFilter<"UploadedFile"> | string | null
    sizeBytes?: IntNullableFilter<"UploadedFile"> | number | null
    uploadedAt?: DateTimeFilter<"UploadedFile"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    quote?: XOR<QuoteNullableScalarRelationFilter, QuoteWhereInput> | null
  }

  export type UploadedFileOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    quoteId?: SortOrderInput | SortOrder
    kind?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    quote?: QuoteOrderByWithRelationInput
  }

  export type UploadedFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UploadedFileWhereInput | UploadedFileWhereInput[]
    OR?: UploadedFileWhereInput[]
    NOT?: UploadedFileWhereInput | UploadedFileWhereInput[]
    tenantId?: StringFilter<"UploadedFile"> | string
    quoteId?: StringNullableFilter<"UploadedFile"> | string | null
    kind?: EnumFileKindFilter<"UploadedFile"> | $Enums.FileKind
    name?: StringFilter<"UploadedFile"> | string
    path?: StringFilter<"UploadedFile"> | string
    mimeType?: StringNullableFilter<"UploadedFile"> | string | null
    sizeBytes?: IntNullableFilter<"UploadedFile"> | number | null
    uploadedAt?: DateTimeFilter<"UploadedFile"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    quote?: XOR<QuoteNullableScalarRelationFilter, QuoteWhereInput> | null
  }, "id">

  export type UploadedFileOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    quoteId?: SortOrderInput | SortOrder
    kind?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: UploadedFileCountOrderByAggregateInput
    _avg?: UploadedFileAvgOrderByAggregateInput
    _max?: UploadedFileMaxOrderByAggregateInput
    _min?: UploadedFileMinOrderByAggregateInput
    _sum?: UploadedFileSumOrderByAggregateInput
  }

  export type UploadedFileScalarWhereWithAggregatesInput = {
    AND?: UploadedFileScalarWhereWithAggregatesInput | UploadedFileScalarWhereWithAggregatesInput[]
    OR?: UploadedFileScalarWhereWithAggregatesInput[]
    NOT?: UploadedFileScalarWhereWithAggregatesInput | UploadedFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UploadedFile"> | string
    tenantId?: StringWithAggregatesFilter<"UploadedFile"> | string
    quoteId?: StringNullableWithAggregatesFilter<"UploadedFile"> | string | null
    kind?: EnumFileKindWithAggregatesFilter<"UploadedFile"> | $Enums.FileKind
    name?: StringWithAggregatesFilter<"UploadedFile"> | string
    path?: StringWithAggregatesFilter<"UploadedFile"> | string
    mimeType?: StringNullableWithAggregatesFilter<"UploadedFile"> | string | null
    sizeBytes?: IntNullableWithAggregatesFilter<"UploadedFile"> | number | null
    uploadedAt?: DateTimeWithAggregatesFilter<"UploadedFile"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    tenant: TenantCreateNestedOneWithoutUsersInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedManyWithoutConnectedByInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateManyWithoutConnectedByNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    tenant: TenantCreateNestedOneWithoutLeadsInput
    opportunity?: OpportunityCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageCreateNestedManyWithoutLeadInput
    Quote?: QuoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityUncheckedCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogUncheckedCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutLeadInput
    Quote?: QuoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUncheckedUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpportunityCreateInput = {
    id?: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOpportunitiesInput
    lead: LeadCreateNestedOneWithoutOpportunityInput
    emailThreads?: EmailThreadCreateNestedManyWithoutOpportunityInput
    emailMessages?: EmailMessageCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateInput = {
    id?: string
    tenantId: string
    leadId: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutOpportunityInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOpportunitiesNestedInput
    lead?: LeadUpdateOneRequiredWithoutOpportunityNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutOpportunityNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutOpportunityNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateManyInput = {
    id?: string
    tenantId: string
    leadId: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIngestCreateInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailIngestsInput
    lead?: LeadCreateNestedOneWithoutEmailIngestsInput
  }

  export type EmailIngestUncheckedCreateInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    leadId?: string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailIngestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailIngestsNestedInput
    lead?: LeadUpdateOneWithoutEmailIngestsNestedInput
  }

  export type EmailIngestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIngestCreateManyInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    leadId?: string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailIngestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIngestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadFieldDefCreateInput = {
    id?: string
    key: string
    label: string
    type?: string
    required?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    tenant: TenantCreateNestedOneWithoutLeadFieldDefsInput
  }

  export type LeadFieldDefUncheckedCreateInput = {
    id?: string
    tenantId: string
    key: string
    label: string
    type?: string
    required?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
  }

  export type LeadFieldDefUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutLeadFieldDefsNestedInput
  }

  export type LeadFieldDefUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type LeadFieldDefCreateManyInput = {
    id?: string
    tenantId: string
    key: string
    label: string
    type?: string
    required?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
  }

  export type LeadFieldDefUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type LeadFieldDefUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type GmailTenantConnectionCreateInput = {
    id?: string
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutGmailTenantConnectionInput
    connectedBy?: UserCreateNestedOneWithoutGmailTenantConnectionInput
  }

  export type GmailTenantConnectionUncheckedCreateInput = {
    id?: string
    tenantId: string
    connectedById?: string | null
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailTenantConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutGmailTenantConnectionNestedInput
    connectedBy?: UserUpdateOneWithoutGmailTenantConnectionNestedInput
  }

  export type GmailTenantConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    connectedById?: NullableStringFieldUpdateOperationsInput | string | null
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailTenantConnectionCreateManyInput = {
    id?: string
    tenantId: string
    connectedById?: string | null
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailTenantConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailTenantConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    connectedById?: NullableStringFieldUpdateOperationsInput | string | null
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Ms365TenantConnectionCreateInput = {
    id?: string
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMs365TenantConnectionInput
    connectedBy?: UserCreateNestedOneWithoutMs365TenantConnectionInput
  }

  export type Ms365TenantConnectionUncheckedCreateInput = {
    id?: string
    tenantId: string
    connectedById?: string | null
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Ms365TenantConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMs365TenantConnectionNestedInput
    connectedBy?: UserUpdateOneWithoutMs365TenantConnectionNestedInput
  }

  export type Ms365TenantConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    connectedById?: NullableStringFieldUpdateOperationsInput | string | null
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Ms365TenantConnectionCreateManyInput = {
    id?: string
    tenantId: string
    connectedById?: string | null
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Ms365TenantConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Ms365TenantConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    connectedById?: NullableStringFieldUpdateOperationsInput | string | null
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadExampleCreateInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    subject?: string | null
    body?: string | null
    extracted?: NullableJsonNullValueInput | InputJsonValue
    label?: $Enums.LeadLabel
    createdAt?: Date | string
  }

  export type LeadExampleUncheckedCreateInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    subject?: string | null
    body?: string | null
    extracted?: NullableJsonNullValueInput | InputJsonValue
    label?: $Enums.LeadLabel
    createdAt?: Date | string
  }

  export type LeadExampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    extracted?: NullableJsonNullValueInput | InputJsonValue
    label?: EnumLeadLabelFieldUpdateOperationsInput | $Enums.LeadLabel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadExampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    extracted?: NullableJsonNullValueInput | InputJsonValue
    label?: EnumLeadLabelFieldUpdateOperationsInput | $Enums.LeadLabel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadExampleCreateManyInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    subject?: string | null
    body?: string | null
    extracted?: NullableJsonNullValueInput | InputJsonValue
    label?: $Enums.LeadLabel
    createdAt?: Date | string
  }

  export type LeadExampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    extracted?: NullableJsonNullValueInput | InputJsonValue
    label?: EnumLeadLabelFieldUpdateOperationsInput | $Enums.LeadLabel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadExampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    extracted?: NullableJsonNullValueInput | InputJsonValue
    label?: EnumLeadLabelFieldUpdateOperationsInput | $Enums.LeadLabel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadTrainingExampleCreateInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    label: string
    extracted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeadTrainingExampleUncheckedCreateInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    label: string
    extracted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeadTrainingExampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    extracted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadTrainingExampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    extracted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadTrainingExampleCreateManyInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    label: string
    extracted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeadTrainingExampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    extracted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadTrainingExampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    extracted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsCreateInput = {
    tenantId: string
    slug: string
    brandName: string
    introHtml?: string | null
    website?: string | null
    phone?: string | null
    logoUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inbox?: NullableJsonNullValueInput | InputJsonValue
    inboxWatchEnabled?: boolean
    inboxLastRun?: Date | string | null
    quoteDefaults?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUncheckedCreateInput = {
    tenantId: string
    slug: string
    brandName: string
    introHtml?: string | null
    website?: string | null
    phone?: string | null
    logoUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inbox?: NullableJsonNullValueInput | InputJsonValue
    inboxWatchEnabled?: boolean
    inboxLastRun?: Date | string | null
    quoteDefaults?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUpdateInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    introHtml?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inbox?: NullableJsonNullValueInput | InputJsonValue
    inboxWatchEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxLastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quoteDefaults?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsUncheckedUpdateInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    introHtml?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inbox?: NullableJsonNullValueInput | InputJsonValue
    inboxWatchEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxLastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quoteDefaults?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsCreateManyInput = {
    tenantId: string
    slug: string
    brandName: string
    introHtml?: string | null
    website?: string | null
    phone?: string | null
    logoUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inbox?: NullableJsonNullValueInput | InputJsonValue
    inboxWatchEnabled?: boolean
    inboxLastRun?: Date | string | null
    quoteDefaults?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUpdateManyMutationInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    introHtml?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inbox?: NullableJsonNullValueInput | InputJsonValue
    inboxWatchEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxLastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quoteDefaults?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsUncheckedUpdateManyInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    introHtml?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inbox?: NullableJsonNullValueInput | InputJsonValue
    inboxWatchEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxLastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quoteDefaults?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpLogCreateInput = {
    id?: string
    tenantId: string
    variant: string
    subject: string
    body: string
    sentAt?: Date | string
    opened?: boolean | null
    replied?: boolean | null
    converted?: boolean | null
    delayDays?: number | null
    provider?: string | null
    messageId?: string | null
    threadId?: string | null
    lead: LeadCreateNestedOneWithoutFollowUpLogsInput
  }

  export type FollowUpLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    leadId: string
    variant: string
    subject: string
    body: string
    sentAt?: Date | string
    opened?: boolean | null
    replied?: boolean | null
    converted?: boolean | null
    delayDays?: number | null
    provider?: string | null
    messageId?: string | null
    threadId?: string | null
  }

  export type FollowUpLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: NullableBoolFieldUpdateOperationsInput | boolean | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delayDays?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    lead?: LeadUpdateOneRequiredWithoutFollowUpLogsNestedInput
  }

  export type FollowUpLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: NullableBoolFieldUpdateOperationsInput | boolean | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delayDays?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowUpLogCreateManyInput = {
    id?: string
    tenantId: string
    leadId: string
    variant: string
    subject: string
    body: string
    sentAt?: Date | string
    opened?: boolean | null
    replied?: boolean | null
    converted?: boolean | null
    delayDays?: number | null
    provider?: string | null
    messageId?: string | null
    threadId?: string | null
  }

  export type FollowUpLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: NullableBoolFieldUpdateOperationsInput | boolean | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delayDays?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowUpLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: NullableBoolFieldUpdateOperationsInput | boolean | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delayDays?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadSourceCostCreateInput = {
    id?: string
    tenantId: string
    source: string
    month: Date | string
    spend?: number
    leads?: number
    conversions?: number
    scalable?: boolean
  }

  export type LeadSourceCostUncheckedCreateInput = {
    id?: string
    tenantId: string
    source: string
    month: Date | string
    spend?: number
    leads?: number
    conversions?: number
    scalable?: boolean
  }

  export type LeadSourceCostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadSourceCostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadSourceCostCreateManyInput = {
    id?: string
    tenantId: string
    source: string
    month: Date | string
    spend?: number
    leads?: number
    conversions?: number
    scalable?: boolean
  }

  export type LeadSourceCostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadSourceCostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    leads?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadSourceSpendCreateInput = {
    id?: string
    tenantId: string
    source: string
    month: Date | string
    amountGBP?: Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendUncheckedCreateInput = {
    id?: string
    tenantId: string
    source: string
    month: Date | string
    amountGBP?: Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    amountGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    amountGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendCreateManyInput = {
    id?: string
    tenantId: string
    source: string
    month: Date | string
    amountGBP?: Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    amountGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    amountGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceConfigCreateInput = {
    id?: string
    tenantId: string
    source: string
    scalable?: boolean
  }

  export type LeadSourceConfigUncheckedCreateInput = {
    id?: string
    tenantId: string
    source: string
    scalable?: boolean
  }

  export type LeadSourceConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadSourceConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadSourceConfigCreateManyInput = {
    id?: string
    tenantId: string
    source: string
    scalable?: boolean
  }

  export type LeadSourceConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadSourceConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    scalable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FollowupExperimentCreateInput = {
    id?: string
    tenantId: string
    opportunityId: string
    variant: string
    source: string
    suggestedAt: Date | string
    whenISO: string
    subject: string
    body: string
    sentAt?: Date | string | null
    replied?: boolean | null
    outcome?: string | null
  }

  export type FollowupExperimentUncheckedCreateInput = {
    id?: string
    tenantId: string
    opportunityId: string
    variant: string
    source: string
    suggestedAt: Date | string
    whenISO: string
    subject: string
    body: string
    sentAt?: Date | string | null
    replied?: boolean | null
    outcome?: string | null
  }

  export type FollowupExperimentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    suggestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whenISO?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowupExperimentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    suggestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whenISO?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowupExperimentCreateManyInput = {
    id?: string
    tenantId: string
    opportunityId: string
    variant: string
    source: string
    suggestedAt: Date | string
    whenISO: string
    subject: string
    body: string
    sentAt?: Date | string | null
    replied?: boolean | null
    outcome?: string | null
  }

  export type FollowupExperimentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    suggestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whenISO?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowupExperimentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    suggestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whenISO?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailThreadCreateInput = {
    id?: string
    provider: string
    threadId: string
    subject?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailThreadsInput
    lead?: LeadCreateNestedOneWithoutEmailThreadsInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailThreadsInput
    messages?: EmailMessageCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadUncheckedCreateInput = {
    id?: string
    tenantId: string
    provider: string
    threadId: string
    subject?: string | null
    leadId?: string | null
    opportunityId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EmailMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailThreadsNestedInput
    lead?: LeadUpdateOneWithoutEmailThreadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailThreadsNestedInput
    messages?: EmailMessageUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EmailMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadCreateManyInput = {
    id?: string
    tenantId: string
    provider: string
    threadId: string
    subject?: string | null
    leadId?: string | null
    opportunityId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageCreateInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailMessagesInput
    thread: EmailThreadCreateNestedOneWithoutMessagesInput
    lead?: LeadCreateNestedOneWithoutEmailMessagesInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailMessagesInput
  }

  export type EmailMessageUncheckedCreateInput = {
    id?: string
    tenantId: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
    opportunityId?: string | null
  }

  export type EmailMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailMessagesNestedInput
    thread?: EmailThreadUpdateOneRequiredWithoutMessagesNestedInput
    lead?: LeadUpdateOneWithoutEmailMessagesNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailMessagesNestedInput
  }

  export type EmailMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailMessageCreateManyInput = {
    id?: string
    tenantId: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
    opportunityId?: string | null
  }

  export type EmailMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuoteCreateInput = {
    id?: string
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutQuotesInput
    lead?: LeadCreateNestedOneWithoutQuoteInput
    supplierFiles?: UploadedFileCreateNestedManyWithoutQuoteInput
    lines?: QuoteLineCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    tenantId: string
    leadId?: string | null
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierFiles?: UploadedFileUncheckedCreateNestedManyWithoutQuoteInput
    lines?: QuoteLineUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutQuotesNestedInput
    lead?: LeadUpdateOneWithoutQuoteNestedInput
    supplierFiles?: UploadedFileUpdateManyWithoutQuoteNestedInput
    lines?: QuoteLineUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierFiles?: UploadedFileUncheckedUpdateManyWithoutQuoteNestedInput
    lines?: QuoteLineUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteCreateManyInput = {
    id?: string
    tenantId: string
    leadId?: string | null
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteLineCreateInput = {
    id?: string
    supplier?: string | null
    sku?: string | null
    description: string
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryShareGBP?: Decimal | DecimalJsLike | number | string
    lineTotalGBP?: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    quote: QuoteCreateNestedOneWithoutLinesInput
  }

  export type QuoteLineUncheckedCreateInput = {
    id?: string
    quoteId: string
    supplier?: string | null
    sku?: string | null
    description: string
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryShareGBP?: Decimal | DecimalJsLike | number | string
    lineTotalGBP?: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryShareGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    quote?: QuoteUpdateOneRequiredWithoutLinesNestedInput
  }

  export type QuoteLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryShareGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineCreateManyInput = {
    id?: string
    quoteId: string
    supplier?: string | null
    sku?: string | null
    description: string
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryShareGBP?: Decimal | DecimalJsLike | number | string
    lineTotalGBP?: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryShareGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryShareGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UploadedFileCreateInput = {
    id?: string
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUploadedFileInput
    quote?: QuoteCreateNestedOneWithoutSupplierFilesInput
  }

  export type UploadedFileUncheckedCreateInput = {
    id?: string
    tenantId: string
    quoteId?: string | null
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
  }

  export type UploadedFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUploadedFileNestedInput
    quote?: QuoteUpdateOneWithoutSupplierFilesNestedInput
  }

  export type UploadedFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileCreateManyInput = {
    id?: string
    tenantId: string
    quoteId?: string | null
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
  }

  export type UploadedFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokenInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    userId: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokenNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    userId: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type EnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type OpportunityListRelationFilter = {
    every?: OpportunityWhereInput
    some?: OpportunityWhereInput
    none?: OpportunityWhereInput
  }

  export type LeadFieldDefListRelationFilter = {
    every?: LeadFieldDefWhereInput
    some?: LeadFieldDefWhereInput
    none?: LeadFieldDefWhereInput
  }

  export type GmailTenantConnectionNullableScalarRelationFilter = {
    is?: GmailTenantConnectionWhereInput | null
    isNot?: GmailTenantConnectionWhereInput | null
  }

  export type Ms365TenantConnectionNullableScalarRelationFilter = {
    is?: Ms365TenantConnectionWhereInput | null
    isNot?: Ms365TenantConnectionWhereInput | null
  }

  export type EmailIngestListRelationFilter = {
    every?: EmailIngestWhereInput
    some?: EmailIngestWhereInput
    none?: EmailIngestWhereInput
  }

  export type EmailThreadListRelationFilter = {
    every?: EmailThreadWhereInput
    some?: EmailThreadWhereInput
    none?: EmailThreadWhereInput
  }

  export type EmailMessageListRelationFilter = {
    every?: EmailMessageWhereInput
    some?: EmailMessageWhereInput
    none?: EmailMessageWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type UploadedFileListRelationFilter = {
    every?: UploadedFileWhereInput
    some?: UploadedFileWhereInput
    none?: UploadedFileWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadFieldDefOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailIngestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UploadedFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    plan?: SortOrder
    trialEndsAt?: SortOrder
    discountCodeUsed?: SortOrder
    seatsOffice?: SortOrder
    seatsWorkshop?: SortOrder
    seatsDisplay?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    seatsOffice?: SortOrder
    seatsWorkshop?: SortOrder
    seatsDisplay?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    plan?: SortOrder
    trialEndsAt?: SortOrder
    discountCodeUsed?: SortOrder
    seatsOffice?: SortOrder
    seatsWorkshop?: SortOrder
    seatsDisplay?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    plan?: SortOrder
    trialEndsAt?: SortOrder
    discountCodeUsed?: SortOrder
    seatsOffice?: SortOrder
    seatsWorkshop?: SortOrder
    seatsDisplay?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    seatsOffice?: SortOrder
    seatsWorkshop?: SortOrder
    seatsDisplay?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type EnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type GmailTenantConnectionListRelationFilter = {
    every?: GmailTenantConnectionWhereInput
    some?: GmailTenantConnectionWhereInput
    none?: GmailTenantConnectionWhereInput
  }

  export type Ms365TenantConnectionListRelationFilter = {
    every?: Ms365TenantConnectionWhereInput
    some?: Ms365TenantConnectionWhereInput
    none?: Ms365TenantConnectionWhereInput
  }

  export type PasswordResetTokenNullableScalarRelationFilter = {
    is?: PasswordResetTokenWhereInput | null
    isNot?: PasswordResetTokenWhereInput | null
  }

  export type GmailTenantConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Ms365TenantConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OpportunityNullableScalarRelationFilter = {
    is?: OpportunityWhereInput | null
    isNot?: OpportunityWhereInput | null
  }

  export type FollowUpLogListRelationFilter = {
    every?: FollowUpLogWhereInput
    some?: FollowUpLogWhereInput
    none?: FollowUpLogWhereInput
  }

  export type FollowUpLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    status?: SortOrder
    capturedAt?: SortOrder
    nextActionAt?: SortOrder
    nextAction?: SortOrder
    briefJson?: SortOrder
    custom?: SortOrder
    description?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    status?: SortOrder
    capturedAt?: SortOrder
    nextActionAt?: SortOrder
    nextAction?: SortOrder
    description?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    status?: SortOrder
    capturedAt?: SortOrder
    nextActionAt?: SortOrder
    nextAction?: SortOrder
    description?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumOppStageFilter<$PrismaModel = never> = {
    equals?: $Enums.OppStage | EnumOppStageFieldRefInput<$PrismaModel>
    in?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOppStageFilter<$PrismaModel> | $Enums.OppStage
  }

  export type LeadScalarRelationFilter = {
    is?: LeadWhereInput
    isNot?: LeadWhereInput
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    valueGBP?: SortOrder
    stage?: SortOrder
    wonAt?: SortOrder
    lostAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OpportunityAvgOrderByAggregateInput = {
    valueGBP?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    valueGBP?: SortOrder
    stage?: SortOrder
    wonAt?: SortOrder
    lostAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    valueGBP?: SortOrder
    stage?: SortOrder
    wonAt?: SortOrder
    lostAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OpportunitySumOrderByAggregateInput = {
    valueGBP?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumOppStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OppStage | EnumOppStageFieldRefInput<$PrismaModel>
    in?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOppStageWithAggregatesFilter<$PrismaModel> | $Enums.OppStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOppStageFilter<$PrismaModel>
    _max?: NestedEnumOppStageFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type LeadNullableScalarRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type EmailIngestTenantId_provider_messageIdCompoundUniqueInput = {
    tenantId: string
    provider: string
    messageId: string
  }

  export type EmailIngestCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    processedAt?: SortOrder
    leadId?: SortOrder
    aiPredictedIsLead?: SortOrder
    userLabelIsLead?: SortOrder
    userLabeledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailIngestMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    processedAt?: SortOrder
    leadId?: SortOrder
    aiPredictedIsLead?: SortOrder
    userLabelIsLead?: SortOrder
    userLabeledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailIngestMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    processedAt?: SortOrder
    leadId?: SortOrder
    aiPredictedIsLead?: SortOrder
    userLabelIsLead?: SortOrder
    userLabeledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LeadFieldDefTenantIdKeyCompoundUniqueInput = {
    tenantId: string
    key: string
  }

  export type LeadFieldDefCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    config?: SortOrder
    sortOrder?: SortOrder
  }

  export type LeadFieldDefAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type LeadFieldDefMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
  }

  export type LeadFieldDefMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
  }

  export type LeadFieldDefSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type GmailTenantConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrder
    gmailAddress?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailTenantConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrder
    gmailAddress?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailTenantConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrder
    gmailAddress?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Ms365TenantConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrder
    ms365Address?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Ms365TenantConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrder
    ms365Address?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Ms365TenantConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    connectedById?: SortOrder
    ms365Address?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeadLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadLabel | EnumLeadLabelFieldRefInput<$PrismaModel>
    in?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadLabelFilter<$PrismaModel> | $Enums.LeadLabel
  }

  export type LeadExampleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    extracted?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadExampleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadExampleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLeadLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadLabel | EnumLeadLabelFieldRefInput<$PrismaModel>
    in?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadLabelWithAggregatesFilter<$PrismaModel> | $Enums.LeadLabel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadLabelFilter<$PrismaModel>
    _max?: NestedEnumLeadLabelFilter<$PrismaModel>
  }

  export type LeadTrainingExampleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    label?: SortOrder
    extracted?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadTrainingExampleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadTrainingExampleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type TenantSettingsCountOrderByAggregateInput = {
    tenantId?: SortOrder
    slug?: SortOrder
    brandName?: SortOrder
    introHtml?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    logoUrl?: SortOrder
    links?: SortOrder
    questionnaire?: SortOrder
    inbox?: SortOrder
    inboxWatchEnabled?: SortOrder
    inboxLastRun?: SortOrder
    quoteDefaults?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsMaxOrderByAggregateInput = {
    tenantId?: SortOrder
    slug?: SortOrder
    brandName?: SortOrder
    introHtml?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    logoUrl?: SortOrder
    inboxWatchEnabled?: SortOrder
    inboxLastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsMinOrderByAggregateInput = {
    tenantId?: SortOrder
    slug?: SortOrder
    brandName?: SortOrder
    introHtml?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    logoUrl?: SortOrder
    inboxWatchEnabled?: SortOrder
    inboxLastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FollowUpLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    variant?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    replied?: SortOrder
    converted?: SortOrder
    delayDays?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    threadId?: SortOrder
  }

  export type FollowUpLogAvgOrderByAggregateInput = {
    delayDays?: SortOrder
  }

  export type FollowUpLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    variant?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    replied?: SortOrder
    converted?: SortOrder
    delayDays?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    threadId?: SortOrder
  }

  export type FollowUpLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    variant?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    replied?: SortOrder
    converted?: SortOrder
    delayDays?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    threadId?: SortOrder
  }

  export type FollowUpLogSumOrderByAggregateInput = {
    delayDays?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LeadSourceCostTenantIdSourceMonthCompoundUniqueInput = {
    tenantId: string
    source: string
    month: Date | string
  }

  export type LeadSourceCostCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    conversions?: SortOrder
    scalable?: SortOrder
  }

  export type LeadSourceCostAvgOrderByAggregateInput = {
    spend?: SortOrder
    leads?: SortOrder
    conversions?: SortOrder
  }

  export type LeadSourceCostMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    conversions?: SortOrder
    scalable?: SortOrder
  }

  export type LeadSourceCostMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    spend?: SortOrder
    leads?: SortOrder
    conversions?: SortOrder
    scalable?: SortOrder
  }

  export type LeadSourceCostSumOrderByAggregateInput = {
    spend?: SortOrder
    leads?: SortOrder
    conversions?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type LeadSourceSpendCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    amountGBP?: SortOrder
  }

  export type LeadSourceSpendAvgOrderByAggregateInput = {
    amountGBP?: SortOrder
  }

  export type LeadSourceSpendMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    amountGBP?: SortOrder
  }

  export type LeadSourceSpendMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    month?: SortOrder
    amountGBP?: SortOrder
  }

  export type LeadSourceSpendSumOrderByAggregateInput = {
    amountGBP?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type LeadSourceConfigTenantIdSourceCompoundUniqueInput = {
    tenantId: string
    source: string
  }

  export type LeadSourceConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    scalable?: SortOrder
  }

  export type LeadSourceConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    scalable?: SortOrder
  }

  export type LeadSourceConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    source?: SortOrder
    scalable?: SortOrder
  }

  export type FollowupExperimentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    opportunityId?: SortOrder
    variant?: SortOrder
    source?: SortOrder
    suggestedAt?: SortOrder
    whenISO?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    replied?: SortOrder
    outcome?: SortOrder
  }

  export type FollowupExperimentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    opportunityId?: SortOrder
    variant?: SortOrder
    source?: SortOrder
    suggestedAt?: SortOrder
    whenISO?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    replied?: SortOrder
    outcome?: SortOrder
  }

  export type FollowupExperimentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    opportunityId?: SortOrder
    variant?: SortOrder
    source?: SortOrder
    suggestedAt?: SortOrder
    whenISO?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    sentAt?: SortOrder
    replied?: SortOrder
    outcome?: SortOrder
  }

  export type EmailThreadTenantIdProviderThreadIdCompoundUniqueInput = {
    tenantId: string
    provider: string
    threadId: string
  }

  export type EmailThreadCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    threadId?: SortOrder
    subject?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
    lastInboundAt?: SortOrder
    lastOutboundAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    threadId?: SortOrder
    subject?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
    lastInboundAt?: SortOrder
    lastOutboundAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailThreadMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    threadId?: SortOrder
    subject?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
    lastInboundAt?: SortOrder
    lastOutboundAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailThreadScalarRelationFilter = {
    is?: EmailThreadWhereInput
    isNot?: EmailThreadWhereInput
  }

  export type EmailMessageTenantIdProviderMessageIdCompoundUniqueInput = {
    tenantId: string
    provider: string
    messageId: string
  }

  export type EmailMessageCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    threadId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrder
    direction?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
  }

  export type EmailMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    threadId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrder
    direction?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
  }

  export type EmailMessageMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    threadId?: SortOrder
    provider?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    bodyText?: SortOrder
    bodyHtml?: SortOrder
    direction?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    opportunityId?: SortOrder
  }

  export type EnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type QuoteLineListRelationFilter = {
    every?: QuoteLineWhereInput
    some?: QuoteLineWhereInput
    none?: QuoteLineWhereInput
  }

  export type QuoteLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    deliveryCost?: SortOrder
    markupDefault?: SortOrder
    subtotalMaterialGBP?: SortOrder
    subtotalLabourGBP?: SortOrder
    subtotalOtherGBP?: SortOrder
    totalGBP?: SortOrder
    proposalPdfUrl?: SortOrder
    notes?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    exchangeRate?: SortOrder
    deliveryCost?: SortOrder
    markupDefault?: SortOrder
    subtotalMaterialGBP?: SortOrder
    subtotalLabourGBP?: SortOrder
    subtotalOtherGBP?: SortOrder
    totalGBP?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    deliveryCost?: SortOrder
    markupDefault?: SortOrder
    subtotalMaterialGBP?: SortOrder
    subtotalLabourGBP?: SortOrder
    subtotalOtherGBP?: SortOrder
    totalGBP?: SortOrder
    proposalPdfUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    deliveryCost?: SortOrder
    markupDefault?: SortOrder
    subtotalMaterialGBP?: SortOrder
    subtotalLabourGBP?: SortOrder
    subtotalOtherGBP?: SortOrder
    totalGBP?: SortOrder
    proposalPdfUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    exchangeRate?: SortOrder
    deliveryCost?: SortOrder
    markupDefault?: SortOrder
    subtotalMaterialGBP?: SortOrder
    subtotalLabourGBP?: SortOrder
    subtotalOtherGBP?: SortOrder
    totalGBP?: SortOrder
  }

  export type EnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type QuoteScalarRelationFilter = {
    is?: QuoteWhereInput
    isNot?: QuoteWhereInput
  }

  export type QuoteLineCountOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    supplier?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    deliveryShareGBP?: SortOrder
    lineTotalGBP?: SortOrder
    meta?: SortOrder
  }

  export type QuoteLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    deliveryShareGBP?: SortOrder
    lineTotalGBP?: SortOrder
  }

  export type QuoteLineMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    supplier?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    deliveryShareGBP?: SortOrder
    lineTotalGBP?: SortOrder
  }

  export type QuoteLineMinOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    supplier?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    deliveryShareGBP?: SortOrder
    lineTotalGBP?: SortOrder
  }

  export type QuoteLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    deliveryShareGBP?: SortOrder
    lineTotalGBP?: SortOrder
  }

  export type EnumFileKindFilter<$PrismaModel = never> = {
    equals?: $Enums.FileKind | EnumFileKindFieldRefInput<$PrismaModel>
    in?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    not?: NestedEnumFileKindFilter<$PrismaModel> | $Enums.FileKind
  }

  export type QuoteNullableScalarRelationFilter = {
    is?: QuoteWhereInput | null
    isNot?: QuoteWhereInput | null
  }

  export type UploadedFileCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    quoteId?: SortOrder
    kind?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    uploadedAt?: SortOrder
  }

  export type UploadedFileAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type UploadedFileMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    quoteId?: SortOrder
    kind?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    uploadedAt?: SortOrder
  }

  export type UploadedFileMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    quoteId?: SortOrder
    kind?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    uploadedAt?: SortOrder
  }

  export type UploadedFileSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type EnumFileKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileKind | EnumFileKindFieldRefInput<$PrismaModel>
    in?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    not?: NestedEnumFileKindWithAggregatesFilter<$PrismaModel> | $Enums.FileKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileKindFilter<$PrismaModel>
    _max?: NestedEnumFileKindFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutTenantInput = {
    create?: XOR<OpportunityCreateWithoutTenantInput, OpportunityUncheckedCreateWithoutTenantInput> | OpportunityCreateWithoutTenantInput[] | OpportunityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenantInput | OpportunityCreateOrConnectWithoutTenantInput[]
    createMany?: OpportunityCreateManyTenantInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type LeadFieldDefCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadFieldDefCreateWithoutTenantInput, LeadFieldDefUncheckedCreateWithoutTenantInput> | LeadFieldDefCreateWithoutTenantInput[] | LeadFieldDefUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadFieldDefCreateOrConnectWithoutTenantInput | LeadFieldDefCreateOrConnectWithoutTenantInput[]
    createMany?: LeadFieldDefCreateManyTenantInputEnvelope
    connect?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
  }

  export type GmailTenantConnectionCreateNestedOneWithoutTenantInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutTenantInput, GmailTenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutTenantInput
    connect?: GmailTenantConnectionWhereUniqueInput
  }

  export type Ms365TenantConnectionCreateNestedOneWithoutTenantInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutTenantInput, Ms365TenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutTenantInput
    connect?: Ms365TenantConnectionWhereUniqueInput
  }

  export type EmailIngestCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmailIngestCreateWithoutTenantInput, EmailIngestUncheckedCreateWithoutTenantInput> | EmailIngestCreateWithoutTenantInput[] | EmailIngestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutTenantInput | EmailIngestCreateOrConnectWithoutTenantInput[]
    createMany?: EmailIngestCreateManyTenantInputEnvelope
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
  }

  export type EmailThreadCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmailThreadCreateWithoutTenantInput, EmailThreadUncheckedCreateWithoutTenantInput> | EmailThreadCreateWithoutTenantInput[] | EmailThreadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTenantInput | EmailThreadCreateOrConnectWithoutTenantInput[]
    createMany?: EmailThreadCreateManyTenantInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type EmailMessageCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmailMessageCreateWithoutTenantInput, EmailMessageUncheckedCreateWithoutTenantInput> | EmailMessageCreateWithoutTenantInput[] | EmailMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTenantInput | EmailMessageCreateOrConnectWithoutTenantInput[]
    createMany?: EmailMessageCreateManyTenantInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutTenantInput = {
    create?: XOR<QuoteCreateWithoutTenantInput, QuoteUncheckedCreateWithoutTenantInput> | QuoteCreateWithoutTenantInput[] | QuoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutTenantInput | QuoteCreateOrConnectWithoutTenantInput[]
    createMany?: QuoteCreateManyTenantInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type UploadedFileCreateNestedManyWithoutTenantInput = {
    create?: XOR<UploadedFileCreateWithoutTenantInput, UploadedFileUncheckedCreateWithoutTenantInput> | UploadedFileCreateWithoutTenantInput[] | UploadedFileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutTenantInput | UploadedFileCreateOrConnectWithoutTenantInput[]
    createMany?: UploadedFileCreateManyTenantInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OpportunityCreateWithoutTenantInput, OpportunityUncheckedCreateWithoutTenantInput> | OpportunityCreateWithoutTenantInput[] | OpportunityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenantInput | OpportunityCreateOrConnectWithoutTenantInput[]
    createMany?: OpportunityCreateManyTenantInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadFieldDefCreateWithoutTenantInput, LeadFieldDefUncheckedCreateWithoutTenantInput> | LeadFieldDefCreateWithoutTenantInput[] | LeadFieldDefUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadFieldDefCreateOrConnectWithoutTenantInput | LeadFieldDefCreateOrConnectWithoutTenantInput[]
    createMany?: LeadFieldDefCreateManyTenantInputEnvelope
    connect?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
  }

  export type GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutTenantInput, GmailTenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutTenantInput
    connect?: GmailTenantConnectionWhereUniqueInput
  }

  export type Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutTenantInput, Ms365TenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutTenantInput
    connect?: Ms365TenantConnectionWhereUniqueInput
  }

  export type EmailIngestUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmailIngestCreateWithoutTenantInput, EmailIngestUncheckedCreateWithoutTenantInput> | EmailIngestCreateWithoutTenantInput[] | EmailIngestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutTenantInput | EmailIngestCreateOrConnectWithoutTenantInput[]
    createMany?: EmailIngestCreateManyTenantInputEnvelope
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
  }

  export type EmailThreadUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmailThreadCreateWithoutTenantInput, EmailThreadUncheckedCreateWithoutTenantInput> | EmailThreadCreateWithoutTenantInput[] | EmailThreadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTenantInput | EmailThreadCreateOrConnectWithoutTenantInput[]
    createMany?: EmailThreadCreateManyTenantInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmailMessageCreateWithoutTenantInput, EmailMessageUncheckedCreateWithoutTenantInput> | EmailMessageCreateWithoutTenantInput[] | EmailMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTenantInput | EmailMessageCreateOrConnectWithoutTenantInput[]
    createMany?: EmailMessageCreateManyTenantInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<QuoteCreateWithoutTenantInput, QuoteUncheckedCreateWithoutTenantInput> | QuoteCreateWithoutTenantInput[] | QuoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutTenantInput | QuoteCreateOrConnectWithoutTenantInput[]
    createMany?: QuoteCreateManyTenantInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type UploadedFileUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UploadedFileCreateWithoutTenantInput, UploadedFileUncheckedCreateWithoutTenantInput> | UploadedFileCreateWithoutTenantInput[] | UploadedFileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutTenantInput | UploadedFileCreateOrConnectWithoutTenantInput[]
    createMany?: UploadedFileCreateManyTenantInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus | null
  }

  export type NullableEnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OpportunityCreateWithoutTenantInput, OpportunityUncheckedCreateWithoutTenantInput> | OpportunityCreateWithoutTenantInput[] | OpportunityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenantInput | OpportunityCreateOrConnectWithoutTenantInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutTenantInput | OpportunityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OpportunityCreateManyTenantInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutTenantInput | OpportunityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutTenantInput | OpportunityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type LeadFieldDefUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadFieldDefCreateWithoutTenantInput, LeadFieldDefUncheckedCreateWithoutTenantInput> | LeadFieldDefCreateWithoutTenantInput[] | LeadFieldDefUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadFieldDefCreateOrConnectWithoutTenantInput | LeadFieldDefCreateOrConnectWithoutTenantInput[]
    upsert?: LeadFieldDefUpsertWithWhereUniqueWithoutTenantInput | LeadFieldDefUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadFieldDefCreateManyTenantInputEnvelope
    set?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    disconnect?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    delete?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    connect?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    update?: LeadFieldDefUpdateWithWhereUniqueWithoutTenantInput | LeadFieldDefUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadFieldDefUpdateManyWithWhereWithoutTenantInput | LeadFieldDefUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadFieldDefScalarWhereInput | LeadFieldDefScalarWhereInput[]
  }

  export type GmailTenantConnectionUpdateOneWithoutTenantNestedInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutTenantInput, GmailTenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutTenantInput
    upsert?: GmailTenantConnectionUpsertWithoutTenantInput
    disconnect?: GmailTenantConnectionWhereInput | boolean
    delete?: GmailTenantConnectionWhereInput | boolean
    connect?: GmailTenantConnectionWhereUniqueInput
    update?: XOR<XOR<GmailTenantConnectionUpdateToOneWithWhereWithoutTenantInput, GmailTenantConnectionUpdateWithoutTenantInput>, GmailTenantConnectionUncheckedUpdateWithoutTenantInput>
  }

  export type Ms365TenantConnectionUpdateOneWithoutTenantNestedInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutTenantInput, Ms365TenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutTenantInput
    upsert?: Ms365TenantConnectionUpsertWithoutTenantInput
    disconnect?: Ms365TenantConnectionWhereInput | boolean
    delete?: Ms365TenantConnectionWhereInput | boolean
    connect?: Ms365TenantConnectionWhereUniqueInput
    update?: XOR<XOR<Ms365TenantConnectionUpdateToOneWithWhereWithoutTenantInput, Ms365TenantConnectionUpdateWithoutTenantInput>, Ms365TenantConnectionUncheckedUpdateWithoutTenantInput>
  }

  export type EmailIngestUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmailIngestCreateWithoutTenantInput, EmailIngestUncheckedCreateWithoutTenantInput> | EmailIngestCreateWithoutTenantInput[] | EmailIngestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutTenantInput | EmailIngestCreateOrConnectWithoutTenantInput[]
    upsert?: EmailIngestUpsertWithWhereUniqueWithoutTenantInput | EmailIngestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmailIngestCreateManyTenantInputEnvelope
    set?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    disconnect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    delete?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    update?: EmailIngestUpdateWithWhereUniqueWithoutTenantInput | EmailIngestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmailIngestUpdateManyWithWhereWithoutTenantInput | EmailIngestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmailIngestScalarWhereInput | EmailIngestScalarWhereInput[]
  }

  export type EmailThreadUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmailThreadCreateWithoutTenantInput, EmailThreadUncheckedCreateWithoutTenantInput> | EmailThreadCreateWithoutTenantInput[] | EmailThreadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTenantInput | EmailThreadCreateOrConnectWithoutTenantInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutTenantInput | EmailThreadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmailThreadCreateManyTenantInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutTenantInput | EmailThreadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutTenantInput | EmailThreadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type EmailMessageUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmailMessageCreateWithoutTenantInput, EmailMessageUncheckedCreateWithoutTenantInput> | EmailMessageCreateWithoutTenantInput[] | EmailMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTenantInput | EmailMessageCreateOrConnectWithoutTenantInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutTenantInput | EmailMessageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmailMessageCreateManyTenantInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutTenantInput | EmailMessageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutTenantInput | EmailMessageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutTenantNestedInput = {
    create?: XOR<QuoteCreateWithoutTenantInput, QuoteUncheckedCreateWithoutTenantInput> | QuoteCreateWithoutTenantInput[] | QuoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutTenantInput | QuoteCreateOrConnectWithoutTenantInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutTenantInput | QuoteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: QuoteCreateManyTenantInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutTenantInput | QuoteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutTenantInput | QuoteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type UploadedFileUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UploadedFileCreateWithoutTenantInput, UploadedFileUncheckedCreateWithoutTenantInput> | UploadedFileCreateWithoutTenantInput[] | UploadedFileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutTenantInput | UploadedFileCreateOrConnectWithoutTenantInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutTenantInput | UploadedFileUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UploadedFileCreateManyTenantInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutTenantInput | UploadedFileUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutTenantInput | UploadedFileUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OpportunityCreateWithoutTenantInput, OpportunityUncheckedCreateWithoutTenantInput> | OpportunityCreateWithoutTenantInput[] | OpportunityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenantInput | OpportunityCreateOrConnectWithoutTenantInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutTenantInput | OpportunityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OpportunityCreateManyTenantInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutTenantInput | OpportunityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutTenantInput | OpportunityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadFieldDefCreateWithoutTenantInput, LeadFieldDefUncheckedCreateWithoutTenantInput> | LeadFieldDefCreateWithoutTenantInput[] | LeadFieldDefUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadFieldDefCreateOrConnectWithoutTenantInput | LeadFieldDefCreateOrConnectWithoutTenantInput[]
    upsert?: LeadFieldDefUpsertWithWhereUniqueWithoutTenantInput | LeadFieldDefUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadFieldDefCreateManyTenantInputEnvelope
    set?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    disconnect?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    delete?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    connect?: LeadFieldDefWhereUniqueInput | LeadFieldDefWhereUniqueInput[]
    update?: LeadFieldDefUpdateWithWhereUniqueWithoutTenantInput | LeadFieldDefUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadFieldDefUpdateManyWithWhereWithoutTenantInput | LeadFieldDefUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadFieldDefScalarWhereInput | LeadFieldDefScalarWhereInput[]
  }

  export type GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutTenantInput, GmailTenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutTenantInput
    upsert?: GmailTenantConnectionUpsertWithoutTenantInput
    disconnect?: GmailTenantConnectionWhereInput | boolean
    delete?: GmailTenantConnectionWhereInput | boolean
    connect?: GmailTenantConnectionWhereUniqueInput
    update?: XOR<XOR<GmailTenantConnectionUpdateToOneWithWhereWithoutTenantInput, GmailTenantConnectionUpdateWithoutTenantInput>, GmailTenantConnectionUncheckedUpdateWithoutTenantInput>
  }

  export type Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutTenantInput, Ms365TenantConnectionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutTenantInput
    upsert?: Ms365TenantConnectionUpsertWithoutTenantInput
    disconnect?: Ms365TenantConnectionWhereInput | boolean
    delete?: Ms365TenantConnectionWhereInput | boolean
    connect?: Ms365TenantConnectionWhereUniqueInput
    update?: XOR<XOR<Ms365TenantConnectionUpdateToOneWithWhereWithoutTenantInput, Ms365TenantConnectionUpdateWithoutTenantInput>, Ms365TenantConnectionUncheckedUpdateWithoutTenantInput>
  }

  export type EmailIngestUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmailIngestCreateWithoutTenantInput, EmailIngestUncheckedCreateWithoutTenantInput> | EmailIngestCreateWithoutTenantInput[] | EmailIngestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutTenantInput | EmailIngestCreateOrConnectWithoutTenantInput[]
    upsert?: EmailIngestUpsertWithWhereUniqueWithoutTenantInput | EmailIngestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmailIngestCreateManyTenantInputEnvelope
    set?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    disconnect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    delete?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    update?: EmailIngestUpdateWithWhereUniqueWithoutTenantInput | EmailIngestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmailIngestUpdateManyWithWhereWithoutTenantInput | EmailIngestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmailIngestScalarWhereInput | EmailIngestScalarWhereInput[]
  }

  export type EmailThreadUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmailThreadCreateWithoutTenantInput, EmailThreadUncheckedCreateWithoutTenantInput> | EmailThreadCreateWithoutTenantInput[] | EmailThreadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTenantInput | EmailThreadCreateOrConnectWithoutTenantInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutTenantInput | EmailThreadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmailThreadCreateManyTenantInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutTenantInput | EmailThreadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutTenantInput | EmailThreadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmailMessageCreateWithoutTenantInput, EmailMessageUncheckedCreateWithoutTenantInput> | EmailMessageCreateWithoutTenantInput[] | EmailMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutTenantInput | EmailMessageCreateOrConnectWithoutTenantInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutTenantInput | EmailMessageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmailMessageCreateManyTenantInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutTenantInput | EmailMessageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutTenantInput | EmailMessageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<QuoteCreateWithoutTenantInput, QuoteUncheckedCreateWithoutTenantInput> | QuoteCreateWithoutTenantInput[] | QuoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutTenantInput | QuoteCreateOrConnectWithoutTenantInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutTenantInput | QuoteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: QuoteCreateManyTenantInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutTenantInput | QuoteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutTenantInput | QuoteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type UploadedFileUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UploadedFileCreateWithoutTenantInput, UploadedFileUncheckedCreateWithoutTenantInput> | UploadedFileCreateWithoutTenantInput[] | UploadedFileUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutTenantInput | UploadedFileCreateOrConnectWithoutTenantInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutTenantInput | UploadedFileUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UploadedFileCreateManyTenantInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutTenantInput | UploadedFileUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutTenantInput | UploadedFileUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type GmailTenantConnectionCreateNestedManyWithoutConnectedByInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutConnectedByInput, GmailTenantConnectionUncheckedCreateWithoutConnectedByInput> | GmailTenantConnectionCreateWithoutConnectedByInput[] | GmailTenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutConnectedByInput | GmailTenantConnectionCreateOrConnectWithoutConnectedByInput[]
    createMany?: GmailTenantConnectionCreateManyConnectedByInputEnvelope
    connect?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
  }

  export type Ms365TenantConnectionCreateNestedManyWithoutConnectedByInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutConnectedByInput, Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput> | Ms365TenantConnectionCreateWithoutConnectedByInput[] | Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput | Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput[]
    createMany?: Ms365TenantConnectionCreateManyConnectedByInputEnvelope
    connect?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    connect?: PasswordResetTokenWhereUniqueInput
  }

  export type GmailTenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutConnectedByInput, GmailTenantConnectionUncheckedCreateWithoutConnectedByInput> | GmailTenantConnectionCreateWithoutConnectedByInput[] | GmailTenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutConnectedByInput | GmailTenantConnectionCreateOrConnectWithoutConnectedByInput[]
    createMany?: GmailTenantConnectionCreateManyConnectedByInputEnvelope
    connect?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
  }

  export type Ms365TenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutConnectedByInput, Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput> | Ms365TenantConnectionCreateWithoutConnectedByInput[] | Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput | Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput[]
    createMany?: Ms365TenantConnectionCreateManyConnectedByInputEnvelope
    connect?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    connect?: PasswordResetTokenWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type GmailTenantConnectionUpdateManyWithoutConnectedByNestedInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutConnectedByInput, GmailTenantConnectionUncheckedCreateWithoutConnectedByInput> | GmailTenantConnectionCreateWithoutConnectedByInput[] | GmailTenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutConnectedByInput | GmailTenantConnectionCreateOrConnectWithoutConnectedByInput[]
    upsert?: GmailTenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput | GmailTenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput[]
    createMany?: GmailTenantConnectionCreateManyConnectedByInputEnvelope
    set?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    disconnect?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    delete?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    connect?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    update?: GmailTenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput | GmailTenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput[]
    updateMany?: GmailTenantConnectionUpdateManyWithWhereWithoutConnectedByInput | GmailTenantConnectionUpdateManyWithWhereWithoutConnectedByInput[]
    deleteMany?: GmailTenantConnectionScalarWhereInput | GmailTenantConnectionScalarWhereInput[]
  }

  export type Ms365TenantConnectionUpdateManyWithoutConnectedByNestedInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutConnectedByInput, Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput> | Ms365TenantConnectionCreateWithoutConnectedByInput[] | Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput | Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput[]
    upsert?: Ms365TenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput | Ms365TenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput[]
    createMany?: Ms365TenantConnectionCreateManyConnectedByInputEnvelope
    set?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    disconnect?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    delete?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    connect?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    update?: Ms365TenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput | Ms365TenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput[]
    updateMany?: Ms365TenantConnectionUpdateManyWithWhereWithoutConnectedByInput | Ms365TenantConnectionUpdateManyWithWhereWithoutConnectedByInput[]
    deleteMany?: Ms365TenantConnectionScalarWhereInput | Ms365TenantConnectionScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    upsert?: PasswordResetTokenUpsertWithoutUserInput
    disconnect?: PasswordResetTokenWhereInput | boolean
    delete?: PasswordResetTokenWhereInput | boolean
    connect?: PasswordResetTokenWhereUniqueInput
    update?: XOR<XOR<PasswordResetTokenUpdateToOneWithWhereWithoutUserInput, PasswordResetTokenUpdateWithoutUserInput>, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type GmailTenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput = {
    create?: XOR<GmailTenantConnectionCreateWithoutConnectedByInput, GmailTenantConnectionUncheckedCreateWithoutConnectedByInput> | GmailTenantConnectionCreateWithoutConnectedByInput[] | GmailTenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: GmailTenantConnectionCreateOrConnectWithoutConnectedByInput | GmailTenantConnectionCreateOrConnectWithoutConnectedByInput[]
    upsert?: GmailTenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput | GmailTenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput[]
    createMany?: GmailTenantConnectionCreateManyConnectedByInputEnvelope
    set?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    disconnect?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    delete?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    connect?: GmailTenantConnectionWhereUniqueInput | GmailTenantConnectionWhereUniqueInput[]
    update?: GmailTenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput | GmailTenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput[]
    updateMany?: GmailTenantConnectionUpdateManyWithWhereWithoutConnectedByInput | GmailTenantConnectionUpdateManyWithWhereWithoutConnectedByInput[]
    deleteMany?: GmailTenantConnectionScalarWhereInput | GmailTenantConnectionScalarWhereInput[]
  }

  export type Ms365TenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput = {
    create?: XOR<Ms365TenantConnectionCreateWithoutConnectedByInput, Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput> | Ms365TenantConnectionCreateWithoutConnectedByInput[] | Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput | Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput[]
    upsert?: Ms365TenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput | Ms365TenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput[]
    createMany?: Ms365TenantConnectionCreateManyConnectedByInputEnvelope
    set?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    disconnect?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    delete?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    connect?: Ms365TenantConnectionWhereUniqueInput | Ms365TenantConnectionWhereUniqueInput[]
    update?: Ms365TenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput | Ms365TenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput[]
    updateMany?: Ms365TenantConnectionUpdateManyWithWhereWithoutConnectedByInput | Ms365TenantConnectionUpdateManyWithWhereWithoutConnectedByInput[]
    deleteMany?: Ms365TenantConnectionScalarWhereInput | Ms365TenantConnectionScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    upsert?: PasswordResetTokenUpsertWithoutUserInput
    disconnect?: PasswordResetTokenWhereInput | boolean
    delete?: PasswordResetTokenWhereInput | boolean
    connect?: PasswordResetTokenWhereUniqueInput
    update?: XOR<XOR<PasswordResetTokenUpdateToOneWithWhereWithoutUserInput, PasswordResetTokenUpdateWithoutUserInput>, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type TenantCreateNestedOneWithoutLeadsInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    connect?: TenantWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutLeadInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput
    connect?: OpportunityWhereUniqueInput
  }

  export type EmailIngestCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailIngestCreateWithoutLeadInput, EmailIngestUncheckedCreateWithoutLeadInput> | EmailIngestCreateWithoutLeadInput[] | EmailIngestUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutLeadInput | EmailIngestCreateOrConnectWithoutLeadInput[]
    createMany?: EmailIngestCreateManyLeadInputEnvelope
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
  }

  export type FollowUpLogCreateNestedManyWithoutLeadInput = {
    create?: XOR<FollowUpLogCreateWithoutLeadInput, FollowUpLogUncheckedCreateWithoutLeadInput> | FollowUpLogCreateWithoutLeadInput[] | FollowUpLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: FollowUpLogCreateOrConnectWithoutLeadInput | FollowUpLogCreateOrConnectWithoutLeadInput[]
    createMany?: FollowUpLogCreateManyLeadInputEnvelope
    connect?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
  }

  export type EmailThreadCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailThreadCreateWithoutLeadInput, EmailThreadUncheckedCreateWithoutLeadInput> | EmailThreadCreateWithoutLeadInput[] | EmailThreadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutLeadInput | EmailThreadCreateOrConnectWithoutLeadInput[]
    createMany?: EmailThreadCreateManyLeadInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type EmailMessageCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailMessageCreateWithoutLeadInput, EmailMessageUncheckedCreateWithoutLeadInput> | EmailMessageCreateWithoutLeadInput[] | EmailMessageUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutLeadInput | EmailMessageCreateOrConnectWithoutLeadInput[]
    createMany?: EmailMessageCreateManyLeadInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutLeadInput = {
    create?: XOR<QuoteCreateWithoutLeadInput, QuoteUncheckedCreateWithoutLeadInput> | QuoteCreateWithoutLeadInput[] | QuoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutLeadInput | QuoteCreateOrConnectWithoutLeadInput[]
    createMany?: QuoteCreateManyLeadInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedOneWithoutLeadInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput
    connect?: OpportunityWhereUniqueInput
  }

  export type EmailIngestUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailIngestCreateWithoutLeadInput, EmailIngestUncheckedCreateWithoutLeadInput> | EmailIngestCreateWithoutLeadInput[] | EmailIngestUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutLeadInput | EmailIngestCreateOrConnectWithoutLeadInput[]
    createMany?: EmailIngestCreateManyLeadInputEnvelope
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
  }

  export type FollowUpLogUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<FollowUpLogCreateWithoutLeadInput, FollowUpLogUncheckedCreateWithoutLeadInput> | FollowUpLogCreateWithoutLeadInput[] | FollowUpLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: FollowUpLogCreateOrConnectWithoutLeadInput | FollowUpLogCreateOrConnectWithoutLeadInput[]
    createMany?: FollowUpLogCreateManyLeadInputEnvelope
    connect?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
  }

  export type EmailThreadUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailThreadCreateWithoutLeadInput, EmailThreadUncheckedCreateWithoutLeadInput> | EmailThreadCreateWithoutLeadInput[] | EmailThreadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutLeadInput | EmailThreadCreateOrConnectWithoutLeadInput[]
    createMany?: EmailThreadCreateManyLeadInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<EmailMessageCreateWithoutLeadInput, EmailMessageUncheckedCreateWithoutLeadInput> | EmailMessageCreateWithoutLeadInput[] | EmailMessageUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutLeadInput | EmailMessageCreateOrConnectWithoutLeadInput[]
    createMany?: EmailMessageCreateManyLeadInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<QuoteCreateWithoutLeadInput, QuoteUncheckedCreateWithoutLeadInput> | QuoteCreateWithoutLeadInput[] | QuoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutLeadInput | QuoteCreateOrConnectWithoutLeadInput[]
    createMany?: QuoteCreateManyLeadInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type TenantUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    upsert?: TenantUpsertWithoutLeadsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeadsInput, TenantUpdateWithoutLeadsInput>, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type OpportunityUpdateOneWithoutLeadNestedInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput
    upsert?: OpportunityUpsertWithoutLeadInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutLeadInput, OpportunityUpdateWithoutLeadInput>, OpportunityUncheckedUpdateWithoutLeadInput>
  }

  export type EmailIngestUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailIngestCreateWithoutLeadInput, EmailIngestUncheckedCreateWithoutLeadInput> | EmailIngestCreateWithoutLeadInput[] | EmailIngestUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutLeadInput | EmailIngestCreateOrConnectWithoutLeadInput[]
    upsert?: EmailIngestUpsertWithWhereUniqueWithoutLeadInput | EmailIngestUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailIngestCreateManyLeadInputEnvelope
    set?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    disconnect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    delete?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    update?: EmailIngestUpdateWithWhereUniqueWithoutLeadInput | EmailIngestUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailIngestUpdateManyWithWhereWithoutLeadInput | EmailIngestUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailIngestScalarWhereInput | EmailIngestScalarWhereInput[]
  }

  export type FollowUpLogUpdateManyWithoutLeadNestedInput = {
    create?: XOR<FollowUpLogCreateWithoutLeadInput, FollowUpLogUncheckedCreateWithoutLeadInput> | FollowUpLogCreateWithoutLeadInput[] | FollowUpLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: FollowUpLogCreateOrConnectWithoutLeadInput | FollowUpLogCreateOrConnectWithoutLeadInput[]
    upsert?: FollowUpLogUpsertWithWhereUniqueWithoutLeadInput | FollowUpLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: FollowUpLogCreateManyLeadInputEnvelope
    set?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    disconnect?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    delete?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    connect?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    update?: FollowUpLogUpdateWithWhereUniqueWithoutLeadInput | FollowUpLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: FollowUpLogUpdateManyWithWhereWithoutLeadInput | FollowUpLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: FollowUpLogScalarWhereInput | FollowUpLogScalarWhereInput[]
  }

  export type EmailThreadUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailThreadCreateWithoutLeadInput, EmailThreadUncheckedCreateWithoutLeadInput> | EmailThreadCreateWithoutLeadInput[] | EmailThreadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutLeadInput | EmailThreadCreateOrConnectWithoutLeadInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutLeadInput | EmailThreadUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailThreadCreateManyLeadInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutLeadInput | EmailThreadUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutLeadInput | EmailThreadUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type EmailMessageUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailMessageCreateWithoutLeadInput, EmailMessageUncheckedCreateWithoutLeadInput> | EmailMessageCreateWithoutLeadInput[] | EmailMessageUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutLeadInput | EmailMessageCreateOrConnectWithoutLeadInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutLeadInput | EmailMessageUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailMessageCreateManyLeadInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutLeadInput | EmailMessageUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutLeadInput | EmailMessageUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutLeadNestedInput = {
    create?: XOR<QuoteCreateWithoutLeadInput, QuoteUncheckedCreateWithoutLeadInput> | QuoteCreateWithoutLeadInput[] | QuoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutLeadInput | QuoteCreateOrConnectWithoutLeadInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutLeadInput | QuoteUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: QuoteCreateManyLeadInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutLeadInput | QuoteUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutLeadInput | QuoteUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateOneWithoutLeadNestedInput = {
    create?: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutLeadInput
    upsert?: OpportunityUpsertWithoutLeadInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutLeadInput, OpportunityUpdateWithoutLeadInput>, OpportunityUncheckedUpdateWithoutLeadInput>
  }

  export type EmailIngestUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailIngestCreateWithoutLeadInput, EmailIngestUncheckedCreateWithoutLeadInput> | EmailIngestCreateWithoutLeadInput[] | EmailIngestUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailIngestCreateOrConnectWithoutLeadInput | EmailIngestCreateOrConnectWithoutLeadInput[]
    upsert?: EmailIngestUpsertWithWhereUniqueWithoutLeadInput | EmailIngestUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailIngestCreateManyLeadInputEnvelope
    set?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    disconnect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    delete?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    connect?: EmailIngestWhereUniqueInput | EmailIngestWhereUniqueInput[]
    update?: EmailIngestUpdateWithWhereUniqueWithoutLeadInput | EmailIngestUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailIngestUpdateManyWithWhereWithoutLeadInput | EmailIngestUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailIngestScalarWhereInput | EmailIngestScalarWhereInput[]
  }

  export type FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<FollowUpLogCreateWithoutLeadInput, FollowUpLogUncheckedCreateWithoutLeadInput> | FollowUpLogCreateWithoutLeadInput[] | FollowUpLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: FollowUpLogCreateOrConnectWithoutLeadInput | FollowUpLogCreateOrConnectWithoutLeadInput[]
    upsert?: FollowUpLogUpsertWithWhereUniqueWithoutLeadInput | FollowUpLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: FollowUpLogCreateManyLeadInputEnvelope
    set?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    disconnect?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    delete?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    connect?: FollowUpLogWhereUniqueInput | FollowUpLogWhereUniqueInput[]
    update?: FollowUpLogUpdateWithWhereUniqueWithoutLeadInput | FollowUpLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: FollowUpLogUpdateManyWithWhereWithoutLeadInput | FollowUpLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: FollowUpLogScalarWhereInput | FollowUpLogScalarWhereInput[]
  }

  export type EmailThreadUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailThreadCreateWithoutLeadInput, EmailThreadUncheckedCreateWithoutLeadInput> | EmailThreadCreateWithoutLeadInput[] | EmailThreadUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutLeadInput | EmailThreadCreateOrConnectWithoutLeadInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutLeadInput | EmailThreadUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailThreadCreateManyLeadInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutLeadInput | EmailThreadUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutLeadInput | EmailThreadUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<EmailMessageCreateWithoutLeadInput, EmailMessageUncheckedCreateWithoutLeadInput> | EmailMessageCreateWithoutLeadInput[] | EmailMessageUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutLeadInput | EmailMessageCreateOrConnectWithoutLeadInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutLeadInput | EmailMessageUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: EmailMessageCreateManyLeadInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutLeadInput | EmailMessageUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutLeadInput | EmailMessageUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<QuoteCreateWithoutLeadInput, QuoteUncheckedCreateWithoutLeadInput> | QuoteCreateWithoutLeadInput[] | QuoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutLeadInput | QuoteCreateOrConnectWithoutLeadInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutLeadInput | QuoteUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: QuoteCreateManyLeadInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutLeadInput | QuoteUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutLeadInput | QuoteUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<TenantCreateWithoutOpportunitiesInput, TenantUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOpportunitiesInput
    connect?: TenantWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutOpportunityInput = {
    create?: XOR<LeadCreateWithoutOpportunityInput, LeadUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: LeadCreateOrConnectWithoutOpportunityInput
    connect?: LeadWhereUniqueInput
  }

  export type EmailThreadCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<EmailThreadCreateWithoutOpportunityInput, EmailThreadUncheckedCreateWithoutOpportunityInput> | EmailThreadCreateWithoutOpportunityInput[] | EmailThreadUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutOpportunityInput | EmailThreadCreateOrConnectWithoutOpportunityInput[]
    createMany?: EmailThreadCreateManyOpportunityInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type EmailMessageCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<EmailMessageCreateWithoutOpportunityInput, EmailMessageUncheckedCreateWithoutOpportunityInput> | EmailMessageCreateWithoutOpportunityInput[] | EmailMessageUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutOpportunityInput | EmailMessageCreateOrConnectWithoutOpportunityInput[]
    createMany?: EmailMessageCreateManyOpportunityInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type EmailThreadUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<EmailThreadCreateWithoutOpportunityInput, EmailThreadUncheckedCreateWithoutOpportunityInput> | EmailThreadCreateWithoutOpportunityInput[] | EmailThreadUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutOpportunityInput | EmailThreadCreateOrConnectWithoutOpportunityInput[]
    createMany?: EmailThreadCreateManyOpportunityInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<EmailMessageCreateWithoutOpportunityInput, EmailMessageUncheckedCreateWithoutOpportunityInput> | EmailMessageCreateWithoutOpportunityInput[] | EmailMessageUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutOpportunityInput | EmailMessageCreateOrConnectWithoutOpportunityInput[]
    createMany?: EmailMessageCreateManyOpportunityInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumOppStageFieldUpdateOperationsInput = {
    set?: $Enums.OppStage
  }

  export type TenantUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<TenantCreateWithoutOpportunitiesInput, TenantUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOpportunitiesInput
    upsert?: TenantUpsertWithoutOpportunitiesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOpportunitiesInput, TenantUpdateWithoutOpportunitiesInput>, TenantUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type LeadUpdateOneRequiredWithoutOpportunityNestedInput = {
    create?: XOR<LeadCreateWithoutOpportunityInput, LeadUncheckedCreateWithoutOpportunityInput>
    connectOrCreate?: LeadCreateOrConnectWithoutOpportunityInput
    upsert?: LeadUpsertWithoutOpportunityInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutOpportunityInput, LeadUpdateWithoutOpportunityInput>, LeadUncheckedUpdateWithoutOpportunityInput>
  }

  export type EmailThreadUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<EmailThreadCreateWithoutOpportunityInput, EmailThreadUncheckedCreateWithoutOpportunityInput> | EmailThreadCreateWithoutOpportunityInput[] | EmailThreadUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutOpportunityInput | EmailThreadCreateOrConnectWithoutOpportunityInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutOpportunityInput | EmailThreadUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: EmailThreadCreateManyOpportunityInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutOpportunityInput | EmailThreadUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutOpportunityInput | EmailThreadUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type EmailMessageUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<EmailMessageCreateWithoutOpportunityInput, EmailMessageUncheckedCreateWithoutOpportunityInput> | EmailMessageCreateWithoutOpportunityInput[] | EmailMessageUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutOpportunityInput | EmailMessageCreateOrConnectWithoutOpportunityInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutOpportunityInput | EmailMessageUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: EmailMessageCreateManyOpportunityInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutOpportunityInput | EmailMessageUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutOpportunityInput | EmailMessageUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type EmailThreadUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<EmailThreadCreateWithoutOpportunityInput, EmailThreadUncheckedCreateWithoutOpportunityInput> | EmailThreadCreateWithoutOpportunityInput[] | EmailThreadUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutOpportunityInput | EmailThreadCreateOrConnectWithoutOpportunityInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutOpportunityInput | EmailThreadUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: EmailThreadCreateManyOpportunityInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutOpportunityInput | EmailThreadUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutOpportunityInput | EmailThreadUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<EmailMessageCreateWithoutOpportunityInput, EmailMessageUncheckedCreateWithoutOpportunityInput> | EmailMessageCreateWithoutOpportunityInput[] | EmailMessageUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutOpportunityInput | EmailMessageCreateOrConnectWithoutOpportunityInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutOpportunityInput | EmailMessageUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: EmailMessageCreateManyOpportunityInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutOpportunityInput | EmailMessageUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutOpportunityInput | EmailMessageUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutEmailIngestsInput = {
    create?: XOR<TenantCreateWithoutEmailIngestsInput, TenantUncheckedCreateWithoutEmailIngestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmailIngestsInput
    connect?: TenantWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutEmailIngestsInput = {
    create?: XOR<LeadCreateWithoutEmailIngestsInput, LeadUncheckedCreateWithoutEmailIngestsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailIngestsInput
    connect?: LeadWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TenantUpdateOneRequiredWithoutEmailIngestsNestedInput = {
    create?: XOR<TenantCreateWithoutEmailIngestsInput, TenantUncheckedCreateWithoutEmailIngestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmailIngestsInput
    upsert?: TenantUpsertWithoutEmailIngestsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmailIngestsInput, TenantUpdateWithoutEmailIngestsInput>, TenantUncheckedUpdateWithoutEmailIngestsInput>
  }

  export type LeadUpdateOneWithoutEmailIngestsNestedInput = {
    create?: XOR<LeadCreateWithoutEmailIngestsInput, LeadUncheckedCreateWithoutEmailIngestsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailIngestsInput
    upsert?: LeadUpsertWithoutEmailIngestsInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutEmailIngestsInput, LeadUpdateWithoutEmailIngestsInput>, LeadUncheckedUpdateWithoutEmailIngestsInput>
  }

  export type TenantCreateNestedOneWithoutLeadFieldDefsInput = {
    create?: XOR<TenantCreateWithoutLeadFieldDefsInput, TenantUncheckedCreateWithoutLeadFieldDefsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadFieldDefsInput
    connect?: TenantWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TenantUpdateOneRequiredWithoutLeadFieldDefsNestedInput = {
    create?: XOR<TenantCreateWithoutLeadFieldDefsInput, TenantUncheckedCreateWithoutLeadFieldDefsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadFieldDefsInput
    upsert?: TenantUpsertWithoutLeadFieldDefsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeadFieldDefsInput, TenantUpdateWithoutLeadFieldDefsInput>, TenantUncheckedUpdateWithoutLeadFieldDefsInput>
  }

  export type TenantCreateNestedOneWithoutGmailTenantConnectionInput = {
    create?: XOR<TenantCreateWithoutGmailTenantConnectionInput, TenantUncheckedCreateWithoutGmailTenantConnectionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGmailTenantConnectionInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGmailTenantConnectionInput = {
    create?: XOR<UserCreateWithoutGmailTenantConnectionInput, UserUncheckedCreateWithoutGmailTenantConnectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutGmailTenantConnectionInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutGmailTenantConnectionNestedInput = {
    create?: XOR<TenantCreateWithoutGmailTenantConnectionInput, TenantUncheckedCreateWithoutGmailTenantConnectionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGmailTenantConnectionInput
    upsert?: TenantUpsertWithoutGmailTenantConnectionInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutGmailTenantConnectionInput, TenantUpdateWithoutGmailTenantConnectionInput>, TenantUncheckedUpdateWithoutGmailTenantConnectionInput>
  }

  export type UserUpdateOneWithoutGmailTenantConnectionNestedInput = {
    create?: XOR<UserCreateWithoutGmailTenantConnectionInput, UserUncheckedCreateWithoutGmailTenantConnectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutGmailTenantConnectionInput
    upsert?: UserUpsertWithoutGmailTenantConnectionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGmailTenantConnectionInput, UserUpdateWithoutGmailTenantConnectionInput>, UserUncheckedUpdateWithoutGmailTenantConnectionInput>
  }

  export type TenantCreateNestedOneWithoutMs365TenantConnectionInput = {
    create?: XOR<TenantCreateWithoutMs365TenantConnectionInput, TenantUncheckedCreateWithoutMs365TenantConnectionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMs365TenantConnectionInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMs365TenantConnectionInput = {
    create?: XOR<UserCreateWithoutMs365TenantConnectionInput, UserUncheckedCreateWithoutMs365TenantConnectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutMs365TenantConnectionInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutMs365TenantConnectionNestedInput = {
    create?: XOR<TenantCreateWithoutMs365TenantConnectionInput, TenantUncheckedCreateWithoutMs365TenantConnectionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMs365TenantConnectionInput
    upsert?: TenantUpsertWithoutMs365TenantConnectionInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMs365TenantConnectionInput, TenantUpdateWithoutMs365TenantConnectionInput>, TenantUncheckedUpdateWithoutMs365TenantConnectionInput>
  }

  export type UserUpdateOneWithoutMs365TenantConnectionNestedInput = {
    create?: XOR<UserCreateWithoutMs365TenantConnectionInput, UserUncheckedCreateWithoutMs365TenantConnectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutMs365TenantConnectionInput
    upsert?: UserUpsertWithoutMs365TenantConnectionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMs365TenantConnectionInput, UserUpdateWithoutMs365TenantConnectionInput>, UserUncheckedUpdateWithoutMs365TenantConnectionInput>
  }

  export type EnumLeadLabelFieldUpdateOperationsInput = {
    set?: $Enums.LeadLabel
  }

  export type LeadCreateNestedOneWithoutFollowUpLogsInput = {
    create?: XOR<LeadCreateWithoutFollowUpLogsInput, LeadUncheckedCreateWithoutFollowUpLogsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutFollowUpLogsInput
    connect?: LeadWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LeadUpdateOneRequiredWithoutFollowUpLogsNestedInput = {
    create?: XOR<LeadCreateWithoutFollowUpLogsInput, LeadUncheckedCreateWithoutFollowUpLogsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutFollowUpLogsInput
    upsert?: LeadUpsertWithoutFollowUpLogsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutFollowUpLogsInput, LeadUpdateWithoutFollowUpLogsInput>, LeadUncheckedUpdateWithoutFollowUpLogsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TenantCreateNestedOneWithoutEmailThreadsInput = {
    create?: XOR<TenantCreateWithoutEmailThreadsInput, TenantUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmailThreadsInput
    connect?: TenantWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutEmailThreadsInput = {
    create?: XOR<LeadCreateWithoutEmailThreadsInput, LeadUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailThreadsInput
    connect?: LeadWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutEmailThreadsInput = {
    create?: XOR<OpportunityCreateWithoutEmailThreadsInput, OpportunityUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutEmailThreadsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type EmailMessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<EmailMessageCreateWithoutThreadInput, EmailMessageUncheckedCreateWithoutThreadInput> | EmailMessageCreateWithoutThreadInput[] | EmailMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutThreadInput | EmailMessageCreateOrConnectWithoutThreadInput[]
    createMany?: EmailMessageCreateManyThreadInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<EmailMessageCreateWithoutThreadInput, EmailMessageUncheckedCreateWithoutThreadInput> | EmailMessageCreateWithoutThreadInput[] | EmailMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutThreadInput | EmailMessageCreateOrConnectWithoutThreadInput[]
    createMany?: EmailMessageCreateManyThreadInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutEmailThreadsNestedInput = {
    create?: XOR<TenantCreateWithoutEmailThreadsInput, TenantUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmailThreadsInput
    upsert?: TenantUpsertWithoutEmailThreadsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmailThreadsInput, TenantUpdateWithoutEmailThreadsInput>, TenantUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type LeadUpdateOneWithoutEmailThreadsNestedInput = {
    create?: XOR<LeadCreateWithoutEmailThreadsInput, LeadUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailThreadsInput
    upsert?: LeadUpsertWithoutEmailThreadsInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutEmailThreadsInput, LeadUpdateWithoutEmailThreadsInput>, LeadUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type OpportunityUpdateOneWithoutEmailThreadsNestedInput = {
    create?: XOR<OpportunityCreateWithoutEmailThreadsInput, OpportunityUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutEmailThreadsInput
    upsert?: OpportunityUpsertWithoutEmailThreadsInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutEmailThreadsInput, OpportunityUpdateWithoutEmailThreadsInput>, OpportunityUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type EmailMessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<EmailMessageCreateWithoutThreadInput, EmailMessageUncheckedCreateWithoutThreadInput> | EmailMessageCreateWithoutThreadInput[] | EmailMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutThreadInput | EmailMessageCreateOrConnectWithoutThreadInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutThreadInput | EmailMessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: EmailMessageCreateManyThreadInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutThreadInput | EmailMessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutThreadInput | EmailMessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<EmailMessageCreateWithoutThreadInput, EmailMessageUncheckedCreateWithoutThreadInput> | EmailMessageCreateWithoutThreadInput[] | EmailMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutThreadInput | EmailMessageCreateOrConnectWithoutThreadInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutThreadInput | EmailMessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: EmailMessageCreateManyThreadInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutThreadInput | EmailMessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutThreadInput | EmailMessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutEmailMessagesInput = {
    create?: XOR<TenantCreateWithoutEmailMessagesInput, TenantUncheckedCreateWithoutEmailMessagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmailMessagesInput
    connect?: TenantWhereUniqueInput
  }

  export type EmailThreadCreateNestedOneWithoutMessagesInput = {
    create?: XOR<EmailThreadCreateWithoutMessagesInput, EmailThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: EmailThreadCreateOrConnectWithoutMessagesInput
    connect?: EmailThreadWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutEmailMessagesInput = {
    create?: XOR<LeadCreateWithoutEmailMessagesInput, LeadUncheckedCreateWithoutEmailMessagesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailMessagesInput
    connect?: LeadWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutEmailMessagesInput = {
    create?: XOR<OpportunityCreateWithoutEmailMessagesInput, OpportunityUncheckedCreateWithoutEmailMessagesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutEmailMessagesInput
    connect?: OpportunityWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutEmailMessagesNestedInput = {
    create?: XOR<TenantCreateWithoutEmailMessagesInput, TenantUncheckedCreateWithoutEmailMessagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmailMessagesInput
    upsert?: TenantUpsertWithoutEmailMessagesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmailMessagesInput, TenantUpdateWithoutEmailMessagesInput>, TenantUncheckedUpdateWithoutEmailMessagesInput>
  }

  export type EmailThreadUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<EmailThreadCreateWithoutMessagesInput, EmailThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: EmailThreadCreateOrConnectWithoutMessagesInput
    upsert?: EmailThreadUpsertWithoutMessagesInput
    connect?: EmailThreadWhereUniqueInput
    update?: XOR<XOR<EmailThreadUpdateToOneWithWhereWithoutMessagesInput, EmailThreadUpdateWithoutMessagesInput>, EmailThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type LeadUpdateOneWithoutEmailMessagesNestedInput = {
    create?: XOR<LeadCreateWithoutEmailMessagesInput, LeadUncheckedCreateWithoutEmailMessagesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutEmailMessagesInput
    upsert?: LeadUpsertWithoutEmailMessagesInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutEmailMessagesInput, LeadUpdateWithoutEmailMessagesInput>, LeadUncheckedUpdateWithoutEmailMessagesInput>
  }

  export type OpportunityUpdateOneWithoutEmailMessagesNestedInput = {
    create?: XOR<OpportunityCreateWithoutEmailMessagesInput, OpportunityUncheckedCreateWithoutEmailMessagesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutEmailMessagesInput
    upsert?: OpportunityUpsertWithoutEmailMessagesInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutEmailMessagesInput, OpportunityUpdateWithoutEmailMessagesInput>, OpportunityUncheckedUpdateWithoutEmailMessagesInput>
  }

  export type TenantCreateNestedOneWithoutQuotesInput = {
    create?: XOR<TenantCreateWithoutQuotesInput, TenantUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutQuotesInput
    connect?: TenantWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutQuoteInput = {
    create?: XOR<LeadCreateWithoutQuoteInput, LeadUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: LeadCreateOrConnectWithoutQuoteInput
    connect?: LeadWhereUniqueInput
  }

  export type UploadedFileCreateNestedManyWithoutQuoteInput = {
    create?: XOR<UploadedFileCreateWithoutQuoteInput, UploadedFileUncheckedCreateWithoutQuoteInput> | UploadedFileCreateWithoutQuoteInput[] | UploadedFileUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutQuoteInput | UploadedFileCreateOrConnectWithoutQuoteInput[]
    createMany?: UploadedFileCreateManyQuoteInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type QuoteLineCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteLineCreateWithoutQuoteInput, QuoteLineUncheckedCreateWithoutQuoteInput> | QuoteLineCreateWithoutQuoteInput[] | QuoteLineUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteLineCreateOrConnectWithoutQuoteInput | QuoteLineCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteLineCreateManyQuoteInputEnvelope
    connect?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
  }

  export type UploadedFileUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<UploadedFileCreateWithoutQuoteInput, UploadedFileUncheckedCreateWithoutQuoteInput> | UploadedFileCreateWithoutQuoteInput[] | UploadedFileUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutQuoteInput | UploadedFileCreateOrConnectWithoutQuoteInput[]
    createMany?: UploadedFileCreateManyQuoteInputEnvelope
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
  }

  export type QuoteLineUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteLineCreateWithoutQuoteInput, QuoteLineUncheckedCreateWithoutQuoteInput> | QuoteLineCreateWithoutQuoteInput[] | QuoteLineUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteLineCreateOrConnectWithoutQuoteInput | QuoteLineCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteLineCreateManyQuoteInputEnvelope
    connect?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
  }

  export type EnumQuoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuoteStatus
  }

  export type TenantUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<TenantCreateWithoutQuotesInput, TenantUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutQuotesInput
    upsert?: TenantUpsertWithoutQuotesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutQuotesInput, TenantUpdateWithoutQuotesInput>, TenantUncheckedUpdateWithoutQuotesInput>
  }

  export type LeadUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<LeadCreateWithoutQuoteInput, LeadUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: LeadCreateOrConnectWithoutQuoteInput
    upsert?: LeadUpsertWithoutQuoteInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutQuoteInput, LeadUpdateWithoutQuoteInput>, LeadUncheckedUpdateWithoutQuoteInput>
  }

  export type UploadedFileUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<UploadedFileCreateWithoutQuoteInput, UploadedFileUncheckedCreateWithoutQuoteInput> | UploadedFileCreateWithoutQuoteInput[] | UploadedFileUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutQuoteInput | UploadedFileCreateOrConnectWithoutQuoteInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutQuoteInput | UploadedFileUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: UploadedFileCreateManyQuoteInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutQuoteInput | UploadedFileUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutQuoteInput | UploadedFileUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type QuoteLineUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteLineCreateWithoutQuoteInput, QuoteLineUncheckedCreateWithoutQuoteInput> | QuoteLineCreateWithoutQuoteInput[] | QuoteLineUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteLineCreateOrConnectWithoutQuoteInput | QuoteLineCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteLineUpsertWithWhereUniqueWithoutQuoteInput | QuoteLineUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteLineCreateManyQuoteInputEnvelope
    set?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    disconnect?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    delete?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    connect?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    update?: QuoteLineUpdateWithWhereUniqueWithoutQuoteInput | QuoteLineUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteLineUpdateManyWithWhereWithoutQuoteInput | QuoteLineUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteLineScalarWhereInput | QuoteLineScalarWhereInput[]
  }

  export type UploadedFileUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<UploadedFileCreateWithoutQuoteInput, UploadedFileUncheckedCreateWithoutQuoteInput> | UploadedFileCreateWithoutQuoteInput[] | UploadedFileUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: UploadedFileCreateOrConnectWithoutQuoteInput | UploadedFileCreateOrConnectWithoutQuoteInput[]
    upsert?: UploadedFileUpsertWithWhereUniqueWithoutQuoteInput | UploadedFileUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: UploadedFileCreateManyQuoteInputEnvelope
    set?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    disconnect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    delete?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    connect?: UploadedFileWhereUniqueInput | UploadedFileWhereUniqueInput[]
    update?: UploadedFileUpdateWithWhereUniqueWithoutQuoteInput | UploadedFileUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: UploadedFileUpdateManyWithWhereWithoutQuoteInput | UploadedFileUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
  }

  export type QuoteLineUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteLineCreateWithoutQuoteInput, QuoteLineUncheckedCreateWithoutQuoteInput> | QuoteLineCreateWithoutQuoteInput[] | QuoteLineUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteLineCreateOrConnectWithoutQuoteInput | QuoteLineCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteLineUpsertWithWhereUniqueWithoutQuoteInput | QuoteLineUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteLineCreateManyQuoteInputEnvelope
    set?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    disconnect?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    delete?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    connect?: QuoteLineWhereUniqueInput | QuoteLineWhereUniqueInput[]
    update?: QuoteLineUpdateWithWhereUniqueWithoutQuoteInput | QuoteLineUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteLineUpdateManyWithWhereWithoutQuoteInput | QuoteLineUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteLineScalarWhereInput | QuoteLineScalarWhereInput[]
  }

  export type QuoteCreateNestedOneWithoutLinesInput = {
    create?: XOR<QuoteCreateWithoutLinesInput, QuoteUncheckedCreateWithoutLinesInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutLinesInput
    connect?: QuoteWhereUniqueInput
  }

  export type QuoteUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<QuoteCreateWithoutLinesInput, QuoteUncheckedCreateWithoutLinesInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutLinesInput
    upsert?: QuoteUpsertWithoutLinesInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutLinesInput, QuoteUpdateWithoutLinesInput>, QuoteUncheckedUpdateWithoutLinesInput>
  }

  export type TenantCreateNestedOneWithoutUploadedFileInput = {
    create?: XOR<TenantCreateWithoutUploadedFileInput, TenantUncheckedCreateWithoutUploadedFileInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUploadedFileInput
    connect?: TenantWhereUniqueInput
  }

  export type QuoteCreateNestedOneWithoutSupplierFilesInput = {
    create?: XOR<QuoteCreateWithoutSupplierFilesInput, QuoteUncheckedCreateWithoutSupplierFilesInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutSupplierFilesInput
    connect?: QuoteWhereUniqueInput
  }

  export type EnumFileKindFieldUpdateOperationsInput = {
    set?: $Enums.FileKind
  }

  export type TenantUpdateOneRequiredWithoutUploadedFileNestedInput = {
    create?: XOR<TenantCreateWithoutUploadedFileInput, TenantUncheckedCreateWithoutUploadedFileInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUploadedFileInput
    upsert?: TenantUpsertWithoutUploadedFileInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUploadedFileInput, TenantUpdateWithoutUploadedFileInput>, TenantUncheckedUpdateWithoutUploadedFileInput>
  }

  export type QuoteUpdateOneWithoutSupplierFilesNestedInput = {
    create?: XOR<QuoteCreateWithoutSupplierFilesInput, QuoteUncheckedCreateWithoutSupplierFilesInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutSupplierFilesInput
    upsert?: QuoteUpsertWithoutSupplierFilesInput
    disconnect?: QuoteWhereInput | boolean
    delete?: QuoteWhereInput | boolean
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutSupplierFilesInput, QuoteUpdateWithoutSupplierFilesInput>, QuoteUncheckedUpdateWithoutSupplierFilesInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokenInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokenNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokenInput
    upsert?: UserUpsertWithoutPasswordResetTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokenInput, UserUpdateWithoutPasswordResetTokenInput>, UserUncheckedUpdateWithoutPasswordResetTokenInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type NestedEnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumOppStageFilter<$PrismaModel = never> = {
    equals?: $Enums.OppStage | EnumOppStageFieldRefInput<$PrismaModel>
    in?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOppStageFilter<$PrismaModel> | $Enums.OppStage
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumOppStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OppStage | EnumOppStageFieldRefInput<$PrismaModel>
    in?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.OppStage[] | ListEnumOppStageFieldRefInput<$PrismaModel>
    not?: NestedEnumOppStageWithAggregatesFilter<$PrismaModel> | $Enums.OppStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOppStageFilter<$PrismaModel>
    _max?: NestedEnumOppStageFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumLeadLabelFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadLabel | EnumLeadLabelFieldRefInput<$PrismaModel>
    in?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadLabelFilter<$PrismaModel> | $Enums.LeadLabel
  }

  export type NestedEnumLeadLabelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadLabel | EnumLeadLabelFieldRefInput<$PrismaModel>
    in?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadLabel[] | ListEnumLeadLabelFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadLabelWithAggregatesFilter<$PrismaModel> | $Enums.LeadLabel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadLabelFilter<$PrismaModel>
    _max?: NestedEnumLeadLabelFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type NestedEnumFileKindFilter<$PrismaModel = never> = {
    equals?: $Enums.FileKind | EnumFileKindFieldRefInput<$PrismaModel>
    in?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    not?: NestedEnumFileKindFilter<$PrismaModel> | $Enums.FileKind
  }

  export type NestedEnumFileKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileKind | EnumFileKindFieldRefInput<$PrismaModel>
    in?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileKind[] | ListEnumFileKindFieldRefInput<$PrismaModel>
    not?: NestedEnumFileKindWithAggregatesFilter<$PrismaModel> | $Enums.FileKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileKindFilter<$PrismaModel>
    _max?: NestedEnumFileKindFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    GmailTenantConnection?: GmailTenantConnectionCreateNestedManyWithoutConnectedByInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutTenantInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageCreateNestedManyWithoutLeadInput
    Quote?: QuoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutTenantInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityUncheckedCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogUncheckedCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutLeadInput
    Quote?: QuoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutTenantInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadCreateManyTenantInputEnvelope = {
    data: LeadCreateManyTenantInput | LeadCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutTenantInput = {
    id?: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    lead: LeadCreateNestedOneWithoutOpportunityInput
    emailThreads?: EmailThreadCreateNestedManyWithoutOpportunityInput
    emailMessages?: EmailMessageCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutTenantInput = {
    id?: string
    leadId: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutOpportunityInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutTenantInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutTenantInput, OpportunityUncheckedCreateWithoutTenantInput>
  }

  export type OpportunityCreateManyTenantInputEnvelope = {
    data: OpportunityCreateManyTenantInput | OpportunityCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LeadFieldDefCreateWithoutTenantInput = {
    id?: string
    key: string
    label: string
    type?: string
    required?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
  }

  export type LeadFieldDefUncheckedCreateWithoutTenantInput = {
    id?: string
    key: string
    label: string
    type?: string
    required?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
  }

  export type LeadFieldDefCreateOrConnectWithoutTenantInput = {
    where: LeadFieldDefWhereUniqueInput
    create: XOR<LeadFieldDefCreateWithoutTenantInput, LeadFieldDefUncheckedCreateWithoutTenantInput>
  }

  export type LeadFieldDefCreateManyTenantInputEnvelope = {
    data: LeadFieldDefCreateManyTenantInput | LeadFieldDefCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type GmailTenantConnectionCreateWithoutTenantInput = {
    id?: string
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectedBy?: UserCreateNestedOneWithoutGmailTenantConnectionInput
  }

  export type GmailTenantConnectionUncheckedCreateWithoutTenantInput = {
    id?: string
    connectedById?: string | null
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailTenantConnectionCreateOrConnectWithoutTenantInput = {
    where: GmailTenantConnectionWhereUniqueInput
    create: XOR<GmailTenantConnectionCreateWithoutTenantInput, GmailTenantConnectionUncheckedCreateWithoutTenantInput>
  }

  export type Ms365TenantConnectionCreateWithoutTenantInput = {
    id?: string
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    connectedBy?: UserCreateNestedOneWithoutMs365TenantConnectionInput
  }

  export type Ms365TenantConnectionUncheckedCreateWithoutTenantInput = {
    id?: string
    connectedById?: string | null
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Ms365TenantConnectionCreateOrConnectWithoutTenantInput = {
    where: Ms365TenantConnectionWhereUniqueInput
    create: XOR<Ms365TenantConnectionCreateWithoutTenantInput, Ms365TenantConnectionUncheckedCreateWithoutTenantInput>
  }

  export type EmailIngestCreateWithoutTenantInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
    lead?: LeadCreateNestedOneWithoutEmailIngestsInput
  }

  export type EmailIngestUncheckedCreateWithoutTenantInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    leadId?: string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailIngestCreateOrConnectWithoutTenantInput = {
    where: EmailIngestWhereUniqueInput
    create: XOR<EmailIngestCreateWithoutTenantInput, EmailIngestUncheckedCreateWithoutTenantInput>
  }

  export type EmailIngestCreateManyTenantInputEnvelope = {
    data: EmailIngestCreateManyTenantInput | EmailIngestCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EmailThreadCreateWithoutTenantInput = {
    id?: string
    provider: string
    threadId: string
    subject?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutEmailThreadsInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailThreadsInput
    messages?: EmailMessageCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadUncheckedCreateWithoutTenantInput = {
    id?: string
    provider: string
    threadId: string
    subject?: string | null
    leadId?: string | null
    opportunityId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EmailMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadCreateOrConnectWithoutTenantInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutTenantInput, EmailThreadUncheckedCreateWithoutTenantInput>
  }

  export type EmailThreadCreateManyTenantInputEnvelope = {
    data: EmailThreadCreateManyTenantInput | EmailThreadCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EmailMessageCreateWithoutTenantInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    thread: EmailThreadCreateNestedOneWithoutMessagesInput
    lead?: LeadCreateNestedOneWithoutEmailMessagesInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailMessagesInput
  }

  export type EmailMessageUncheckedCreateWithoutTenantInput = {
    id?: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
    opportunityId?: string | null
  }

  export type EmailMessageCreateOrConnectWithoutTenantInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutTenantInput, EmailMessageUncheckedCreateWithoutTenantInput>
  }

  export type EmailMessageCreateManyTenantInputEnvelope = {
    data: EmailMessageCreateManyTenantInput | EmailMessageCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutTenantInput = {
    id?: string
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lead?: LeadCreateNestedOneWithoutQuoteInput
    supplierFiles?: UploadedFileCreateNestedManyWithoutQuoteInput
    lines?: QuoteLineCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutTenantInput = {
    id?: string
    leadId?: string | null
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierFiles?: UploadedFileUncheckedCreateNestedManyWithoutQuoteInput
    lines?: QuoteLineUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutTenantInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutTenantInput, QuoteUncheckedCreateWithoutTenantInput>
  }

  export type QuoteCreateManyTenantInputEnvelope = {
    data: QuoteCreateManyTenantInput | QuoteCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UploadedFileCreateWithoutTenantInput = {
    id?: string
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
    quote?: QuoteCreateNestedOneWithoutSupplierFilesInput
  }

  export type UploadedFileUncheckedCreateWithoutTenantInput = {
    id?: string
    quoteId?: string | null
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
  }

  export type UploadedFileCreateOrConnectWithoutTenantInput = {
    where: UploadedFileWhereUniqueInput
    create: XOR<UploadedFileCreateWithoutTenantInput, UploadedFileUncheckedCreateWithoutTenantInput>
  }

  export type UploadedFileCreateManyTenantInputEnvelope = {
    data: UploadedFileCreateManyTenantInput | UploadedFileCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
  }

  export type LeadUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
  }

  export type LeadUpdateManyWithWhereWithoutTenantInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutTenantInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    createdById?: StringFilter<"Lead"> | string
    contactName?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    capturedAt?: DateTimeFilter<"Lead"> | Date | string
    nextActionAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextAction?: StringNullableFilter<"Lead"> | string | null
    briefJson?: JsonNullableFilter<"Lead">
    custom?: JsonNullableFilter<"Lead">
    description?: StringNullableFilter<"Lead"> | string | null
  }

  export type OpportunityUpsertWithWhereUniqueWithoutTenantInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutTenantInput, OpportunityUncheckedUpdateWithoutTenantInput>
    create: XOR<OpportunityCreateWithoutTenantInput, OpportunityUncheckedCreateWithoutTenantInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutTenantInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutTenantInput, OpportunityUncheckedUpdateWithoutTenantInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutTenantInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutTenantInput>
  }

  export type OpportunityScalarWhereInput = {
    AND?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    OR?: OpportunityScalarWhereInput[]
    NOT?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    tenantId?: StringFilter<"Opportunity"> | string
    leadId?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    valueGBP?: DecimalNullableFilter<"Opportunity"> | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFilter<"Opportunity"> | $Enums.OppStage
    wonAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
  }

  export type LeadFieldDefUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeadFieldDefWhereUniqueInput
    update: XOR<LeadFieldDefUpdateWithoutTenantInput, LeadFieldDefUncheckedUpdateWithoutTenantInput>
    create: XOR<LeadFieldDefCreateWithoutTenantInput, LeadFieldDefUncheckedCreateWithoutTenantInput>
  }

  export type LeadFieldDefUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeadFieldDefWhereUniqueInput
    data: XOR<LeadFieldDefUpdateWithoutTenantInput, LeadFieldDefUncheckedUpdateWithoutTenantInput>
  }

  export type LeadFieldDefUpdateManyWithWhereWithoutTenantInput = {
    where: LeadFieldDefScalarWhereInput
    data: XOR<LeadFieldDefUpdateManyMutationInput, LeadFieldDefUncheckedUpdateManyWithoutTenantInput>
  }

  export type LeadFieldDefScalarWhereInput = {
    AND?: LeadFieldDefScalarWhereInput | LeadFieldDefScalarWhereInput[]
    OR?: LeadFieldDefScalarWhereInput[]
    NOT?: LeadFieldDefScalarWhereInput | LeadFieldDefScalarWhereInput[]
    id?: StringFilter<"LeadFieldDef"> | string
    tenantId?: StringFilter<"LeadFieldDef"> | string
    key?: StringFilter<"LeadFieldDef"> | string
    label?: StringFilter<"LeadFieldDef"> | string
    type?: StringFilter<"LeadFieldDef"> | string
    required?: BoolFilter<"LeadFieldDef"> | boolean
    config?: JsonNullableFilter<"LeadFieldDef">
    sortOrder?: IntFilter<"LeadFieldDef"> | number
  }

  export type GmailTenantConnectionUpsertWithoutTenantInput = {
    update: XOR<GmailTenantConnectionUpdateWithoutTenantInput, GmailTenantConnectionUncheckedUpdateWithoutTenantInput>
    create: XOR<GmailTenantConnectionCreateWithoutTenantInput, GmailTenantConnectionUncheckedCreateWithoutTenantInput>
    where?: GmailTenantConnectionWhereInput
  }

  export type GmailTenantConnectionUpdateToOneWithWhereWithoutTenantInput = {
    where?: GmailTenantConnectionWhereInput
    data: XOR<GmailTenantConnectionUpdateWithoutTenantInput, GmailTenantConnectionUncheckedUpdateWithoutTenantInput>
  }

  export type GmailTenantConnectionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedBy?: UserUpdateOneWithoutGmailTenantConnectionNestedInput
  }

  export type GmailTenantConnectionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectedById?: NullableStringFieldUpdateOperationsInput | string | null
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Ms365TenantConnectionUpsertWithoutTenantInput = {
    update: XOR<Ms365TenantConnectionUpdateWithoutTenantInput, Ms365TenantConnectionUncheckedUpdateWithoutTenantInput>
    create: XOR<Ms365TenantConnectionCreateWithoutTenantInput, Ms365TenantConnectionUncheckedCreateWithoutTenantInput>
    where?: Ms365TenantConnectionWhereInput
  }

  export type Ms365TenantConnectionUpdateToOneWithWhereWithoutTenantInput = {
    where?: Ms365TenantConnectionWhereInput
    data: XOR<Ms365TenantConnectionUpdateWithoutTenantInput, Ms365TenantConnectionUncheckedUpdateWithoutTenantInput>
  }

  export type Ms365TenantConnectionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedBy?: UserUpdateOneWithoutMs365TenantConnectionNestedInput
  }

  export type Ms365TenantConnectionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectedById?: NullableStringFieldUpdateOperationsInput | string | null
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIngestUpsertWithWhereUniqueWithoutTenantInput = {
    where: EmailIngestWhereUniqueInput
    update: XOR<EmailIngestUpdateWithoutTenantInput, EmailIngestUncheckedUpdateWithoutTenantInput>
    create: XOR<EmailIngestCreateWithoutTenantInput, EmailIngestUncheckedCreateWithoutTenantInput>
  }

  export type EmailIngestUpdateWithWhereUniqueWithoutTenantInput = {
    where: EmailIngestWhereUniqueInput
    data: XOR<EmailIngestUpdateWithoutTenantInput, EmailIngestUncheckedUpdateWithoutTenantInput>
  }

  export type EmailIngestUpdateManyWithWhereWithoutTenantInput = {
    where: EmailIngestScalarWhereInput
    data: XOR<EmailIngestUpdateManyMutationInput, EmailIngestUncheckedUpdateManyWithoutTenantInput>
  }

  export type EmailIngestScalarWhereInput = {
    AND?: EmailIngestScalarWhereInput | EmailIngestScalarWhereInput[]
    OR?: EmailIngestScalarWhereInput[]
    NOT?: EmailIngestScalarWhereInput | EmailIngestScalarWhereInput[]
    id?: StringFilter<"EmailIngest"> | string
    tenantId?: StringFilter<"EmailIngest"> | string
    provider?: StringFilter<"EmailIngest"> | string
    messageId?: StringFilter<"EmailIngest"> | string
    fromEmail?: StringNullableFilter<"EmailIngest"> | string | null
    subject?: StringNullableFilter<"EmailIngest"> | string | null
    snippet?: StringNullableFilter<"EmailIngest"> | string | null
    processedAt?: DateTimeNullableFilter<"EmailIngest"> | Date | string | null
    leadId?: StringNullableFilter<"EmailIngest"> | string | null
    aiPredictedIsLead?: BoolNullableFilter<"EmailIngest"> | boolean | null
    userLabelIsLead?: BoolNullableFilter<"EmailIngest"> | boolean | null
    userLabeledAt?: DateTimeNullableFilter<"EmailIngest"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailIngest"> | Date | string
  }

  export type EmailThreadUpsertWithWhereUniqueWithoutTenantInput = {
    where: EmailThreadWhereUniqueInput
    update: XOR<EmailThreadUpdateWithoutTenantInput, EmailThreadUncheckedUpdateWithoutTenantInput>
    create: XOR<EmailThreadCreateWithoutTenantInput, EmailThreadUncheckedCreateWithoutTenantInput>
  }

  export type EmailThreadUpdateWithWhereUniqueWithoutTenantInput = {
    where: EmailThreadWhereUniqueInput
    data: XOR<EmailThreadUpdateWithoutTenantInput, EmailThreadUncheckedUpdateWithoutTenantInput>
  }

  export type EmailThreadUpdateManyWithWhereWithoutTenantInput = {
    where: EmailThreadScalarWhereInput
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyWithoutTenantInput>
  }

  export type EmailThreadScalarWhereInput = {
    AND?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
    OR?: EmailThreadScalarWhereInput[]
    NOT?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
    id?: StringFilter<"EmailThread"> | string
    tenantId?: StringFilter<"EmailThread"> | string
    provider?: StringFilter<"EmailThread"> | string
    threadId?: StringFilter<"EmailThread"> | string
    subject?: StringNullableFilter<"EmailThread"> | string | null
    leadId?: StringNullableFilter<"EmailThread"> | string | null
    opportunityId?: StringNullableFilter<"EmailThread"> | string | null
    lastInboundAt?: DateTimeNullableFilter<"EmailThread"> | Date | string | null
    lastOutboundAt?: DateTimeNullableFilter<"EmailThread"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeFilter<"EmailThread"> | Date | string
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutTenantInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutTenantInput, EmailMessageUncheckedUpdateWithoutTenantInput>
    create: XOR<EmailMessageCreateWithoutTenantInput, EmailMessageUncheckedCreateWithoutTenantInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutTenantInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutTenantInput, EmailMessageUncheckedUpdateWithoutTenantInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutTenantInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutTenantInput>
  }

  export type EmailMessageScalarWhereInput = {
    AND?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
    OR?: EmailMessageScalarWhereInput[]
    NOT?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
    id?: StringFilter<"EmailMessage"> | string
    tenantId?: StringFilter<"EmailMessage"> | string
    threadId?: StringFilter<"EmailMessage"> | string
    provider?: StringFilter<"EmailMessage"> | string
    messageId?: StringFilter<"EmailMessage"> | string
    fromEmail?: StringNullableFilter<"EmailMessage"> | string | null
    toEmail?: StringNullableFilter<"EmailMessage"> | string | null
    cc?: StringNullableFilter<"EmailMessage"> | string | null
    bcc?: StringNullableFilter<"EmailMessage"> | string | null
    subject?: StringNullableFilter<"EmailMessage"> | string | null
    snippet?: StringNullableFilter<"EmailMessage"> | string | null
    bodyText?: StringNullableFilter<"EmailMessage"> | string | null
    bodyHtml?: StringNullableFilter<"EmailMessage"> | string | null
    direction?: StringFilter<"EmailMessage"> | string
    sentAt?: DateTimeFilter<"EmailMessage"> | Date | string
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    leadId?: StringNullableFilter<"EmailMessage"> | string | null
    opportunityId?: StringNullableFilter<"EmailMessage"> | string | null
  }

  export type QuoteUpsertWithWhereUniqueWithoutTenantInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutTenantInput, QuoteUncheckedUpdateWithoutTenantInput>
    create: XOR<QuoteCreateWithoutTenantInput, QuoteUncheckedCreateWithoutTenantInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutTenantInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutTenantInput, QuoteUncheckedUpdateWithoutTenantInput>
  }

  export type QuoteUpdateManyWithWhereWithoutTenantInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutTenantInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: StringFilter<"Quote"> | string
    tenantId?: StringFilter<"Quote"> | string
    leadId?: StringNullableFilter<"Quote"> | string | null
    title?: StringFilter<"Quote"> | string
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    currency?: StringFilter<"Quote"> | string
    exchangeRate?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    markupDefault?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    totalGBP?: DecimalNullableFilter<"Quote"> | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    meta?: JsonNullableFilter<"Quote">
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
  }

  export type UploadedFileUpsertWithWhereUniqueWithoutTenantInput = {
    where: UploadedFileWhereUniqueInput
    update: XOR<UploadedFileUpdateWithoutTenantInput, UploadedFileUncheckedUpdateWithoutTenantInput>
    create: XOR<UploadedFileCreateWithoutTenantInput, UploadedFileUncheckedCreateWithoutTenantInput>
  }

  export type UploadedFileUpdateWithWhereUniqueWithoutTenantInput = {
    where: UploadedFileWhereUniqueInput
    data: XOR<UploadedFileUpdateWithoutTenantInput, UploadedFileUncheckedUpdateWithoutTenantInput>
  }

  export type UploadedFileUpdateManyWithWhereWithoutTenantInput = {
    where: UploadedFileScalarWhereInput
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyWithoutTenantInput>
  }

  export type UploadedFileScalarWhereInput = {
    AND?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
    OR?: UploadedFileScalarWhereInput[]
    NOT?: UploadedFileScalarWhereInput | UploadedFileScalarWhereInput[]
    id?: StringFilter<"UploadedFile"> | string
    tenantId?: StringFilter<"UploadedFile"> | string
    quoteId?: StringNullableFilter<"UploadedFile"> | string | null
    kind?: EnumFileKindFilter<"UploadedFile"> | $Enums.FileKind
    name?: StringFilter<"UploadedFile"> | string
    path?: StringFilter<"UploadedFile"> | string
    mimeType?: StringNullableFilter<"UploadedFile"> | string | null
    sizeBytes?: IntNullableFilter<"UploadedFile"> | number | null
    uploadedAt?: DateTimeFilter<"UploadedFile"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type GmailTenantConnectionCreateWithoutConnectedByInput = {
    id?: string
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutGmailTenantConnectionInput
  }

  export type GmailTenantConnectionUncheckedCreateWithoutConnectedByInput = {
    id?: string
    tenantId: string
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailTenantConnectionCreateOrConnectWithoutConnectedByInput = {
    where: GmailTenantConnectionWhereUniqueInput
    create: XOR<GmailTenantConnectionCreateWithoutConnectedByInput, GmailTenantConnectionUncheckedCreateWithoutConnectedByInput>
  }

  export type GmailTenantConnectionCreateManyConnectedByInputEnvelope = {
    data: GmailTenantConnectionCreateManyConnectedByInput | GmailTenantConnectionCreateManyConnectedByInput[]
    skipDuplicates?: boolean
  }

  export type Ms365TenantConnectionCreateWithoutConnectedByInput = {
    id?: string
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMs365TenantConnectionInput
  }

  export type Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput = {
    id?: string
    tenantId: string
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Ms365TenantConnectionCreateOrConnectWithoutConnectedByInput = {
    where: Ms365TenantConnectionWhereUniqueInput
    create: XOR<Ms365TenantConnectionCreateWithoutConnectedByInput, Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput>
  }

  export type Ms365TenantConnectionCreateManyConnectedByInputEnvelope = {
    data: Ms365TenantConnectionCreateManyConnectedByInput | Ms365TenantConnectionCreateManyConnectedByInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type GmailTenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput = {
    where: GmailTenantConnectionWhereUniqueInput
    update: XOR<GmailTenantConnectionUpdateWithoutConnectedByInput, GmailTenantConnectionUncheckedUpdateWithoutConnectedByInput>
    create: XOR<GmailTenantConnectionCreateWithoutConnectedByInput, GmailTenantConnectionUncheckedCreateWithoutConnectedByInput>
  }

  export type GmailTenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput = {
    where: GmailTenantConnectionWhereUniqueInput
    data: XOR<GmailTenantConnectionUpdateWithoutConnectedByInput, GmailTenantConnectionUncheckedUpdateWithoutConnectedByInput>
  }

  export type GmailTenantConnectionUpdateManyWithWhereWithoutConnectedByInput = {
    where: GmailTenantConnectionScalarWhereInput
    data: XOR<GmailTenantConnectionUpdateManyMutationInput, GmailTenantConnectionUncheckedUpdateManyWithoutConnectedByInput>
  }

  export type GmailTenantConnectionScalarWhereInput = {
    AND?: GmailTenantConnectionScalarWhereInput | GmailTenantConnectionScalarWhereInput[]
    OR?: GmailTenantConnectionScalarWhereInput[]
    NOT?: GmailTenantConnectionScalarWhereInput | GmailTenantConnectionScalarWhereInput[]
    id?: StringFilter<"GmailTenantConnection"> | string
    tenantId?: StringFilter<"GmailTenantConnection"> | string
    connectedById?: StringNullableFilter<"GmailTenantConnection"> | string | null
    gmailAddress?: StringNullableFilter<"GmailTenantConnection"> | string | null
    refreshToken?: StringFilter<"GmailTenantConnection"> | string
    createdAt?: DateTimeFilter<"GmailTenantConnection"> | Date | string
    updatedAt?: DateTimeFilter<"GmailTenantConnection"> | Date | string
  }

  export type Ms365TenantConnectionUpsertWithWhereUniqueWithoutConnectedByInput = {
    where: Ms365TenantConnectionWhereUniqueInput
    update: XOR<Ms365TenantConnectionUpdateWithoutConnectedByInput, Ms365TenantConnectionUncheckedUpdateWithoutConnectedByInput>
    create: XOR<Ms365TenantConnectionCreateWithoutConnectedByInput, Ms365TenantConnectionUncheckedCreateWithoutConnectedByInput>
  }

  export type Ms365TenantConnectionUpdateWithWhereUniqueWithoutConnectedByInput = {
    where: Ms365TenantConnectionWhereUniqueInput
    data: XOR<Ms365TenantConnectionUpdateWithoutConnectedByInput, Ms365TenantConnectionUncheckedUpdateWithoutConnectedByInput>
  }

  export type Ms365TenantConnectionUpdateManyWithWhereWithoutConnectedByInput = {
    where: Ms365TenantConnectionScalarWhereInput
    data: XOR<Ms365TenantConnectionUpdateManyMutationInput, Ms365TenantConnectionUncheckedUpdateManyWithoutConnectedByInput>
  }

  export type Ms365TenantConnectionScalarWhereInput = {
    AND?: Ms365TenantConnectionScalarWhereInput | Ms365TenantConnectionScalarWhereInput[]
    OR?: Ms365TenantConnectionScalarWhereInput[]
    NOT?: Ms365TenantConnectionScalarWhereInput | Ms365TenantConnectionScalarWhereInput[]
    id?: StringFilter<"Ms365TenantConnection"> | string
    tenantId?: StringFilter<"Ms365TenantConnection"> | string
    connectedById?: StringNullableFilter<"Ms365TenantConnection"> | string | null
    ms365Address?: StringNullableFilter<"Ms365TenantConnection"> | string | null
    refreshToken?: StringFilter<"Ms365TenantConnection"> | string
    createdAt?: DateTimeFilter<"Ms365TenantConnection"> | Date | string
    updatedAt?: DateTimeFilter<"Ms365TenantConnection"> | Date | string
  }

  export type PasswordResetTokenUpsertWithoutUserInput = {
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    where?: PasswordResetTokenWhereInput
  }

  export type PasswordResetTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: PasswordResetTokenWhereInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutLeadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLeadsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
  }

  export type OpportunityCreateWithoutLeadInput = {
    id?: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOpportunitiesInput
    emailThreads?: EmailThreadCreateNestedManyWithoutOpportunityInput
    emailMessages?: EmailMessageCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutOpportunityInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutLeadInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
  }

  export type EmailIngestCreateWithoutLeadInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailIngestsInput
  }

  export type EmailIngestUncheckedCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailIngestCreateOrConnectWithoutLeadInput = {
    where: EmailIngestWhereUniqueInput
    create: XOR<EmailIngestCreateWithoutLeadInput, EmailIngestUncheckedCreateWithoutLeadInput>
  }

  export type EmailIngestCreateManyLeadInputEnvelope = {
    data: EmailIngestCreateManyLeadInput | EmailIngestCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type FollowUpLogCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    variant: string
    subject: string
    body: string
    sentAt?: Date | string
    opened?: boolean | null
    replied?: boolean | null
    converted?: boolean | null
    delayDays?: number | null
    provider?: string | null
    messageId?: string | null
    threadId?: string | null
  }

  export type FollowUpLogUncheckedCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    variant: string
    subject: string
    body: string
    sentAt?: Date | string
    opened?: boolean | null
    replied?: boolean | null
    converted?: boolean | null
    delayDays?: number | null
    provider?: string | null
    messageId?: string | null
    threadId?: string | null
  }

  export type FollowUpLogCreateOrConnectWithoutLeadInput = {
    where: FollowUpLogWhereUniqueInput
    create: XOR<FollowUpLogCreateWithoutLeadInput, FollowUpLogUncheckedCreateWithoutLeadInput>
  }

  export type FollowUpLogCreateManyLeadInputEnvelope = {
    data: FollowUpLogCreateManyLeadInput | FollowUpLogCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type EmailThreadCreateWithoutLeadInput = {
    id?: string
    provider: string
    threadId: string
    subject?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailThreadsInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailThreadsInput
    messages?: EmailMessageCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadUncheckedCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    provider: string
    threadId: string
    subject?: string | null
    opportunityId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EmailMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadCreateOrConnectWithoutLeadInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutLeadInput, EmailThreadUncheckedCreateWithoutLeadInput>
  }

  export type EmailThreadCreateManyLeadInputEnvelope = {
    data: EmailThreadCreateManyLeadInput | EmailThreadCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type EmailMessageCreateWithoutLeadInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailMessagesInput
    thread: EmailThreadCreateNestedOneWithoutMessagesInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailMessagesInput
  }

  export type EmailMessageUncheckedCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    opportunityId?: string | null
  }

  export type EmailMessageCreateOrConnectWithoutLeadInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutLeadInput, EmailMessageUncheckedCreateWithoutLeadInput>
  }

  export type EmailMessageCreateManyLeadInputEnvelope = {
    data: EmailMessageCreateManyLeadInput | EmailMessageCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutLeadInput = {
    id?: string
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutQuotesInput
    supplierFiles?: UploadedFileCreateNestedManyWithoutQuoteInput
    lines?: QuoteLineCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierFiles?: UploadedFileUncheckedCreateNestedManyWithoutQuoteInput
    lines?: QuoteLineUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutLeadInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutLeadInput, QuoteUncheckedCreateWithoutLeadInput>
  }

  export type QuoteCreateManyLeadInputEnvelope = {
    data: QuoteCreateManyLeadInput | QuoteCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutLeadsInput = {
    update: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeadsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type TenantUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OpportunityUpsertWithoutLeadInput = {
    update: XOR<OpportunityUpdateWithoutLeadInput, OpportunityUncheckedUpdateWithoutLeadInput>
    create: XOR<OpportunityCreateWithoutLeadInput, OpportunityUncheckedCreateWithoutLeadInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutLeadInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutLeadInput, OpportunityUncheckedUpdateWithoutLeadInput>
  }

  export type OpportunityUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOpportunitiesNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutOpportunityNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutOpportunityNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type EmailIngestUpsertWithWhereUniqueWithoutLeadInput = {
    where: EmailIngestWhereUniqueInput
    update: XOR<EmailIngestUpdateWithoutLeadInput, EmailIngestUncheckedUpdateWithoutLeadInput>
    create: XOR<EmailIngestCreateWithoutLeadInput, EmailIngestUncheckedCreateWithoutLeadInput>
  }

  export type EmailIngestUpdateWithWhereUniqueWithoutLeadInput = {
    where: EmailIngestWhereUniqueInput
    data: XOR<EmailIngestUpdateWithoutLeadInput, EmailIngestUncheckedUpdateWithoutLeadInput>
  }

  export type EmailIngestUpdateManyWithWhereWithoutLeadInput = {
    where: EmailIngestScalarWhereInput
    data: XOR<EmailIngestUpdateManyMutationInput, EmailIngestUncheckedUpdateManyWithoutLeadInput>
  }

  export type FollowUpLogUpsertWithWhereUniqueWithoutLeadInput = {
    where: FollowUpLogWhereUniqueInput
    update: XOR<FollowUpLogUpdateWithoutLeadInput, FollowUpLogUncheckedUpdateWithoutLeadInput>
    create: XOR<FollowUpLogCreateWithoutLeadInput, FollowUpLogUncheckedCreateWithoutLeadInput>
  }

  export type FollowUpLogUpdateWithWhereUniqueWithoutLeadInput = {
    where: FollowUpLogWhereUniqueInput
    data: XOR<FollowUpLogUpdateWithoutLeadInput, FollowUpLogUncheckedUpdateWithoutLeadInput>
  }

  export type FollowUpLogUpdateManyWithWhereWithoutLeadInput = {
    where: FollowUpLogScalarWhereInput
    data: XOR<FollowUpLogUpdateManyMutationInput, FollowUpLogUncheckedUpdateManyWithoutLeadInput>
  }

  export type FollowUpLogScalarWhereInput = {
    AND?: FollowUpLogScalarWhereInput | FollowUpLogScalarWhereInput[]
    OR?: FollowUpLogScalarWhereInput[]
    NOT?: FollowUpLogScalarWhereInput | FollowUpLogScalarWhereInput[]
    id?: StringFilter<"FollowUpLog"> | string
    tenantId?: StringFilter<"FollowUpLog"> | string
    leadId?: StringFilter<"FollowUpLog"> | string
    variant?: StringFilter<"FollowUpLog"> | string
    subject?: StringFilter<"FollowUpLog"> | string
    body?: StringFilter<"FollowUpLog"> | string
    sentAt?: DateTimeFilter<"FollowUpLog"> | Date | string
    opened?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    replied?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    converted?: BoolNullableFilter<"FollowUpLog"> | boolean | null
    delayDays?: IntNullableFilter<"FollowUpLog"> | number | null
    provider?: StringNullableFilter<"FollowUpLog"> | string | null
    messageId?: StringNullableFilter<"FollowUpLog"> | string | null
    threadId?: StringNullableFilter<"FollowUpLog"> | string | null
  }

  export type EmailThreadUpsertWithWhereUniqueWithoutLeadInput = {
    where: EmailThreadWhereUniqueInput
    update: XOR<EmailThreadUpdateWithoutLeadInput, EmailThreadUncheckedUpdateWithoutLeadInput>
    create: XOR<EmailThreadCreateWithoutLeadInput, EmailThreadUncheckedCreateWithoutLeadInput>
  }

  export type EmailThreadUpdateWithWhereUniqueWithoutLeadInput = {
    where: EmailThreadWhereUniqueInput
    data: XOR<EmailThreadUpdateWithoutLeadInput, EmailThreadUncheckedUpdateWithoutLeadInput>
  }

  export type EmailThreadUpdateManyWithWhereWithoutLeadInput = {
    where: EmailThreadScalarWhereInput
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyWithoutLeadInput>
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutLeadInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutLeadInput, EmailMessageUncheckedUpdateWithoutLeadInput>
    create: XOR<EmailMessageCreateWithoutLeadInput, EmailMessageUncheckedCreateWithoutLeadInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutLeadInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutLeadInput, EmailMessageUncheckedUpdateWithoutLeadInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutLeadInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutLeadInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutLeadInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutLeadInput, QuoteUncheckedUpdateWithoutLeadInput>
    create: XOR<QuoteCreateWithoutLeadInput, QuoteUncheckedCreateWithoutLeadInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutLeadInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutLeadInput, QuoteUncheckedUpdateWithoutLeadInput>
  }

  export type QuoteUpdateManyWithWhereWithoutLeadInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutLeadInput>
  }

  export type TenantCreateWithoutOpportunitiesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOpportunitiesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOpportunitiesInput, TenantUncheckedCreateWithoutOpportunitiesInput>
  }

  export type LeadCreateWithoutOpportunityInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    tenant: TenantCreateNestedOneWithoutLeadsInput
    emailIngests?: EmailIngestCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageCreateNestedManyWithoutLeadInput
    Quote?: QuoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutOpportunityInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogUncheckedCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutLeadInput
    Quote?: QuoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutOpportunityInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutOpportunityInput, LeadUncheckedCreateWithoutOpportunityInput>
  }

  export type EmailThreadCreateWithoutOpportunityInput = {
    id?: string
    provider: string
    threadId: string
    subject?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailThreadsInput
    lead?: LeadCreateNestedOneWithoutEmailThreadsInput
    messages?: EmailMessageCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadUncheckedCreateWithoutOpportunityInput = {
    id?: string
    tenantId: string
    provider: string
    threadId: string
    subject?: string | null
    leadId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: EmailMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type EmailThreadCreateOrConnectWithoutOpportunityInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutOpportunityInput, EmailThreadUncheckedCreateWithoutOpportunityInput>
  }

  export type EmailThreadCreateManyOpportunityInputEnvelope = {
    data: EmailThreadCreateManyOpportunityInput | EmailThreadCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type EmailMessageCreateWithoutOpportunityInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailMessagesInput
    thread: EmailThreadCreateNestedOneWithoutMessagesInput
    lead?: LeadCreateNestedOneWithoutEmailMessagesInput
  }

  export type EmailMessageUncheckedCreateWithoutOpportunityInput = {
    id?: string
    tenantId: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
  }

  export type EmailMessageCreateOrConnectWithoutOpportunityInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutOpportunityInput, EmailMessageUncheckedCreateWithoutOpportunityInput>
  }

  export type EmailMessageCreateManyOpportunityInputEnvelope = {
    data: EmailMessageCreateManyOpportunityInput | EmailMessageCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutOpportunitiesInput = {
    update: XOR<TenantUpdateWithoutOpportunitiesInput, TenantUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<TenantCreateWithoutOpportunitiesInput, TenantUncheckedCreateWithoutOpportunitiesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOpportunitiesInput, TenantUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type TenantUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeadUpsertWithoutOpportunityInput = {
    update: XOR<LeadUpdateWithoutOpportunityInput, LeadUncheckedUpdateWithoutOpportunityInput>
    create: XOR<LeadCreateWithoutOpportunityInput, LeadUncheckedCreateWithoutOpportunityInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutOpportunityInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutOpportunityInput, LeadUncheckedUpdateWithoutOpportunityInput>
  }

  export type LeadUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type EmailThreadUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: EmailThreadWhereUniqueInput
    update: XOR<EmailThreadUpdateWithoutOpportunityInput, EmailThreadUncheckedUpdateWithoutOpportunityInput>
    create: XOR<EmailThreadCreateWithoutOpportunityInput, EmailThreadUncheckedCreateWithoutOpportunityInput>
  }

  export type EmailThreadUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: EmailThreadWhereUniqueInput
    data: XOR<EmailThreadUpdateWithoutOpportunityInput, EmailThreadUncheckedUpdateWithoutOpportunityInput>
  }

  export type EmailThreadUpdateManyWithWhereWithoutOpportunityInput = {
    where: EmailThreadScalarWhereInput
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutOpportunityInput, EmailMessageUncheckedUpdateWithoutOpportunityInput>
    create: XOR<EmailMessageCreateWithoutOpportunityInput, EmailMessageUncheckedCreateWithoutOpportunityInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutOpportunityInput, EmailMessageUncheckedUpdateWithoutOpportunityInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutOpportunityInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type TenantCreateWithoutEmailIngestsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmailIngestsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmailIngestsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmailIngestsInput, TenantUncheckedCreateWithoutEmailIngestsInput>
  }

  export type LeadCreateWithoutEmailIngestsInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    tenant: TenantCreateNestedOneWithoutLeadsInput
    opportunity?: OpportunityCreateNestedOneWithoutLeadInput
    followUpLogs?: FollowUpLogCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageCreateNestedManyWithoutLeadInput
    Quote?: QuoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutEmailIngestsInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityUncheckedCreateNestedOneWithoutLeadInput
    followUpLogs?: FollowUpLogUncheckedCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutLeadInput
    Quote?: QuoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutEmailIngestsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutEmailIngestsInput, LeadUncheckedCreateWithoutEmailIngestsInput>
  }

  export type TenantUpsertWithoutEmailIngestsInput = {
    update: XOR<TenantUpdateWithoutEmailIngestsInput, TenantUncheckedUpdateWithoutEmailIngestsInput>
    create: XOR<TenantCreateWithoutEmailIngestsInput, TenantUncheckedCreateWithoutEmailIngestsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmailIngestsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmailIngestsInput, TenantUncheckedUpdateWithoutEmailIngestsInput>
  }

  export type TenantUpdateWithoutEmailIngestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmailIngestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeadUpsertWithoutEmailIngestsInput = {
    update: XOR<LeadUpdateWithoutEmailIngestsInput, LeadUncheckedUpdateWithoutEmailIngestsInput>
    create: XOR<LeadCreateWithoutEmailIngestsInput, LeadUncheckedCreateWithoutEmailIngestsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutEmailIngestsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutEmailIngestsInput, LeadUncheckedUpdateWithoutEmailIngestsInput>
  }

  export type LeadUpdateWithoutEmailIngestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutEmailIngestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUncheckedUpdateOneWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type TenantCreateWithoutLeadFieldDefsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeadFieldDefsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLeadFieldDefsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeadFieldDefsInput, TenantUncheckedCreateWithoutLeadFieldDefsInput>
  }

  export type TenantUpsertWithoutLeadFieldDefsInput = {
    update: XOR<TenantUpdateWithoutLeadFieldDefsInput, TenantUncheckedUpdateWithoutLeadFieldDefsInput>
    create: XOR<TenantCreateWithoutLeadFieldDefsInput, TenantUncheckedCreateWithoutLeadFieldDefsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeadFieldDefsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeadFieldDefsInput, TenantUncheckedUpdateWithoutLeadFieldDefsInput>
  }

  export type TenantUpdateWithoutLeadFieldDefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeadFieldDefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutGmailTenantConnectionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutGmailTenantConnectionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutGmailTenantConnectionInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutGmailTenantConnectionInput, TenantUncheckedCreateWithoutGmailTenantConnectionInput>
  }

  export type UserCreateWithoutGmailTenantConnectionInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    tenant: TenantCreateNestedOneWithoutUsersInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGmailTenantConnectionInput = {
    id?: string
    tenantId: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGmailTenantConnectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGmailTenantConnectionInput, UserUncheckedCreateWithoutGmailTenantConnectionInput>
  }

  export type TenantUpsertWithoutGmailTenantConnectionInput = {
    update: XOR<TenantUpdateWithoutGmailTenantConnectionInput, TenantUncheckedUpdateWithoutGmailTenantConnectionInput>
    create: XOR<TenantCreateWithoutGmailTenantConnectionInput, TenantUncheckedCreateWithoutGmailTenantConnectionInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutGmailTenantConnectionInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutGmailTenantConnectionInput, TenantUncheckedUpdateWithoutGmailTenantConnectionInput>
  }

  export type TenantUpdateWithoutGmailTenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutGmailTenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutGmailTenantConnectionInput = {
    update: XOR<UserUpdateWithoutGmailTenantConnectionInput, UserUncheckedUpdateWithoutGmailTenantConnectionInput>
    create: XOR<UserCreateWithoutGmailTenantConnectionInput, UserUncheckedCreateWithoutGmailTenantConnectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGmailTenantConnectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGmailTenantConnectionInput, UserUncheckedUpdateWithoutGmailTenantConnectionInput>
  }

  export type UserUpdateWithoutGmailTenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGmailTenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TenantCreateWithoutMs365TenantConnectionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMs365TenantConnectionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMs365TenantConnectionInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMs365TenantConnectionInput, TenantUncheckedCreateWithoutMs365TenantConnectionInput>
  }

  export type UserCreateWithoutMs365TenantConnectionInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    tenant: TenantCreateNestedOneWithoutUsersInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMs365TenantConnectionInput = {
    id?: string
    tenantId: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMs365TenantConnectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMs365TenantConnectionInput, UserUncheckedCreateWithoutMs365TenantConnectionInput>
  }

  export type TenantUpsertWithoutMs365TenantConnectionInput = {
    update: XOR<TenantUpdateWithoutMs365TenantConnectionInput, TenantUncheckedUpdateWithoutMs365TenantConnectionInput>
    create: XOR<TenantCreateWithoutMs365TenantConnectionInput, TenantUncheckedCreateWithoutMs365TenantConnectionInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMs365TenantConnectionInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMs365TenantConnectionInput, TenantUncheckedUpdateWithoutMs365TenantConnectionInput>
  }

  export type TenantUpdateWithoutMs365TenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMs365TenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutMs365TenantConnectionInput = {
    update: XOR<UserUpdateWithoutMs365TenantConnectionInput, UserUncheckedUpdateWithoutMs365TenantConnectionInput>
    create: XOR<UserCreateWithoutMs365TenantConnectionInput, UserUncheckedCreateWithoutMs365TenantConnectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMs365TenantConnectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMs365TenantConnectionInput, UserUncheckedUpdateWithoutMs365TenantConnectionInput>
  }

  export type UserUpdateWithoutMs365TenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMs365TenantConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LeadCreateWithoutFollowUpLogsInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    tenant: TenantCreateNestedOneWithoutLeadsInput
    opportunity?: OpportunityCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageCreateNestedManyWithoutLeadInput
    Quote?: QuoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutFollowUpLogsInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityUncheckedCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutLeadInput
    Quote?: QuoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutFollowUpLogsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutFollowUpLogsInput, LeadUncheckedCreateWithoutFollowUpLogsInput>
  }

  export type LeadUpsertWithoutFollowUpLogsInput = {
    update: XOR<LeadUpdateWithoutFollowUpLogsInput, LeadUncheckedUpdateWithoutFollowUpLogsInput>
    create: XOR<LeadCreateWithoutFollowUpLogsInput, LeadUncheckedCreateWithoutFollowUpLogsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutFollowUpLogsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutFollowUpLogsInput, LeadUncheckedUpdateWithoutFollowUpLogsInput>
  }

  export type LeadUpdateWithoutFollowUpLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutFollowUpLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUncheckedUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type TenantCreateWithoutEmailThreadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmailThreadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmailThreadsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmailThreadsInput, TenantUncheckedCreateWithoutEmailThreadsInput>
  }

  export type LeadCreateWithoutEmailThreadsInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    tenant: TenantCreateNestedOneWithoutLeadsInput
    opportunity?: OpportunityCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageCreateNestedManyWithoutLeadInput
    Quote?: QuoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutEmailThreadsInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityUncheckedCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogUncheckedCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutLeadInput
    Quote?: QuoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutEmailThreadsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutEmailThreadsInput, LeadUncheckedCreateWithoutEmailThreadsInput>
  }

  export type OpportunityCreateWithoutEmailThreadsInput = {
    id?: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOpportunitiesInput
    lead: LeadCreateNestedOneWithoutOpportunityInput
    emailMessages?: EmailMessageCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutEmailThreadsInput = {
    id?: string
    tenantId: string
    leadId: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutEmailThreadsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutEmailThreadsInput, OpportunityUncheckedCreateWithoutEmailThreadsInput>
  }

  export type EmailMessageCreateWithoutThreadInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailMessagesInput
    lead?: LeadCreateNestedOneWithoutEmailMessagesInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailMessagesInput
  }

  export type EmailMessageUncheckedCreateWithoutThreadInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
    opportunityId?: string | null
  }

  export type EmailMessageCreateOrConnectWithoutThreadInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutThreadInput, EmailMessageUncheckedCreateWithoutThreadInput>
  }

  export type EmailMessageCreateManyThreadInputEnvelope = {
    data: EmailMessageCreateManyThreadInput | EmailMessageCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutEmailThreadsInput = {
    update: XOR<TenantUpdateWithoutEmailThreadsInput, TenantUncheckedUpdateWithoutEmailThreadsInput>
    create: XOR<TenantCreateWithoutEmailThreadsInput, TenantUncheckedCreateWithoutEmailThreadsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmailThreadsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmailThreadsInput, TenantUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type TenantUpdateWithoutEmailThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmailThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeadUpsertWithoutEmailThreadsInput = {
    update: XOR<LeadUpdateWithoutEmailThreadsInput, LeadUncheckedUpdateWithoutEmailThreadsInput>
    create: XOR<LeadCreateWithoutEmailThreadsInput, LeadUncheckedCreateWithoutEmailThreadsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutEmailThreadsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutEmailThreadsInput, LeadUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type LeadUpdateWithoutEmailThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutEmailThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUncheckedUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type OpportunityUpsertWithoutEmailThreadsInput = {
    update: XOR<OpportunityUpdateWithoutEmailThreadsInput, OpportunityUncheckedUpdateWithoutEmailThreadsInput>
    create: XOR<OpportunityCreateWithoutEmailThreadsInput, OpportunityUncheckedCreateWithoutEmailThreadsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutEmailThreadsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutEmailThreadsInput, OpportunityUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type OpportunityUpdateWithoutEmailThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOpportunitiesNestedInput
    lead?: LeadUpdateOneRequiredWithoutOpportunityNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutEmailThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutThreadInput, EmailMessageUncheckedUpdateWithoutThreadInput>
    create: XOR<EmailMessageCreateWithoutThreadInput, EmailMessageUncheckedCreateWithoutThreadInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutThreadInput, EmailMessageUncheckedUpdateWithoutThreadInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutThreadInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutThreadInput>
  }

  export type TenantCreateWithoutEmailMessagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmailMessagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmailMessagesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmailMessagesInput, TenantUncheckedCreateWithoutEmailMessagesInput>
  }

  export type EmailThreadCreateWithoutMessagesInput = {
    id?: string
    provider: string
    threadId: string
    subject?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmailThreadsInput
    lead?: LeadCreateNestedOneWithoutEmailThreadsInput
    opportunity?: OpportunityCreateNestedOneWithoutEmailThreadsInput
  }

  export type EmailThreadUncheckedCreateWithoutMessagesInput = {
    id?: string
    tenantId: string
    provider: string
    threadId: string
    subject?: string | null
    leadId?: string | null
    opportunityId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailThreadCreateOrConnectWithoutMessagesInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutMessagesInput, EmailThreadUncheckedCreateWithoutMessagesInput>
  }

  export type LeadCreateWithoutEmailMessagesInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    tenant: TenantCreateNestedOneWithoutLeadsInput
    opportunity?: OpportunityCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadCreateNestedManyWithoutLeadInput
    Quote?: QuoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutEmailMessagesInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityUncheckedCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogUncheckedCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutLeadInput
    Quote?: QuoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutEmailMessagesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutEmailMessagesInput, LeadUncheckedCreateWithoutEmailMessagesInput>
  }

  export type OpportunityCreateWithoutEmailMessagesInput = {
    id?: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOpportunitiesInput
    lead: LeadCreateNestedOneWithoutOpportunityInput
    emailThreads?: EmailThreadCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutEmailMessagesInput = {
    id?: string
    tenantId: string
    leadId: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutEmailMessagesInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutEmailMessagesInput, OpportunityUncheckedCreateWithoutEmailMessagesInput>
  }

  export type TenantUpsertWithoutEmailMessagesInput = {
    update: XOR<TenantUpdateWithoutEmailMessagesInput, TenantUncheckedUpdateWithoutEmailMessagesInput>
    create: XOR<TenantCreateWithoutEmailMessagesInput, TenantUncheckedCreateWithoutEmailMessagesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmailMessagesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmailMessagesInput, TenantUncheckedUpdateWithoutEmailMessagesInput>
  }

  export type TenantUpdateWithoutEmailMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmailMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type EmailThreadUpsertWithoutMessagesInput = {
    update: XOR<EmailThreadUpdateWithoutMessagesInput, EmailThreadUncheckedUpdateWithoutMessagesInput>
    create: XOR<EmailThreadCreateWithoutMessagesInput, EmailThreadUncheckedCreateWithoutMessagesInput>
    where?: EmailThreadWhereInput
  }

  export type EmailThreadUpdateToOneWithWhereWithoutMessagesInput = {
    where?: EmailThreadWhereInput
    data: XOR<EmailThreadUpdateWithoutMessagesInput, EmailThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type EmailThreadUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailThreadsNestedInput
    lead?: LeadUpdateOneWithoutEmailThreadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpsertWithoutEmailMessagesInput = {
    update: XOR<LeadUpdateWithoutEmailMessagesInput, LeadUncheckedUpdateWithoutEmailMessagesInput>
    create: XOR<LeadCreateWithoutEmailMessagesInput, LeadUncheckedCreateWithoutEmailMessagesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutEmailMessagesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutEmailMessagesInput, LeadUncheckedUpdateWithoutEmailMessagesInput>
  }

  export type LeadUpdateWithoutEmailMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutEmailMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUncheckedUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type OpportunityUpsertWithoutEmailMessagesInput = {
    update: XOR<OpportunityUpdateWithoutEmailMessagesInput, OpportunityUncheckedUpdateWithoutEmailMessagesInput>
    create: XOR<OpportunityCreateWithoutEmailMessagesInput, OpportunityUncheckedCreateWithoutEmailMessagesInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutEmailMessagesInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutEmailMessagesInput, OpportunityUncheckedUpdateWithoutEmailMessagesInput>
  }

  export type OpportunityUpdateWithoutEmailMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOpportunitiesNestedInput
    lead?: LeadUpdateOneRequiredWithoutOpportunityNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutEmailMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type TenantCreateWithoutQuotesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutQuotesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    UploadedFile?: UploadedFileUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutQuotesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutQuotesInput, TenantUncheckedCreateWithoutQuotesInput>
  }

  export type LeadCreateWithoutQuoteInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    tenant: TenantCreateNestedOneWithoutLeadsInput
    opportunity?: OpportunityCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutQuoteInput = {
    id?: string
    tenantId: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    opportunity?: OpportunityUncheckedCreateNestedOneWithoutLeadInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutLeadInput
    followUpLogs?: FollowUpLogUncheckedCreateNestedManyWithoutLeadInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutLeadInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutQuoteInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutQuoteInput, LeadUncheckedCreateWithoutQuoteInput>
  }

  export type UploadedFileCreateWithoutQuoteInput = {
    id?: string
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUploadedFileInput
  }

  export type UploadedFileUncheckedCreateWithoutQuoteInput = {
    id?: string
    tenantId: string
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
  }

  export type UploadedFileCreateOrConnectWithoutQuoteInput = {
    where: UploadedFileWhereUniqueInput
    create: XOR<UploadedFileCreateWithoutQuoteInput, UploadedFileUncheckedCreateWithoutQuoteInput>
  }

  export type UploadedFileCreateManyQuoteInputEnvelope = {
    data: UploadedFileCreateManyQuoteInput | UploadedFileCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type QuoteLineCreateWithoutQuoteInput = {
    id?: string
    supplier?: string | null
    sku?: string | null
    description: string
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryShareGBP?: Decimal | DecimalJsLike | number | string
    lineTotalGBP?: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineUncheckedCreateWithoutQuoteInput = {
    id?: string
    supplier?: string | null
    sku?: string | null
    description: string
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryShareGBP?: Decimal | DecimalJsLike | number | string
    lineTotalGBP?: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineCreateOrConnectWithoutQuoteInput = {
    where: QuoteLineWhereUniqueInput
    create: XOR<QuoteLineCreateWithoutQuoteInput, QuoteLineUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteLineCreateManyQuoteInputEnvelope = {
    data: QuoteLineCreateManyQuoteInput | QuoteLineCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutQuotesInput = {
    update: XOR<TenantUpdateWithoutQuotesInput, TenantUncheckedUpdateWithoutQuotesInput>
    create: XOR<TenantCreateWithoutQuotesInput, TenantUncheckedCreateWithoutQuotesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutQuotesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutQuotesInput, TenantUncheckedUpdateWithoutQuotesInput>
  }

  export type TenantUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    UploadedFile?: UploadedFileUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeadUpsertWithoutQuoteInput = {
    update: XOR<LeadUpdateWithoutQuoteInput, LeadUncheckedUpdateWithoutQuoteInput>
    create: XOR<LeadCreateWithoutQuoteInput, LeadUncheckedCreateWithoutQuoteInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutQuoteInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutQuoteInput, LeadUncheckedUpdateWithoutQuoteInput>
  }

  export type LeadUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUncheckedUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type UploadedFileUpsertWithWhereUniqueWithoutQuoteInput = {
    where: UploadedFileWhereUniqueInput
    update: XOR<UploadedFileUpdateWithoutQuoteInput, UploadedFileUncheckedUpdateWithoutQuoteInput>
    create: XOR<UploadedFileCreateWithoutQuoteInput, UploadedFileUncheckedCreateWithoutQuoteInput>
  }

  export type UploadedFileUpdateWithWhereUniqueWithoutQuoteInput = {
    where: UploadedFileWhereUniqueInput
    data: XOR<UploadedFileUpdateWithoutQuoteInput, UploadedFileUncheckedUpdateWithoutQuoteInput>
  }

  export type UploadedFileUpdateManyWithWhereWithoutQuoteInput = {
    where: UploadedFileScalarWhereInput
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuoteLineUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuoteLineWhereUniqueInput
    update: XOR<QuoteLineUpdateWithoutQuoteInput, QuoteLineUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuoteLineCreateWithoutQuoteInput, QuoteLineUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteLineUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuoteLineWhereUniqueInput
    data: XOR<QuoteLineUpdateWithoutQuoteInput, QuoteLineUncheckedUpdateWithoutQuoteInput>
  }

  export type QuoteLineUpdateManyWithWhereWithoutQuoteInput = {
    where: QuoteLineScalarWhereInput
    data: XOR<QuoteLineUpdateManyMutationInput, QuoteLineUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuoteLineScalarWhereInput = {
    AND?: QuoteLineScalarWhereInput | QuoteLineScalarWhereInput[]
    OR?: QuoteLineScalarWhereInput[]
    NOT?: QuoteLineScalarWhereInput | QuoteLineScalarWhereInput[]
    id?: StringFilter<"QuoteLine"> | string
    quoteId?: StringFilter<"QuoteLine"> | string
    supplier?: StringNullableFilter<"QuoteLine"> | string | null
    sku?: StringNullableFilter<"QuoteLine"> | string | null
    description?: StringFilter<"QuoteLine"> | string
    qty?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"QuoteLine"> | string
    deliveryShareGBP?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFilter<"QuoteLine"> | Decimal | DecimalJsLike | number | string
    meta?: JsonNullableFilter<"QuoteLine">
  }

  export type QuoteCreateWithoutLinesInput = {
    id?: string
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutQuotesInput
    lead?: LeadCreateNestedOneWithoutQuoteInput
    supplierFiles?: UploadedFileCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutLinesInput = {
    id?: string
    tenantId: string
    leadId?: string | null
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierFiles?: UploadedFileUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutLinesInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutLinesInput, QuoteUncheckedCreateWithoutLinesInput>
  }

  export type QuoteUpsertWithoutLinesInput = {
    update: XOR<QuoteUpdateWithoutLinesInput, QuoteUncheckedUpdateWithoutLinesInput>
    create: XOR<QuoteCreateWithoutLinesInput, QuoteUncheckedCreateWithoutLinesInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutLinesInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutLinesInput, QuoteUncheckedUpdateWithoutLinesInput>
  }

  export type QuoteUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutQuotesNestedInput
    lead?: LeadUpdateOneWithoutQuoteNestedInput
    supplierFiles?: UploadedFileUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierFiles?: UploadedFileUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type TenantCreateWithoutUploadedFileInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageCreateNestedManyWithoutTenantInput
    quotes?: QuoteCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUploadedFileInput = {
    id?: string
    name: string
    createdAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    plan?: $Enums.Plan | null
    trialEndsAt?: Date | string | null
    discountCodeUsed?: string | null
    seatsOffice?: number
    seatsWorkshop?: number
    seatsDisplay?: number
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenantInput
    leadFieldDefs?: LeadFieldDefUncheckedCreateNestedManyWithoutTenantInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedOneWithoutTenantInput
    emailIngests?: EmailIngestUncheckedCreateNestedManyWithoutTenantInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTenantInput
    emailMessages?: EmailMessageUncheckedCreateNestedManyWithoutTenantInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUploadedFileInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUploadedFileInput, TenantUncheckedCreateWithoutUploadedFileInput>
  }

  export type QuoteCreateWithoutSupplierFilesInput = {
    id?: string
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutQuotesInput
    lead?: LeadCreateNestedOneWithoutQuoteInput
    lines?: QuoteLineCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutSupplierFilesInput = {
    id?: string
    tenantId: string
    leadId?: string | null
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: QuoteLineUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutSupplierFilesInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutSupplierFilesInput, QuoteUncheckedCreateWithoutSupplierFilesInput>
  }

  export type TenantUpsertWithoutUploadedFileInput = {
    update: XOR<TenantUpdateWithoutUploadedFileInput, TenantUncheckedUpdateWithoutUploadedFileInput>
    create: XOR<TenantCreateWithoutUploadedFileInput, TenantUncheckedCreateWithoutUploadedFileInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUploadedFileInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUploadedFileInput, TenantUncheckedUpdateWithoutUploadedFileInput>
  }

  export type TenantUpdateWithoutUploadedFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUploadedFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discountCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    seatsOffice?: IntFieldUpdateOperationsInput | number
    seatsWorkshop?: IntFieldUpdateOperationsInput | number
    seatsDisplay?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenantNestedInput
    leadFieldDefs?: LeadFieldDefUncheckedUpdateManyWithoutTenantNestedInput
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateOneWithoutTenantNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutTenantNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTenantNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutTenantNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type QuoteUpsertWithoutSupplierFilesInput = {
    update: XOR<QuoteUpdateWithoutSupplierFilesInput, QuoteUncheckedUpdateWithoutSupplierFilesInput>
    create: XOR<QuoteCreateWithoutSupplierFilesInput, QuoteUncheckedCreateWithoutSupplierFilesInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutSupplierFilesInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutSupplierFilesInput, QuoteUncheckedUpdateWithoutSupplierFilesInput>
  }

  export type QuoteUpdateWithoutSupplierFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutQuotesNestedInput
    lead?: LeadUpdateOneWithoutQuoteNestedInput
    lines?: QuoteLineUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutSupplierFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: QuoteLineUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type UserCreateWithoutPasswordResetTokenInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    tenant: TenantCreateNestedOneWithoutUsersInput
    GmailTenantConnection?: GmailTenantConnectionCreateNestedManyWithoutConnectedByInput
    Ms365TenantConnection?: Ms365TenantConnectionCreateNestedManyWithoutConnectedByInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokenInput = {
    id?: string
    tenantId: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
    GmailTenantConnection?: GmailTenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedCreateNestedManyWithoutConnectedByInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
  }

  export type UserUpsertWithoutPasswordResetTokenInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokenInput, UserUncheckedUpdateWithoutPasswordResetTokenInput>
    create: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokenInput, UserUncheckedUpdateWithoutPasswordResetTokenInput>
  }

  export type UserUpdateWithoutPasswordResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    GmailTenantConnection?: GmailTenantConnectionUpdateManyWithoutConnectedByNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateManyWithoutConnectedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    passwordHash: string
  }

  export type LeadCreateManyTenantInput = {
    id?: string
    createdById: string
    contactName: string
    email?: string | null
    status?: $Enums.LeadStatus
    capturedAt?: Date | string
    nextActionAt?: Date | string | null
    nextAction?: string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
  }

  export type OpportunityCreateManyTenantInput = {
    id?: string
    leadId: string
    title: string
    valueGBP?: Decimal | DecimalJsLike | number | string | null
    stage?: $Enums.OppStage
    wonAt?: Date | string | null
    lostAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LeadFieldDefCreateManyTenantInput = {
    id?: string
    key: string
    label: string
    type?: string
    required?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
  }

  export type EmailIngestCreateManyTenantInput = {
    id?: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    leadId?: string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailThreadCreateManyTenantInput = {
    id?: string
    provider: string
    threadId: string
    subject?: string | null
    leadId?: string | null
    opportunityId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailMessageCreateManyTenantInput = {
    id?: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
    opportunityId?: string | null
  }

  export type QuoteCreateManyTenantInput = {
    id?: string
    leadId?: string | null
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UploadedFileCreateManyTenantInput = {
    id?: string
    quoteId?: string | null
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    GmailTenantConnection?: GmailTenantConnectionUpdateManyWithoutConnectedByNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    GmailTenantConnection?: GmailTenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    Ms365TenantConnection?: Ms365TenantConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type LeadUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    opportunity?: OpportunityUncheckedUpdateOneWithoutLeadNestedInput
    emailIngests?: EmailIngestUncheckedUpdateManyWithoutLeadNestedInput
    followUpLogs?: FollowUpLogUncheckedUpdateManyWithoutLeadNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutLeadNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutLeadNestedInput
    Quote?: QuoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAction?: NullableStringFieldUpdateOperationsInput | string | null
    briefJson?: NullableJsonNullValueInput | InputJsonValue
    custom?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpportunityUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutOpportunityNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutOpportunityNestedInput
    emailMessages?: EmailMessageUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutOpportunityNestedInput
    emailMessages?: EmailMessageUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    valueGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stage?: EnumOppStageFieldUpdateOperationsInput | $Enums.OppStage
    wonAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadFieldDefUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type LeadFieldDefUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type LeadFieldDefUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type EmailIngestUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutEmailIngestsNestedInput
  }

  export type EmailIngestUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIngestUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailThreadUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutEmailThreadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailThreadsNestedInput
    messages?: EmailMessageUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EmailMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: EmailThreadUpdateOneRequiredWithoutMessagesNestedInput
    lead?: LeadUpdateOneWithoutEmailMessagesNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailMessagesNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailMessageUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuoteUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneWithoutQuoteNestedInput
    supplierFiles?: UploadedFileUpdateManyWithoutQuoteNestedInput
    lines?: QuoteLineUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierFiles?: UploadedFileUncheckedUpdateManyWithoutQuoteNestedInput
    lines?: QuoteLineUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneWithoutSupplierFilesNestedInput
  }

  export type UploadedFileUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailTenantConnectionCreateManyConnectedByInput = {
    id?: string
    tenantId: string
    gmailAddress?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Ms365TenantConnectionCreateManyConnectedByInput = {
    id?: string
    tenantId: string
    ms365Address?: string | null
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailTenantConnectionUpdateWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutGmailTenantConnectionNestedInput
  }

  export type GmailTenantConnectionUncheckedUpdateWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailTenantConnectionUncheckedUpdateManyWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    gmailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Ms365TenantConnectionUpdateWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMs365TenantConnectionNestedInput
  }

  export type Ms365TenantConnectionUncheckedUpdateWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Ms365TenantConnectionUncheckedUpdateManyWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ms365Address?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIngestCreateManyLeadInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    subject?: string | null
    snippet?: string | null
    processedAt?: Date | string | null
    aiPredictedIsLead?: boolean | null
    userLabelIsLead?: boolean | null
    userLabeledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FollowUpLogCreateManyLeadInput = {
    id?: string
    tenantId: string
    variant: string
    subject: string
    body: string
    sentAt?: Date | string
    opened?: boolean | null
    replied?: boolean | null
    converted?: boolean | null
    delayDays?: number | null
    provider?: string | null
    messageId?: string | null
    threadId?: string | null
  }

  export type EmailThreadCreateManyLeadInput = {
    id?: string
    tenantId: string
    provider: string
    threadId: string
    subject?: string | null
    opportunityId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailMessageCreateManyLeadInput = {
    id?: string
    tenantId: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    opportunityId?: string | null
  }

  export type QuoteCreateManyLeadInput = {
    id?: string
    tenantId: string
    title: string
    status?: $Enums.QuoteStatus
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    deliveryCost?: Decimal | DecimalJsLike | number | string | null
    markupDefault?: Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: Decimal | DecimalJsLike | number | string | null
    totalGBP?: Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: string | null
    notes?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailIngestUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailIngestsNestedInput
  }

  export type EmailIngestUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIngestUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiPredictedIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabelIsLead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userLabeledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpLogUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: NullableBoolFieldUpdateOperationsInput | boolean | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delayDays?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowUpLogUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: NullableBoolFieldUpdateOperationsInput | boolean | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delayDays?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowUpLogUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: NullableBoolFieldUpdateOperationsInput | boolean | null
    replied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delayDays?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailThreadUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailThreadsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailThreadsNestedInput
    messages?: EmailMessageUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EmailMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailMessagesNestedInput
    thread?: EmailThreadUpdateOneRequiredWithoutMessagesNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailMessagesNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailMessageUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuoteUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutQuotesNestedInput
    supplierFiles?: UploadedFileUpdateManyWithoutQuoteNestedInput
    lines?: QuoteLineUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierFiles?: UploadedFileUncheckedUpdateManyWithoutQuoteNestedInput
    lines?: QuoteLineUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    markupDefault?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalMaterialGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalLabourGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotalOtherGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalGBP?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proposalPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailThreadCreateManyOpportunityInput = {
    id?: string
    tenantId: string
    provider: string
    threadId: string
    subject?: string | null
    leadId?: string | null
    lastInboundAt?: Date | string | null
    lastOutboundAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailMessageCreateManyOpportunityInput = {
    id?: string
    tenantId: string
    threadId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
  }

  export type EmailThreadUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailThreadsNestedInput
    lead?: LeadUpdateOneWithoutEmailThreadsNestedInput
    messages?: EmailMessageUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: EmailMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    lastInboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOutboundAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailMessagesNestedInput
    thread?: EmailThreadUpdateOneRequiredWithoutMessagesNestedInput
    lead?: LeadUpdateOneWithoutEmailMessagesNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailMessageUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailMessageCreateManyThreadInput = {
    id?: string
    tenantId: string
    provider: string
    messageId: string
    fromEmail?: string | null
    toEmail?: string | null
    cc?: string | null
    bcc?: string | null
    subject?: string | null
    snippet?: string | null
    bodyText?: string | null
    bodyHtml?: string | null
    direction: string
    sentAt: Date | string
    createdAt?: Date | string
    leadId?: string | null
    opportunityId?: string | null
  }

  export type EmailMessageUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmailMessagesNestedInput
    lead?: LeadUpdateOneWithoutEmailMessagesNestedInput
    opportunity?: OpportunityUpdateOneWithoutEmailMessagesNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailMessageUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmail?: NullableStringFieldUpdateOperationsInput | string | null
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    bodyText?: NullableStringFieldUpdateOperationsInput | string | null
    bodyHtml?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UploadedFileCreateManyQuoteInput = {
    id?: string
    tenantId: string
    kind: $Enums.FileKind
    name: string
    path: string
    mimeType?: string | null
    sizeBytes?: number | null
    uploadedAt?: Date | string
  }

  export type QuoteLineCreateManyQuoteInput = {
    id?: string
    supplier?: string | null
    sku?: string | null
    description: string
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    deliveryShareGBP?: Decimal | DecimalJsLike | number | string
    lineTotalGBP?: Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UploadedFileUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUploadedFileNestedInput
  }

  export type UploadedFileUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kind?: EnumFileKindFieldUpdateOperationsInput | $Enums.FileKind
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteLineUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryShareGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryShareGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuoteLineUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    deliveryShareGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotalGBP?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meta?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}